!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
APIENTRY	libs/imgui/imgui_impl_glfw_gl3.cpp	11;"	d	file:
Accessed	libs/imgui/imgui.cpp	/^    bool                    Accessed;                           \/\/ Set to true when any widget access the current window$/;"	m	struct:ImGuiWindow	file:	access:public
Active	libs/imgui/imgui.cpp	/^    bool                    Active;                             \/\/ Set to true on Begin()$/;"	m	struct:ImGuiWindow	file:	access:public
ActiveClickDeltaToCenter	libs/imgui/imgui.cpp	/^    ImVec2                  ActiveClickDeltaToCenter;$/;"	m	struct:ImGuiState	file:	access:public
ActiveId	libs/imgui/imgui.cpp	/^    ImGuiID                 ActiveId;                           \/\/ Active widget$/;"	m	struct:ImGuiState	file:	access:public
ActiveIdIsAlive	libs/imgui/imgui.cpp	/^    bool                    ActiveIdIsAlive;$/;"	m	struct:ImGuiState	file:	access:public
ActiveIdIsFocusedOnly	libs/imgui/imgui.cpp	/^    bool                    ActiveIdIsFocusedOnly;              \/\/ Set only by active widget. Denote focus but no active interaction$/;"	m	struct:ImGuiState	file:	access:public
ActiveIdIsJustActivated	libs/imgui/imgui.cpp	/^    bool                    ActiveIdIsJustActivated;            \/\/ Set at the time of activation for one frame$/;"	m	struct:ImGuiState	file:	access:public
ActiveIdPreviousFrame	libs/imgui/imgui.cpp	/^    ImGuiID                 ActiveIdPreviousFrame;$/;"	m	struct:ImGuiState	file:	access:public
ActiveIdWindow	libs/imgui/imgui.cpp	/^    ImGuiWindow*            ActiveIdWindow;$/;"	m	struct:ImGuiState	file:	access:public
Add	libs/imgui/imgui.cpp	/^    void        Add(const ImRect& rhs)              { Min.x = ImMin(Min.x, rhs.Min.x); Min.y = ImMin(Min.y, rhs.Min.y); Max.x = ImMax(Max.x, rhs.Max.x); Max.y = ImMax(Max.y, rhs.Max.y); }$/;"	f	struct:ImRect	access:public	signature:(const ImRect& rhs)
Add	libs/imgui/imgui.cpp	/^    void        Add(const ImVec2& rhs)              { Min.x = ImMin(Min.x, rhs.x); Min.y = ImMin(Min.y, rhs.y); Max.x = ImMax(Max.x, rhs.x); Max.y = ImMax(Max.y, rhs.y); }$/;"	f	struct:ImRect	access:public	signature:(const ImVec2& rhs)
AddCallback	libs/imgui/imgui.cpp	/^void ImDrawList::AddCallback(ImDrawCallback callback, void* callback_data)$/;"	f	class:ImDrawList	signature:(ImDrawCallback callback, void* callback_data)
AddCallback	libs/imgui/imgui.h	/^    IMGUI_API void  AddCallback(ImDrawCallback callback, void* callback_data);  \/\/ Your rendering function must check for 'UserCallback' in ImDrawCmd and call the function instead of rendering triangles.$/;"	p	struct:ImDrawList	access:public	signature:(ImDrawCallback callback, void* callback_data)
AddCircle	libs/imgui/imgui.cpp	/^void ImDrawList::AddCircle(const ImVec2& centre, float radius, ImU32 col, int num_segments)$/;"	f	class:ImDrawList	signature:(const ImVec2& centre, float radius, ImU32 col, int num_segments)
AddCircle	libs/imgui/imgui.h	/^    IMGUI_API void  AddCircle(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12)
AddCircleFilled	libs/imgui/imgui.cpp	/^void ImDrawList::AddCircleFilled(const ImVec2& centre, float radius, ImU32 col, int num_segments)$/;"	f	class:ImDrawList	signature:(const ImVec2& centre, float radius, ImU32 col, int num_segments)
AddCircleFilled	libs/imgui/imgui.h	/^    IMGUI_API void  AddCircleFilled(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12)
AddConvexPolyFilled	libs/imgui/imgui.cpp	/^void ImDrawList::AddConvexPolyFilled(const ImVec2* points, const int points_count, ImU32 col, bool anti_aliased)$/;"	f	class:ImDrawList	signature:(const ImVec2* points, const int points_count, ImU32 col, bool anti_aliased)
AddConvexPolyFilled	libs/imgui/imgui.h	/^    IMGUI_API void  AddConvexPolyFilled(const ImVec2* points, const int num_points, ImU32 col, bool anti_aliased);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2* points, const int num_points, ImU32 col, bool anti_aliased)
AddDrawCmd	libs/imgui/imgui.cpp	/^void ImDrawList::AddDrawCmd()$/;"	f	class:ImDrawList	signature:()
AddDrawCmd	libs/imgui/imgui.h	/^    IMGUI_API void  AddDrawCmd();                                               \/\/ This is useful if you need to forcefully create a new draw call (to allow for dependent rendering \/ blending). Otherwise primitives are merged into the same draw-call as much as possible$/;"	p	struct:ImDrawList	access:public	signature:()
AddDrawListToRenderList	libs/imgui/imgui.cpp	/^static inline void AddDrawListToRenderList(ImVector<ImDrawList*>& out_render_list, ImDrawList* draw_list)$/;"	f	file:	signature:(ImVector<ImDrawList*>& out_render_list, ImDrawList* draw_list)
AddFont	libs/imgui/imgui.cpp	/^ImFont* ImFontAtlas::AddFont(const ImFontConfig* font_cfg)$/;"	f	class:ImFontAtlas	signature:(const ImFontConfig* font_cfg)
AddFont	libs/imgui/imgui.h	/^    IMGUI_API ImFont*           AddFont(const ImFontConfig* font_cfg);$/;"	p	struct:ImFontAtlas	access:public	signature:(const ImFontConfig* font_cfg)
AddFontDefault	libs/imgui/imgui.cpp	/^ImFont* ImFontAtlas::AddFontDefault(const ImFontConfig* font_cfg_template)$/;"	f	class:ImFontAtlas	signature:(const ImFontConfig* font_cfg_template)
AddFontDefault	libs/imgui/imgui.h	/^    IMGUI_API ImFont*           AddFontDefault(const ImFontConfig* font_cfg = NULL);$/;"	p	struct:ImFontAtlas	access:public	signature:(const ImFontConfig* font_cfg = NULL)
AddFontFromFileTTF	libs/imgui/imgui.cpp	/^ImFont* ImFontAtlas::AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)$/;"	f	class:ImFontAtlas	signature:(const char* filename, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
AddFontFromFileTTF	libs/imgui/imgui.h	/^    IMGUI_API ImFont*           AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);$/;"	p	struct:ImFontAtlas	access:public	signature:(const char* filename, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL)
AddFontFromMemoryCompressedBase85TTF	libs/imgui/imgui.cpp	/^ImFont* ImFontAtlas::AddFontFromMemoryCompressedBase85TTF(const char* compressed_ttf_data_base85, float size_pixels, const ImFontConfig* font_cfg, const ImWchar* glyph_ranges)$/;"	f	class:ImFontAtlas	signature:(const char* compressed_ttf_data_base85, float size_pixels, const ImFontConfig* font_cfg, const ImWchar* glyph_ranges)
AddFontFromMemoryCompressedBase85TTF	libs/imgui/imgui.h	/^    IMGUI_API ImFont*           AddFontFromMemoryCompressedBase85TTF(const char* compressed_ttf_data_base85, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);              \/\/ 'compressed_ttf_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 paramaeter$/;"	p	struct:ImFontAtlas	access:public	signature:(const char* compressed_ttf_data_base85, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL)
AddFontFromMemoryCompressedTTF	libs/imgui/imgui.cpp	/^ImFont* ImFontAtlas::AddFontFromMemoryCompressedTTF(const void* compressed_ttf_data, int compressed_ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)$/;"	f	class:ImFontAtlas	signature:(const void* compressed_ttf_data, int compressed_ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
AddFontFromMemoryCompressedTTF	libs/imgui/imgui.h	/^    IMGUI_API ImFont*           AddFontFromMemoryCompressedTTF(const void* compressed_ttf_data, int compressed_ttf_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);  \/\/ 'compressed_ttf_data' still owned by caller. Compress with binary_to_compressed_c.cpp$/;"	p	struct:ImFontAtlas	access:public	signature:(const void* compressed_ttf_data, int compressed_ttf_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL)
AddFontFromMemoryTTF	libs/imgui/imgui.cpp	/^ImFont* ImFontAtlas::AddFontFromMemoryTTF(void* ttf_data, int ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)$/;"	f	class:ImFontAtlas	signature:(void* ttf_data, int ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
AddFontFromMemoryTTF	libs/imgui/imgui.h	/^    IMGUI_API ImFont*           AddFontFromMemoryTTF(void* ttf_data, int ttf_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);                                        \/\/ Transfer ownership of 'ttf_data' to ImFontAtlas, will be deleted after Build()$/;"	p	struct:ImFontAtlas	access:public	signature:(void* ttf_data, int ttf_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL)
AddImage	libs/imgui/imgui.cpp	/^void ImDrawList::AddImage(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv0, const ImVec2& uv1, ImU32 col)$/;"	f	class:ImDrawList	signature:(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv0, const ImVec2& uv1, ImU32 col)
AddImage	libs/imgui/imgui.h	/^    IMGUI_API void  AddImage(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv0, const ImVec2& uv1, ImU32 col = 0xFFFFFFFF);$/;"	p	struct:ImDrawList	access:public	signature:(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv0, const ImVec2& uv1, ImU32 col = 0xFFFFFFFF)
AddInputCharacter	libs/imgui/imgui.cpp	/^void ImGuiIO::AddInputCharacter(ImWchar c)$/;"	f	class:ImGuiIO	signature:(ImWchar c)
AddInputCharacter	libs/imgui/imgui.h	/^    IMGUI_API void AddInputCharacter(ImWchar c);                    \/\/ Helper to add a new character into InputCharacters[]$/;"	p	struct:ImGuiIO	access:public	signature:(ImWchar c)
AddInputCharactersUTF8	libs/imgui/imgui.cpp	/^void ImGuiIO::AddInputCharactersUTF8(const char* utf8_chars)$/;"	f	class:ImGuiIO	signature:(const char* utf8_chars)
AddInputCharactersUTF8	libs/imgui/imgui.h	/^    IMGUI_API void AddInputCharactersUTF8(const char* utf8_chars);  \/\/ Helper to add new characters into InputCharacters[] from an UTF-8 string$/;"	p	struct:ImGuiIO	access:public	signature:(const char* utf8_chars)
AddLine	libs/imgui/imgui.cpp	/^void ImDrawList::AddLine(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness)
AddLine	libs/imgui/imgui.h	/^    IMGUI_API void  AddLine(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness = 1.0f);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness = 1.0f)
AddLog	libs/imgui/imgui.cpp	/^    void    AddLog(const char* fmt, ...)$/;"	f	struct:ExampleAppConsole	access:public	signature:(const char* fmt, ...)
AddLog	src/util/Console.cpp	/^	void    AddLog(const char* fmt, ...)$/;"	f	struct:Console::Console	access:public	signature:(const char* fmt, ...)
AddPolyline	libs/imgui/imgui.cpp	/^void ImDrawList::AddPolyline(const ImVec2* points, const int points_count, ImU32 col, bool closed, float thickness, bool anti_aliased)$/;"	f	class:ImDrawList	signature:(const ImVec2* points, const int points_count, ImU32 col, bool closed, float thickness, bool anti_aliased)
AddPolyline	libs/imgui/imgui.h	/^    IMGUI_API void  AddPolyline(const ImVec2* points, const int num_points, ImU32 col, bool closed, float thickness, bool anti_aliased);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2* points, const int num_points, ImU32 col, bool closed, float thickness, bool anti_aliased)
AddRect	libs/imgui/imgui.cpp	/^void ImDrawList::AddRect(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding, int rounding_corners)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding, int rounding_corners)
AddRect	libs/imgui/imgui.h	/^    IMGUI_API void  AddRect(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners = 0x0F);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners = 0x0F)
AddRectFilled	libs/imgui/imgui.cpp	/^void ImDrawList::AddRectFilled(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding, int rounding_corners)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding, int rounding_corners)
AddRectFilled	libs/imgui/imgui.h	/^    IMGUI_API void  AddRectFilled(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners = 0x0F);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners = 0x0F)
AddRectFilledMultiColor	libs/imgui/imgui.cpp	/^void ImDrawList::AddRectFilledMultiColor(const ImVec2& a, const ImVec2& c, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& c, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left)
AddRectFilledMultiColor	libs/imgui/imgui.h	/^    IMGUI_API void  AddRectFilledMultiColor(const ImVec2& a, const ImVec2& b, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left)
AddText	libs/imgui/imgui.cpp	/^void ImDrawList::AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end, float wrap_width, const ImVec4* cpu_fine_clip_rect)$/;"	f	class:ImDrawList	signature:(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end, float wrap_width, const ImVec4* cpu_fine_clip_rect)
AddText	libs/imgui/imgui.cpp	/^void ImDrawList::AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end)$/;"	f	class:ImDrawList	signature:(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end)
AddText	libs/imgui/imgui.h	/^    IMGUI_API void  AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL, float wrap_width = 0.0f, const ImVec4* cpu_fine_clip_rect = NULL);$/;"	p	struct:ImDrawList	access:public	signature:(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL, float wrap_width = 0.0f, const ImVec4* cpu_fine_clip_rect = NULL)
AddText	libs/imgui/imgui.h	/^    IMGUI_API void  AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL)
AddTriangleFilled	libs/imgui/imgui.cpp	/^void ImDrawList::AddTriangleFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col)
AddTriangleFilled	libs/imgui/imgui.h	/^    IMGUI_API void  AddTriangleFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col)
AddWindowSettings	libs/imgui/imgui.cpp	/^static ImGuiIniData* AddWindowSettings(const char* name)$/;"	f	file:	signature:(const char* name)
AddWindowToRenderList	libs/imgui/imgui.cpp	/^static void AddWindowToRenderList(ImVector<ImDrawList*>& out_render_list, ImGuiWindow* window)$/;"	f	file:	signature:(ImVector<ImDrawList*>& out_render_list, ImGuiWindow* window)
AddWindowToSortedBuffer	libs/imgui/imgui.cpp	/^static void AddWindowToSortedBuffer(ImVector<ImGuiWindow*>& out_sorted_windows, ImGuiWindow* window)$/;"	f	file:	signature:(ImVector<ImGuiWindow*>& out_sorted_windows, ImGuiWindow* window)
AdvanceCursor	libs/imgui/imgui.cpp	/^    bool   AdvanceCursor;$/;"	m	struct:ImGuiGroupData	file:	access:public
AlignFirstTextHeightToWidgets	libs/imgui/imgui.cpp	/^void ImGui::AlignFirstTextHeightToWidgets()$/;"	f	class:ImGui	signature:()
AlignFirstTextHeightToWidgets	libs/imgui/imgui.h	/^    IMGUI_API void          AlignFirstTextHeightToWidgets();                                    \/\/ call once if the first item on the line is a Text() item and you want to vertically lower it to match subsequent (bigger) widgets$/;"	p	namespace:ImGui	signature:()
AllowKeyboardFocus	libs/imgui/imgui.cpp	/^    bool                    AllowKeyboardFocus;     \/\/ == AllowKeyboardFocusStack.back() [empty == true]$/;"	m	struct:ImGuiDrawContext	file:	access:public
AllowKeyboardFocusStack	libs/imgui/imgui.cpp	/^    ImVector<bool>          AllowKeyboardFocusStack;$/;"	m	struct:ImGuiDrawContext	file:	access:public
Alpha	libs/imgui/imgui.h	/^    float       Alpha;                      \/\/ Global alpha applies to everything in ImGui$/;"	m	struct:ImGuiStyle	access:public
AntiAliasedLines	libs/imgui/imgui.h	/^    bool        AntiAliasedLines;           \/\/ Enable anti-aliasing on lines\/borders. Disable if you are really tight on CPU\/GPU.$/;"	m	struct:ImGuiStyle	access:public
AntiAliasedShapes	libs/imgui/imgui.h	/^    bool        AntiAliasedShapes;          \/\/ Enable anti-aliasing on filled shapes (rounded rectangles, circles, etc.)$/;"	m	struct:ImGuiStyle	access:public
Ascent	libs/imgui/imgui.h	/^    float                       Ascent, Descent;    \/\/ Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]$/;"	m	struct:ImFont	access:public
AutoFitFramesX	libs/imgui/imgui.cpp	/^    int                     AutoFitFramesX, AutoFitFramesY;$/;"	m	struct:ImGuiWindow	file:	access:public
AutoFitFramesY	libs/imgui/imgui.cpp	/^    int                     AutoFitFramesX, AutoFitFramesY;$/;"	m	struct:ImGuiWindow	file:	access:public
AutoFitOnlyGrows	libs/imgui/imgui.cpp	/^    bool                    AutoFitOnlyGrows;$/;"	m	struct:ImGuiWindow	file:	access:public
AutoPosLastDirection	libs/imgui/imgui.cpp	/^    int                     AutoPosLastDirection;$/;"	m	struct:ImGuiWindow	file:	access:public
BackupColumnsStartX	libs/imgui/imgui.cpp	/^    float  BackupColumnsStartX;$/;"	m	struct:ImGuiGroupData	file:	access:public
BackupCurrentLineHeight	libs/imgui/imgui.cpp	/^    float  BackupCurrentLineHeight;$/;"	m	struct:ImGuiGroupData	file:	access:public
BackupCurrentLineTextBaseOffset	libs/imgui/imgui.cpp	/^    float  BackupCurrentLineTextBaseOffset;$/;"	m	struct:ImGuiGroupData	file:	access:public
BackupCursorMaxPos	libs/imgui/imgui.cpp	/^    ImVec2 BackupCursorMaxPos;$/;"	m	struct:ImGuiGroupData	file:	access:public
BackupCursorPos	libs/imgui/imgui.cpp	/^    ImVec2 BackupCursorPos;$/;"	m	struct:ImGuiGroupData	file:	access:public
BackupLogLinePosY	libs/imgui/imgui.cpp	/^    float  BackupLogLinePosY;$/;"	m	struct:ImGuiGroupData	file:	access:public
Begin	libs/imgui/imgui.cpp	/^bool ImGui::Begin(const char* name, bool* p_opened, ImGuiWindowFlags flags)$/;"	f	class:ImGui	signature:(const char* name, bool* p_opened, ImGuiWindowFlags flags)
Begin	libs/imgui/imgui.cpp	/^bool ImGui::Begin(const char* name, bool* p_opened, const ImVec2& size_on_first_use, float bg_alpha, ImGuiWindowFlags flags)$/;"	f	class:ImGui	signature:(const char* name, bool* p_opened, const ImVec2& size_on_first_use, float bg_alpha, ImGuiWindowFlags flags)
Begin	libs/imgui/imgui.h	/^    IMGUI_API bool          Begin(const char* name = "Debug", bool* p_opened = NULL, ImGuiWindowFlags flags = 0);                                           \/\/ see .cpp for details. return false when window is collapsed, so you can early out in your code. 'bool* p_opened' creates a widget on the upper-right to close the window (which sets your bool to false). $/;"	p	namespace:ImGui	signature:(const char* name = Ó, bool* p_opened = NULL, ImGuiWindowFlags flags = 0)
Begin	libs/imgui/imgui.h	/^    IMGUI_API bool          Begin(const char* name, bool* p_opened, const ImVec2& size_on_first_use, float bg_alpha = -1.0f, ImGuiWindowFlags flags = 0);   \/\/ this is the older\/longer API. call SetNextWindowSize() instead if you want to set a window size. For regular windows, 'size_on_first_use' only applies to the first time EVER the window is created and probably not what you want! maybe obsolete this API eventually.$/;"	p	namespace:ImGui	signature:(const char* name, bool* p_opened, const ImVec2& size_on_first_use, float bg_alpha = -1.0f, ImGuiWindowFlags flags = 0)
Begin	libs/imgui/imgui.h	/^    void Begin(int count, float height)        \/\/ items_height: generally pass GetTextLineHeightWithSpacing() or GetItemsLineHeightWithSpacing()$/;"	f	struct:ImGuiListClipper	access:public	signature:(int count, float height)
BeginChild	libs/imgui/imgui.cpp	/^bool ImGui::BeginChild(ImGuiID id, const ImVec2& size, bool border, ImGuiWindowFlags extra_flags)$/;"	f	class:ImGui	signature:(ImGuiID id, const ImVec2& size, bool border, ImGuiWindowFlags extra_flags)
BeginChild	libs/imgui/imgui.cpp	/^bool ImGui::BeginChild(const char* str_id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* str_id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)
BeginChild	libs/imgui/imgui.h	/^    IMGUI_API bool          BeginChild(ImGuiID id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags extra_flags = 0);                \/\/ "$/;"	p	namespace:ImGui	signature:(ImGuiID id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags extra_flags = 0)
BeginChild	libs/imgui/imgui.h	/^    IMGUI_API bool          BeginChild(const char* str_id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags extra_flags = 0);        \/\/ begin a scrolling region. size==0.0f: use remaining window size, size<0.0f: use remaining window size minus abs(size). size>0.0f: fixed size. each axis can use a different mode, e.g. ImVec2(0,400).$/;"	p	namespace:ImGui	signature:(const char* str_id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags extra_flags = 0)
BeginChildFrame	libs/imgui/imgui.cpp	/^bool ImGui::BeginChildFrame(ImGuiID id, const ImVec2& size)$/;"	f	class:ImGui	signature:(ImGuiID id, const ImVec2& size)
BeginChildFrame	libs/imgui/imgui.h	/^    IMGUI_API bool          BeginChildFrame(ImGuiID id, const ImVec2& size);                    \/\/ helper to create a child window \/ scrolling region that looks like a normal widget frame$/;"	p	namespace:ImGui	signature:(ImGuiID id, const ImVec2& size)
BeginCount	libs/imgui/imgui.cpp	/^    int                     BeginCount;                         \/\/ Number of Begin() during the current frame (generally 0 or 1, 1+ if appending via multiple Begin\/End pairs)$/;"	m	struct:ImGuiWindow	file:	access:public
BeginGroup	libs/imgui/imgui.cpp	/^void ImGui::BeginGroup()$/;"	f	class:ImGui	signature:()
BeginGroup	libs/imgui/imgui.h	/^    IMGUI_API void          BeginGroup();                                                       \/\/ once closing a group it is seen as a single item (so you can use IsItemHovered() on a group, SameLine() between groups, etc. $/;"	p	namespace:ImGui	signature:()
BeginMainMenuBar	libs/imgui/imgui.cpp	/^bool ImGui::BeginMainMenuBar()$/;"	f	class:ImGui	signature:()
BeginMainMenuBar	libs/imgui/imgui.h	/^    IMGUI_API bool          BeginMainMenuBar();                                                 \/\/ create and append to a full screen menu-bar. only call EndMainMenuBar() if this returns true!$/;"	p	namespace:ImGui	signature:()
BeginMenu	libs/imgui/imgui.cpp	/^bool ImGui::BeginMenu(const char* label, bool enabled)$/;"	f	class:ImGui	signature:(const char* label, bool enabled)
BeginMenu	libs/imgui/imgui.h	/^    IMGUI_API bool          BeginMenu(const char* label, bool enabled = true);                  \/\/ create a sub-menu entry. only call EndMenu() if this returns true!$/;"	p	namespace:ImGui	signature:(const char* label, bool enabled = true)
BeginMenuBar	libs/imgui/imgui.cpp	/^bool ImGui::BeginMenuBar()$/;"	f	class:ImGui	signature:()
BeginMenuBar	libs/imgui/imgui.h	/^    IMGUI_API bool          BeginMenuBar();                                                     \/\/ append to menu-bar of current window (requires ImGuiWindowFlags_MenuBar flag set). only call EndMenuBar() if this returns true!$/;"	p	namespace:ImGui	signature:()
BeginPopup	libs/imgui/imgui.cpp	/^bool ImGui::BeginPopup(const char* str_id)$/;"	f	class:ImGui	signature:(const char* str_id)
BeginPopup	libs/imgui/imgui.h	/^    IMGUI_API bool          BeginPopup(const char* str_id);                                     \/\/ return true if popup if opened and start outputting to it. only call EndPopup() if BeginPopup() returned true!$/;"	p	namespace:ImGui	signature:(const char* str_id)
BeginPopupContextItem	libs/imgui/imgui.cpp	/^bool ImGui::BeginPopupContextItem(const char* str_id, int mouse_button)$/;"	f	class:ImGui	signature:(const char* str_id, int mouse_button)
BeginPopupContextItem	libs/imgui/imgui.h	/^    IMGUI_API bool          BeginPopupContextItem(const char* str_id, int mouse_button = 1);                                        \/\/ helper to open and begin popup when clicked on last item$/;"	p	namespace:ImGui	signature:(const char* str_id, int mouse_button = 1)
BeginPopupContextVoid	libs/imgui/imgui.cpp	/^bool ImGui::BeginPopupContextVoid(const char* str_id, int mouse_button)$/;"	f	class:ImGui	signature:(const char* str_id, int mouse_button)
BeginPopupContextVoid	libs/imgui/imgui.h	/^    IMGUI_API bool          BeginPopupContextVoid(const char* str_id = NULL, int mouse_button = 1);                                 \/\/ helper to open and begin popup when clicked in void (no window)$/;"	p	namespace:ImGui	signature:(const char* str_id = NULL, int mouse_button = 1)
BeginPopupContextWindow	libs/imgui/imgui.cpp	/^bool ImGui::BeginPopupContextWindow(bool also_over_items, const char* str_id, int mouse_button)$/;"	f	class:ImGui	signature:(bool also_over_items, const char* str_id, int mouse_button)
BeginPopupContextWindow	libs/imgui/imgui.h	/^    IMGUI_API bool          BeginPopupContextWindow(bool also_over_items = true, const char* str_id = NULL, int mouse_button = 1);  \/\/ helper to open and begin popup when clicked on current window$/;"	p	namespace:ImGui	signature:(bool also_over_items = true, const char* str_id = NULL, int mouse_button = 1)
BeginPopupEx	libs/imgui/imgui.cpp	/^static bool BeginPopupEx(const char* str_id, ImGuiWindowFlags extra_flags)$/;"	f	file:	signature:(const char* str_id, ImGuiWindowFlags extra_flags)
BeginPopupModal	libs/imgui/imgui.cpp	/^bool ImGui::BeginPopupModal(const char* name, bool* p_opened, ImGuiWindowFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* name, bool* p_opened, ImGuiWindowFlags extra_flags)
BeginPopupModal	libs/imgui/imgui.h	/^    IMGUI_API bool          BeginPopupModal(const char* name, bool* p_opened = NULL, ImGuiWindowFlags extra_flags = 0);             \/\/ modal dialog (can't close them by clicking outside)$/;"	p	namespace:ImGui	signature:(const char* name, bool* p_opened = NULL, ImGuiWindowFlags extra_flags = 0)
BeginTooltip	libs/imgui/imgui.cpp	/^void ImGui::BeginTooltip()$/;"	f	class:ImGui	signature:()
BeginTooltip	libs/imgui/imgui.h	/^    IMGUI_API void          BeginTooltip();                                                     \/\/ use to create full-featured tooltip windows that aren't just text$/;"	p	namespace:ImGui	signature:()
Buf	libs/imgui/imgui.h	/^    ImVector<char>      Buf;$/;"	m	struct:ImGuiTextBuffer	access:public
Buf	libs/imgui/imgui.h	/^    char*               Buf;            \/\/ Current text                         \/\/ Read-write (pointed data only)$/;"	m	struct:ImGuiTextEditCallbackData	access:public
BufDirty	libs/imgui/imgui.h	/^    bool                BufDirty;       \/\/ Set if you modify Buf directly       \/\/ Write$/;"	m	struct:ImGuiTextEditCallbackData	access:public
BufSize	libs/imgui/imgui.h	/^    int                 BufSize;        \/\/                                      \/\/ Read-only$/;"	m	struct:ImGuiTextEditCallbackData	access:public
BufSizeA	libs/imgui/imgui.cpp	/^    int                 BufSizeA;                       \/\/ end-user buffer size$/;"	m	struct:ImGuiTextEditState	file:	access:public
Build	libs/imgui/imgui.cpp	/^bool    ImFontAtlas::Build()$/;"	f	class:ImFontAtlas	signature:()
Build	libs/imgui/imgui.cpp	/^void ImGuiTextFilter::Build()$/;"	f	class:ImGuiTextFilter	signature:()
Build	libs/imgui/imgui.h	/^    IMGUI_API bool              Build();            \/\/ Build pixels data. This is automatically for you by the GetTexData*** functions.$/;"	p	struct:ImFontAtlas	access:public	signature:()
Build	libs/imgui/imgui.h	/^    IMGUI_API void Build();$/;"	p	struct:ImGuiTextFilter	access:public	signature:()
BuildLookupTable	libs/imgui/imgui.cpp	/^void ImFont::BuildLookupTable()$/;"	f	class:ImFont	signature:()
BuildLookupTable	libs/imgui/imgui.h	/^    IMGUI_API void              BuildLookupTable();$/;"	p	struct:ImFont	access:public	signature:()
Bullet	libs/imgui/imgui.cpp	/^void ImGui::Bullet()$/;"	f	class:ImGui	signature:()
Bullet	libs/imgui/imgui.h	/^    IMGUI_API void          Bullet();$/;"	p	namespace:ImGui	signature:()
BulletText	libs/imgui/imgui.cpp	/^void ImGui::BulletText(const char* fmt, ...)$/;"	f	class:ImGui	signature:(const char* fmt, ...)
BulletText	libs/imgui/imgui.h	/^    IMGUI_API void          BulletText(const char* fmt, ...);$/;"	p	namespace:ImGui	signature:(const char* fmt, ...)
BulletTextV	libs/imgui/imgui.cpp	/^void ImGui::BulletTextV(const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const char* fmt, va_list args)
BulletTextV	libs/imgui/imgui.h	/^    IMGUI_API void          BulletTextV(const char* fmt, va_list args);$/;"	p	namespace:ImGui	signature:(const char* fmt, va_list args)
Button	libs/imgui/imgui.cpp	/^bool ImGui::Button(const char* label, const ImVec2& size_arg)$/;"	f	class:ImGui	signature:(const char* label, const ImVec2& size_arg)
Button	libs/imgui/imgui.h	/^    IMGUI_API bool          Button(const char* label, const ImVec2& size = ImVec2(0,0));$/;"	p	namespace:ImGui	signature:(const char* label, const ImVec2& size = ImVec2(0,0))
ButtonBehavior	libs/imgui/imgui.cpp	/^static bool         ButtonBehavior(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, bool allow_key_modifiers, ImGuiButtonFlags flags = 0);$/;"	p	file:	signature:(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, bool allow_key_modifiers, ImGuiButtonFlags flags = 0)
ButtonBehavior	libs/imgui/imgui.cpp	/^static bool ButtonBehavior(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, bool allow_key_modifiers, ImGuiButtonFlags flags)$/;"	f	file:	signature:(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, bool allow_key_modifiers, ImGuiButtonFlags flags)
ButtonEx	libs/imgui/imgui.cpp	/^static bool ButtonEx(const char* label, const ImVec2& size_arg = ImVec2(0,0), ImGuiButtonFlags flags = 0)$/;"	f	file:	signature:(const char* label, const ImVec2& size_arg = ImVec2(0,0), ImGuiButtonFlags flags = 0)
ButtonRepeat	libs/imgui/imgui.cpp	/^    bool                    ButtonRepeat;           \/\/ == ButtonRepeatStack.back() [empty == false]$/;"	m	struct:ImGuiDrawContext	file:	access:public
ButtonRepeatStack	libs/imgui/imgui.cpp	/^    ImVector<bool>          ButtonRepeatStack;$/;"	m	struct:ImGuiDrawContext	file:	access:public
CAMERA_H	include/gfx/Camera.h	2;"	d
COMMAND_H	include/util/Command.h	2;"	d
COMPILE_FLAGS	GaffMaker/Makefile	/^COMPILE_FLAGS = -std=c++14 -Wall -Wextra -g $(EXTRA)$/;"	m
COMPILE_FLAGS	Makefile	/^COMPILE_FLAGS = -std=c++14 -Wall -Wextra $(EXTRA) $(DEFS) -g$/;"	m
CONSOLE	include/Input.h	/^    const int CONSOLE = GLFW_KEY_F4;$/;"	m	namespace:Key
CONSOLE_H	include/util/Console.h	2;"	d
CXX	GaffMaker/Makefile	/^CXX ?= g++$/;"	m
CXX	Makefile	/^CXX = g++$/;"	m
CalcExtraSpace	libs/imgui/imgui.cpp	/^    float CalcExtraSpace(float avail_w)$/;"	f	struct:ImGuiSimpleColumns	access:public	signature:(float avail_w)
CalcFontSize	libs/imgui/imgui.cpp	/^    float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }$/;"	f	struct:ImGuiWindow	access:public	signature:() const
CalcItemRectClosestPoint	libs/imgui/imgui.cpp	/^ImVec2 ImGui::CalcItemRectClosestPoint(const ImVec2& pos, bool on_edge, float outward)$/;"	f	class:ImGui	signature:(const ImVec2& pos, bool on_edge, float outward)
CalcItemRectClosestPoint	libs/imgui/imgui.h	/^    IMGUI_API ImVec2        CalcItemRectClosestPoint(const ImVec2& pos, bool on_edge = false, float outward = +0.0f);   \/\/ utility to find the closest point the last item bounding rectangle edge. useful to visually link items$/;"	p	namespace:ImGui	signature:(const ImVec2& pos, bool on_edge = false, float outward = +0.0f)
CalcItemSize	libs/imgui/imgui.cpp	/^static inline ImVec2 CalcItemSize(ImVec2 size, float default_x, float default_y)$/;"	f	file:	signature:(ImVec2 size, float default_x, float default_y)
CalcItemWidth	libs/imgui/imgui.cpp	/^float ImGui::CalcItemWidth()$/;"	f	class:ImGui	signature:()
CalcItemWidth	libs/imgui/imgui.h	/^    IMGUI_API float         CalcItemWidth();                                                    \/\/ width of item given pushed settings and current cursor position$/;"	p	namespace:ImGui	signature:()
CalcListClipping	libs/imgui/imgui.cpp	/^void ImGui::CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end)$/;"	f	class:ImGui	signature:(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end)
CalcListClipping	libs/imgui/imgui.h	/^    IMGUI_API void          CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end);    \/\/ calculate coarse clipping for large list of evenly sized items. Prefer using the ImGuiListClipper higher-level helper if you can.$/;"	p	namespace:ImGui	signature:(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end)
CalcTextSize	libs/imgui/imgui.cpp	/^ImVec2 ImGui::CalcTextSize(const char* text, const char* text_end, bool hide_text_after_double_hash, float wrap_width)$/;"	f	class:ImGui	signature:(const char* text, const char* text_end, bool hide_text_after_double_hash, float wrap_width)
CalcTextSize	libs/imgui/imgui.h	/^    IMGUI_API ImVec2        CalcTextSize(const char* text, const char* text_end = NULL, bool hide_text_after_double_hash = false, float wrap_width = -1.0f);$/;"	p	namespace:ImGui	signature:(const char* text, const char* text_end = NULL, bool hide_text_after_double_hash = false, float wrap_width = -1.0f)
CalcTextSizeA	libs/imgui/imgui.cpp	/^ImVec2 ImFont::CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end, const char** remaining) const$/;"	f	class:ImFont	signature:(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end, const char** remaining) const
CalcTextSizeA	libs/imgui/imgui.h	/^    IMGUI_API ImVec2            CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end = NULL, const char** remaining = NULL) const; \/\/ utf8$/;"	p	struct:ImFont	access:public	signature:(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end = NULL, const char** remaining = NULL) const
CalcWordWrapPositionA	libs/imgui/imgui.cpp	/^const char* ImFont::CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const$/;"	f	class:ImFont	signature:(float scale, const char* text, const char* text_end, float wrap_width) const
CalcWordWrapPositionA	libs/imgui/imgui.h	/^    IMGUI_API const char*       CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const;$/;"	p	struct:ImFont	access:public	signature:(float scale, const char* text, const char* text_end, float wrap_width) const
CalcWrapWidthForPos	libs/imgui/imgui.cpp	/^static float CalcWrapWidthForPos(const ImVec2& pos, float wrap_pos_x)$/;"	f	file:	signature:(const ImVec2& pos, float wrap_pos_x)
Camera	include/gfx/Camera.h	/^namespace Camera {$/;"	n
Camera	src/gfx/Camera.cpp	/^namespace Camera {$/;"	n	file:
Camera::init	include/gfx/Camera.h	/^    void init();$/;"	p	namespace:Camera	signature:()
Camera::init	src/gfx/Camera.cpp	/^    void init() {$/;"	f	namespace:Camera	signature:()
Camera::player	src/gfx/Camera.cpp	/^    Entity *player;$/;"	m	namespace:Camera	file:
Camera::positionLast	src/gfx/Camera.cpp	/^    vec4 positionLast;$/;"	m	namespace:Camera	file:
Camera::render	include/gfx/Camera.h	/^    void render();$/;"	p	namespace:Camera	signature:()
Camera::render	src/gfx/Camera.cpp	/^    void render() {$/;"	f	namespace:Camera	signature:()
Camera::tick	include/gfx/Camera.h	/^    void tick();$/;"	p	namespace:Camera	signature:()
Camera::tick	src/gfx/Camera.cpp	/^    void tick() {$/;"	f	namespace:Camera	signature:()
Camera::toMove	src/gfx/Camera.cpp	/^    vec4 toMove = vec4(0, 0, 0, 0);$/;"	m	namespace:Camera	file:
Camera::tween	src/gfx/Camera.cpp	/^    mat4 tween = scale(IDENTITY, vec3(tweenFloat, tweenFloat, 1));$/;"	m	namespace:Camera	file:
Camera::tweenFloat	src/gfx/Camera.cpp	/^    float tweenFloat = 0.1 * VT;$/;"	m	namespace:Camera	file:
Capacity	libs/imgui/imgui.h	/^    int                         Capacity;$/;"	m	class:ImVector	access:public
CaptureKeyboardFromApp	libs/imgui/imgui.cpp	/^void ImGui::CaptureKeyboardFromApp()$/;"	f	class:ImGui	signature:()
CaptureKeyboardFromApp	libs/imgui/imgui.h	/^    IMGUI_API void          CaptureKeyboardFromApp();                                           \/\/ manually enforce imgui setting the io.WantCaptureKeyboard flag next frame (your application needs to handle it). e.g. capture keyboard when your widget is being hovered.$/;"	p	namespace:ImGui	signature:()
CaptureKeyboardNextFrame	libs/imgui/imgui.cpp	/^    bool                    CaptureKeyboardNextFrame;$/;"	m	struct:ImGuiState	file:	access:public
CaptureMouseFromApp	libs/imgui/imgui.cpp	/^void ImGui::CaptureMouseFromApp()$/;"	f	class:ImGui	signature:()
CaptureMouseFromApp	libs/imgui/imgui.h	/^    IMGUI_API void          CaptureMouseFromApp();                                              \/\/ manually enforce imgui setting the io.WantCaptureMouse flag next frame (your application needs to handle it).$/;"	p	namespace:ImGui	signature:()
CaptureMouseNextFrame	libs/imgui/imgui.cpp	/^    bool                    CaptureMouseNextFrame;              \/\/ explicit capture via CaptureInputs() sets those flags$/;"	m	struct:ImGuiState	file:	access:public
ChannelsMerge	libs/imgui/imgui.cpp	/^void ImDrawList::ChannelsMerge(int channel_count)$/;"	f	class:ImDrawList	signature:(int channel_count)
ChannelsMerge	libs/imgui/imgui.h	/^    IMGUI_API void  ChannelsMerge(int channel_count);$/;"	p	struct:ImDrawList	access:public	signature:(int channel_count)
ChannelsSetCurrent	libs/imgui/imgui.cpp	/^void ImDrawList::ChannelsSetCurrent(int idx)$/;"	f	class:ImDrawList	signature:(int idx)
ChannelsSetCurrent	libs/imgui/imgui.h	/^    IMGUI_API void  ChannelsSetCurrent(int idx);$/;"	p	struct:ImDrawList	access:public	signature:(int idx)
ChannelsSplit	libs/imgui/imgui.cpp	/^void ImDrawList::ChannelsSplit(int channel_count)$/;"	f	class:ImDrawList	signature:(int channel_count)
ChannelsSplit	libs/imgui/imgui.h	/^    IMGUI_API void  ChannelsSplit(int channel_count);$/;"	p	struct:ImDrawList	access:public	signature:(int channel_count)
CheckStacksSize	libs/imgui/imgui.cpp	/^static void CheckStacksSize(ImGuiWindow* window, bool write)$/;"	f	file:	signature:(ImGuiWindow* window, bool write)
Checkbox	libs/imgui/imgui.cpp	/^bool ImGui::Checkbox(const char* label, bool* v)$/;"	f	class:ImGui	signature:(const char* label, bool* v)
Checkbox	libs/imgui/imgui.h	/^    IMGUI_API bool          Checkbox(const char* label, bool* v);$/;"	p	namespace:ImGui	signature:(const char* label, bool* v)
CheckboxFlags	libs/imgui/imgui.cpp	/^bool ImGui::CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value)$/;"	f	class:ImGui	signature:(const char* label, unsigned int* flags, unsigned int flags_value)
CheckboxFlags	libs/imgui/imgui.h	/^    IMGUI_API bool          CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value);$/;"	p	namespace:ImGui	signature:(const char* label, unsigned int* flags, unsigned int flags_value)
ChildWindowComparer	libs/imgui/imgui.cpp	/^static int ChildWindowComparer(const void* lhs, const void* rhs)$/;"	f	file:	signature:(const void* lhs, const void* rhs)
ChildWindowRounding	libs/imgui/imgui.h	/^    float       ChildWindowRounding;        \/\/ Radius of child window corners rounding. Set to 0.0f to have rectangular windows$/;"	m	struct:ImGuiStyle	access:public
ChildWindows	libs/imgui/imgui.cpp	/^    ImVector<ImGuiWindow*>  ChildWindows;$/;"	m	struct:ImGuiDrawContext	file:	access:public
Clear	libs/imgui/imgui.cpp	/^void    ImFont::Clear()$/;"	f	class:ImFont	signature:()
Clear	libs/imgui/imgui.cpp	/^void    ImFontAtlas::Clear()$/;"	f	class:ImFontAtlas	signature:()
Clear	libs/imgui/imgui.cpp	/^void ImDrawList::Clear()$/;"	f	class:ImDrawList	signature:()
Clear	libs/imgui/imgui.cpp	/^void ImGuiStorage::Clear()$/;"	f	class:ImGuiStorage	signature:()
Clear	libs/imgui/imgui.h	/^    IMGUI_API void              Clear();                    \/\/ Clear all$/;"	p	struct:ImFontAtlas	access:public	signature:()
Clear	libs/imgui/imgui.h	/^    IMGUI_API void              Clear();$/;"	p	struct:ImFont	access:public	signature:()
Clear	libs/imgui/imgui.h	/^    IMGUI_API void    Clear();$/;"	p	struct:ImGuiStorage	access:public	signature:()
Clear	libs/imgui/imgui.h	/^    IMGUI_API void  Clear();$/;"	p	struct:ImDrawList	access:public	signature:()
Clear	libs/imgui/imgui.h	/^    void Clear() { InputBuf[0] = 0; Build(); }$/;"	f	struct:ImGuiTextFilter	access:public	signature:()
ClearFonts	libs/imgui/imgui.cpp	/^void    ImFontAtlas::ClearFonts()$/;"	f	class:ImFontAtlas	signature:()
ClearFonts	libs/imgui/imgui.h	/^    IMGUI_API void              ClearFonts();               \/\/ Clear the ImGui-side font data (glyphs storage, UV coordinates)$/;"	p	struct:ImFontAtlas	access:public	signature:()
ClearFreeMemory	libs/imgui/imgui.cpp	/^void ImDrawList::ClearFreeMemory()$/;"	f	class:ImDrawList	signature:()
ClearFreeMemory	libs/imgui/imgui.h	/^    IMGUI_API void  ClearFreeMemory();$/;"	p	struct:ImDrawList	access:public	signature:()
ClearInputData	libs/imgui/imgui.cpp	/^void    ImFontAtlas::ClearInputData()$/;"	f	class:ImFontAtlas	signature:()
ClearInputData	libs/imgui/imgui.h	/^    IMGUI_API void              ClearInputData();           \/\/ Clear the input TTF data (inc sizes, glyph ranges)$/;"	p	struct:ImFontAtlas	access:public	signature:()
ClearLog	libs/imgui/imgui.cpp	/^    void    ClearLog()$/;"	f	struct:ExampleAppConsole	access:public	signature:()
ClearLog	src/util/Console.cpp	/^	void    ClearLog()$/;"	f	struct:Console::Console	access:public	signature:()
ClearSelection	libs/imgui/imgui.cpp	/^    void                ClearSelection()                { StbState.select_start = StbState.select_end = StbState.cursor; }$/;"	f	struct:ImGuiTextEditState	access:public	signature:()
ClearSetNextWindowData	libs/imgui/imgui.cpp	/^static void ClearSetNextWindowData()$/;"	f	file:	signature:()
ClearTexData	libs/imgui/imgui.cpp	/^void    ImFontAtlas::ClearTexData()$/;"	f	class:ImFontAtlas	signature:()
ClearTexData	libs/imgui/imgui.h	/^    IMGUI_API void              ClearTexData();             \/\/ Clear the CPU-side texture data. Saves RAM once the texture has been copied to graphics memory.$/;"	p	struct:ImFontAtlas	access:public	signature:()
Clip	libs/imgui/imgui.cpp	/^    void        Clip(const ImRect& clip)            { Min.x = ImMax(Min.x, clip.Min.x); Min.y = ImMax(Min.y, clip.Min.y); Max.x = ImMin(Max.x, clip.Max.x); Max.y = ImMin(Max.y, clip.Max.y); }$/;"	f	struct:ImRect	access:public	signature:(const ImRect& clip)
ClipRect	libs/imgui/imgui.cpp	/^    ImVec4                  ClipRect;                           \/\/ = DrawList->clip_rect_stack.back(). Scissoring \/ clipping rectangle. x1, y1, x2, y2.$/;"	m	struct:ImGuiWindow	file:	access:public
ClipRect	libs/imgui/imgui.h	/^    ImVec4          ClipRect;               \/\/ Clipping rectangle (x1, y1, x2, y2)$/;"	m	struct:ImDrawCmd	access:public
ClippedWindowRect	libs/imgui/imgui.cpp	/^    ImRect                  ClippedWindowRect;                  \/\/ = ClipRect just after setup in Begin()$/;"	m	struct:ImGuiWindow	file:	access:public
CloseCurrentPopup	libs/imgui/imgui.cpp	/^void ImGui::CloseCurrentPopup()$/;"	f	class:ImGui	signature:()
CloseCurrentPopup	libs/imgui/imgui.h	/^    IMGUI_API void          CloseCurrentPopup();                                                \/\/ close the popup we have begin-ed into. clicking on a MenuItem or Selectable automatically close the current popup.$/;"	p	namespace:ImGui	signature:()
CloseInactivePopups	libs/imgui/imgui.cpp	/^static void         CloseInactivePopups();$/;"	p	file:	signature:()
CloseInactivePopups	libs/imgui/imgui.cpp	/^static void CloseInactivePopups()$/;"	f	file:	signature:()
ClosePopup	libs/imgui/imgui.cpp	/^static void ClosePopup(ImGuiID id)$/;"	f	file:	signature:(ImGuiID id)
ClosePopupToLevel	libs/imgui/imgui.cpp	/^static void ClosePopupToLevel(int remaining)$/;"	f	file:	signature:(int remaining)
CloseWindowButton	libs/imgui/imgui.cpp	/^static bool         CloseWindowButton(bool* p_opened = NULL);$/;"	p	file:	signature:(bool* p_opened = NULL)
CloseWindowButton	libs/imgui/imgui.cpp	/^static bool CloseWindowButton(bool* p_opened)$/;"	f	file:	signature:(bool* p_opened)
CmdBuffer	libs/imgui/imgui.h	/^    ImVector<ImDrawCmd>     CmdBuffer;          \/\/ Commands. Typically 1 command = 1 gpu draw call.$/;"	m	struct:ImDrawList	access:public
CmdBuffer	libs/imgui/imgui.h	/^    ImVector<ImDrawCmd>     CmdBuffer;$/;"	m	struct:ImDrawChannel	access:public
CmdLists	libs/imgui/imgui.h	/^    ImDrawList**    CmdLists;$/;"	m	struct:ImDrawData	access:public
CmdListsCount	libs/imgui/imgui.h	/^    int             CmdListsCount;$/;"	m	struct:ImDrawData	access:public
Codepoint	libs/imgui/imgui.h	/^        ImWchar                 Codepoint;$/;"	m	struct:ImFont::Glyph	access:public
Col	libs/imgui/imgui.cpp	/^    ImGuiCol    Col;$/;"	m	struct:ImGuiColMod	file:	access:public
Collapsed	libs/imgui/imgui.cpp	/^    bool                    Collapsed;                          \/\/ Set when collapsing window to become only title-bar$/;"	m	struct:ImGuiWindow	file:	access:public
Collapsed	libs/imgui/imgui.cpp	/^    bool    Collapsed;$/;"	m	struct:ImGuiIniData	file:	access:public
CollapsingHeader	libs/imgui/imgui.cpp	/^bool ImGui::CollapsingHeader(const char* label, const char* str_id, bool display_frame, bool default_open)$/;"	f	class:ImGui	signature:(const char* label, const char* str_id, bool display_frame, bool default_open)
CollapsingHeader	libs/imgui/imgui.h	/^    IMGUI_API bool          CollapsingHeader(const char* label, const char* str_id = NULL, bool display_frame = true, bool default_open = false);$/;"	p	namespace:ImGui	signature:(const char* label, const char* str_id = NULL, bool display_frame = true, bool default_open = false)
Color	libs/imgui/imgui.cpp	/^    ImU32       Color(ImGuiCol idx, float a=1.f) const  { ImVec4 c = GImGui->Style.Colors[idx]; c.w *= GImGui->Style.Alpha * a; return ImGui::ColorConvertFloat4ToU32(c); }$/;"	f	struct:ImGuiWindow	access:public	signature:(ImGuiCol idx, float a=1.f) const
Color	libs/imgui/imgui.cpp	/^    ImU32       Color(const ImVec4& col) const          { ImVec4 c = col; c.w *= GImGui->Style.Alpha; return ImGui::ColorConvertFloat4ToU32(c); }$/;"	f	struct:ImGuiWindow	access:public	signature:(const ImVec4& col) const
Color	libs/imgui/imgui.cpp	/^void ImGui::Color(const char* prefix, const ImVec4& v)$/;"	f	class:ImGui	signature:(const char* prefix, const ImVec4& v)
Color	libs/imgui/imgui.cpp	/^void ImGui::Color(const char* prefix, unsigned int v)$/;"	f	class:ImGui	signature:(const char* prefix, unsigned int v)
Color	libs/imgui/imgui.h	/^    IMGUI_API void          Color(const char* prefix, const ImVec4& v);$/;"	p	namespace:ImGui	signature:(const char* prefix, const ImVec4& v)
Color	libs/imgui/imgui.h	/^    IMGUI_API void          Color(const char* prefix, unsigned int v);$/;"	p	namespace:ImGui	signature:(const char* prefix, unsigned int v)
ColorButton	libs/imgui/imgui.cpp	/^bool ImGui::ColorButton(const ImVec4& col, bool small_height, bool outline_border)$/;"	f	class:ImGui	signature:(const ImVec4& col, bool small_height, bool outline_border)
ColorButton	libs/imgui/imgui.h	/^    IMGUI_API bool          ColorButton(const ImVec4& col, bool small_height = false, bool outline_border = true);$/;"	p	namespace:ImGui	signature:(const ImVec4& col, bool small_height = false, bool outline_border = true)
ColorConvertFloat4ToU32	libs/imgui/imgui.cpp	/^ImU32 ImGui::ColorConvertFloat4ToU32(const ImVec4& in)$/;"	f	class:ImGui	signature:(const ImVec4& in)
ColorConvertFloat4ToU32	libs/imgui/imgui.h	/^    IMGUI_API ImU32         ColorConvertFloat4ToU32(const ImVec4& in);$/;"	p	namespace:ImGui	signature:(const ImVec4& in)
ColorConvertHSVtoRGB	libs/imgui/imgui.cpp	/^void ImGui::ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b)$/;"	f	class:ImGui	signature:(float h, float s, float v, float& out_r, float& out_g, float& out_b)
ColorConvertHSVtoRGB	libs/imgui/imgui.h	/^    IMGUI_API void          ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b);$/;"	p	namespace:ImGui	signature:(float h, float s, float v, float& out_r, float& out_g, float& out_b)
ColorConvertRGBtoHSV	libs/imgui/imgui.cpp	/^void ImGui::ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v)$/;"	f	class:ImGui	signature:(float r, float g, float b, float& out_h, float& out_s, float& out_v)
ColorConvertRGBtoHSV	libs/imgui/imgui.h	/^    IMGUI_API void          ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v);$/;"	p	namespace:ImGui	signature:(float r, float g, float b, float& out_h, float& out_s, float& out_v)
ColorEdit3	libs/imgui/imgui.cpp	/^bool ImGui::ColorEdit3(const char* label, float col[3])$/;"	f	class:ImGui	signature:(const char* label, float col[3])
ColorEdit3	libs/imgui/imgui.h	/^    IMGUI_API bool          ColorEdit3(const char* label, float col[3]);$/;"	p	namespace:ImGui	signature:(const char* label, float col[3])
ColorEdit4	libs/imgui/imgui.cpp	/^bool ImGui::ColorEdit4(const char* label, float col[4], bool alpha)$/;"	f	class:ImGui	signature:(const char* label, float col[4], bool alpha)
ColorEdit4	libs/imgui/imgui.h	/^    IMGUI_API bool          ColorEdit4(const char* label, float col[4], bool show_alpha = true);$/;"	p	namespace:ImGui	signature:(const char* label, float col[4], bool show_alpha = true)
ColorEditMode	libs/imgui/imgui.cpp	/^    ImGuiColorEditMode      ColorEditMode;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ColorEditMode	libs/imgui/imgui.cpp	/^void ImGui::ColorEditMode(ImGuiColorEditMode mode)$/;"	f	class:ImGui	signature:(ImGuiColorEditMode mode)
ColorEditMode	libs/imgui/imgui.h	/^    IMGUI_API void          ColorEditMode(ImGuiColorEditMode mode);$/;"	p	namespace:ImGui	signature:(ImGuiColorEditMode mode)
ColorEditModeStorage	libs/imgui/imgui.cpp	/^    ImGuiStorage            ColorEditModeStorage;               \/\/ Store user selection of color edit mode$/;"	m	struct:ImGuiState	file:	access:public
ColorModifiers	libs/imgui/imgui.cpp	/^    ImVector<ImGuiColMod>   ColorModifiers;$/;"	m	struct:ImGuiState	file:	access:public
Colors	libs/imgui/imgui.h	/^    ImVec4      Colors[ImGuiCol_COUNT];$/;"	m	struct:ImGuiStyle	access:public
Columns	libs/imgui/imgui.cpp	/^void ImGui::Columns(int columns_count, const char* id, bool border)$/;"	f	class:ImGui	signature:(int columns_count, const char* id, bool border)
Columns	libs/imgui/imgui.h	/^    IMGUI_API void          Columns(int count = 1, const char* id = NULL, bool border=true);    \/\/ setup number of columns. use an identifier to distinguish multiple column sets. close with Columns(1).$/;"	p	namespace:ImGui	signature:(int count = 1, const char* id = NULL, bool border=true)
ColumnsCellMaxY	libs/imgui/imgui.cpp	/^    float                   ColumnsCellMaxY;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ColumnsCellMinY	libs/imgui/imgui.cpp	/^    float                   ColumnsCellMinY;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ColumnsCount	libs/imgui/imgui.cpp	/^    int                     ColumnsCount;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ColumnsCurrent	libs/imgui/imgui.cpp	/^    int                     ColumnsCurrent;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ColumnsMinSpacing	libs/imgui/imgui.h	/^    float       ColumnsMinSpacing;          \/\/ Minimum horizontal spacing between two columns$/;"	m	struct:ImGuiStyle	access:public
ColumnsOffsetX	libs/imgui/imgui.cpp	/^    float                   ColumnsOffsetX;         \/\/ Offset to the current column (if ColumnsCurrent > 0). FIXME: This and the above should be a stack to allow use cases like Tree->Column->Tree. Need revamp columns API.$/;"	m	struct:ImGuiDrawContext	file:	access:public
ColumnsOffsetsT	libs/imgui/imgui.cpp	/^    ImVector<float>         ColumnsOffsetsT;        \/\/ Columns offset normalized 0.0 (far left) -> 1.0 (far right)$/;"	m	struct:ImGuiDrawContext	file:	access:public
ColumnsSetID	libs/imgui/imgui.cpp	/^    ImGuiID                 ColumnsSetID;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ColumnsShowBorders	libs/imgui/imgui.cpp	/^    bool                    ColumnsShowBorders;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ColumnsStartPos	libs/imgui/imgui.cpp	/^    ImVec2                  ColumnsStartPos;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ColumnsStartX	libs/imgui/imgui.cpp	/^    float                   ColumnsStartX;          \/\/ Indentation \/ start position from left of window (increased by TreePush\/TreePop, etc.)$/;"	m	struct:ImGuiDrawContext	file:	access:public
Combo	libs/imgui/imgui.cpp	/^bool ImGui::Combo(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int height_in_items)$/;"	f	class:ImGui	signature:(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int height_in_items)
Combo	libs/imgui/imgui.cpp	/^bool ImGui::Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int height_in_items)$/;"	f	class:ImGui	signature:(const char* label, int* current_item, const char* items_separated_by_zeros, int height_in_items)
Combo	libs/imgui/imgui.cpp	/^bool ImGui::Combo(const char* label, int* current_item, const char** items, int items_count, int height_in_items)$/;"	f	class:ImGui	signature:(const char* label, int* current_item, const char** items, int items_count, int height_in_items)
Combo	libs/imgui/imgui.h	/^    IMGUI_API bool          Combo(const char* label, int* current_item, bool (*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int height_in_items = -1);$/;"	p	namespace:ImGui	signature:(const char* label, int* current_item, bool (*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int height_in_items = -1)
Combo	libs/imgui/imgui.h	/^    IMGUI_API bool          Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int height_in_items = -1);      \/\/ separate items with \\0, end item-list with \\0\\0$/;"	p	namespace:ImGui	signature:(const char* label, int* current_item, const char* items_separated_by_zeros, int height_in_items = -1)
Combo	libs/imgui/imgui.h	/^    IMGUI_API bool          Combo(const char* label, int* current_item, const char** items, int items_count, int height_in_items = -1);$/;"	p	namespace:ImGui	signature:(const char* label, int* current_item, const char** items, int items_count, int height_in_items = -1)
Command	include/util/Command.h	/^namespace Command {$/;"	n
Command	src/util/Command.cpp	/^namespace Command {$/;"	n	file:
Command::commandList	include/util/Command.h	/^    const std::string commandList[] = {"hello"};$/;"	m	namespace:Command
Command::count	include/util/Command.h	/^    const int count = sizeof(commandList)\/sizeof(std::string);$/;"	m	namespace:Command
Command::run	include/util/Command.h	/^    bool run(std::string command);$/;"	p	namespace:Command	signature:(std::string command)
Command::run	src/util/Command.cpp	/^    bool run(std::string command) {$/;"	f	namespace:Command	signature:(std::string command)
Commands	libs/imgui/imgui.cpp	/^    ImVector<const char*> Commands;$/;"	m	struct:ExampleAppConsole	file:	access:public
Commands	src/util/Console.cpp	/^	ImVector<const char*> Commands;$/;"	m	struct:Console::Console	file:	access:public
ConfigData	libs/imgui/imgui.h	/^    ImFontConfig*               ConfigData;         \/\/                 \/\/ Pointer within ImFontAtlas->ConfigData$/;"	m	struct:ImFont	access:public
ConfigData	libs/imgui/imgui.h	/^    ImVector<ImFontConfig>      ConfigData;         \/\/ Internal data$/;"	m	struct:ImFontAtlas	access:public
ConfigDataCount	libs/imgui/imgui.h	/^    int                         ConfigDataCount;    \/\/$/;"	m	struct:ImFont	access:public
Console	include/util/Console.h	/^namespace Console {$/;"	n
Console	src/util/Console.cpp	/^	Console()$/;"	f	struct:Console::Console	access:public	signature:()
Console	src/util/Console.cpp	/^    struct Console$/;"	s	namespace:Console	file:
Console	src/util/Console.cpp	/^namespace Console {$/;"	n	file:
Console::Console	src/util/Console.cpp	/^    struct Console$/;"	s	namespace:Console	file:
Console::Console::AddLog	src/util/Console.cpp	/^	void    AddLog(const char* fmt, ...)$/;"	f	struct:Console::Console	access:public	signature:(const char* fmt, ...)
Console::Console::ClearLog	src/util/Console.cpp	/^	void    ClearLog()$/;"	f	struct:Console::Console	access:public	signature:()
Console::Console::Commands	src/util/Console.cpp	/^	ImVector<const char*> Commands;$/;"	m	struct:Console::Console	file:	access:public
Console::Console::Console	src/util/Console.cpp	/^	Console()$/;"	f	struct:Console::Console	access:public	signature:()
Console::Console::ExecCommand	src/util/Console.cpp	/^	void    ExecCommand(const char* command_line)$/;"	f	struct:Console::Console	access:public	signature:(const char* command_line)
Console::Console::History	src/util/Console.cpp	/^	ImVector<char*>       History;$/;"	m	struct:Console::Console	file:	access:public
Console::Console::HistoryPos	src/util/Console.cpp	/^	int                   HistoryPos;    \/\/ -1: new line, 0..History.Size-1 browsing history.$/;"	m	struct:Console::Console	file:	access:public
Console::Console::InputBuf	src/util/Console.cpp	/^	char                  InputBuf[256];$/;"	m	struct:Console::Console	file:	access:public
Console::Console::Items	src/util/Console.cpp	/^	ImVector<char*>       Items;$/;"	m	struct:Console::Console	file:	access:public
Console::Console::Run	src/util/Console.cpp	/^	void    Run(const char* title, bool* opened)$/;"	f	struct:Console::Console	access:public	signature:(const char* title, bool* opened)
Console::Console::ScrollToBottom	src/util/Console.cpp	/^	bool                  ScrollToBottom;$/;"	m	struct:Console::Console	file:	access:public
Console::Console::TextEditCallback	src/util/Console.cpp	/^	int     TextEditCallback(ImGuiTextEditCallbackData* data)$/;"	f	struct:Console::Console	access:public	signature:(ImGuiTextEditCallbackData* data)
Console::Console::TextEditCallbackStub	src/util/Console.cpp	/^	static int TextEditCallbackStub(ImGuiTextEditCallbackData* data) \/\/ In C++11 you are better off using lambdas for this sort of forwarding callbacks$/;"	f	struct:Console::Console	access:public	signature:(ImGuiTextEditCallbackData* data)
Console::Console::~Console	src/util/Console.cpp	/^	~Console()$/;"	f	struct:Console::Console	access:public	signature:()
Console::ImStricmp	src/util/Console.cpp	/^    static int ImStricmp(const char* str1, const char* str2)$/;"	f	namespace:Console	signature:(const char* str1, const char* str2)
Console::ImStricmp	src/util/Console.cpp	/^    static int ImStricmp(const char* str1, const char* str2);$/;"	p	namespace:Console	file:	signature:(const char* str1, const char* str2)
Console::ImStrnicmp	src/util/Console.cpp	/^    static int ImStrnicmp(const char* str1, const char* str2, int count)$/;"	f	namespace:Console	signature:(const char* str1, const char* str2, int count)
Console::ImStrnicmp	src/util/Console.cpp	/^    static int ImStrnicmp(const char* str1, const char* str2, int count);$/;"	p	namespace:Console	file:	signature:(const char* str1, const char* str2, int count)
Console::getConsole	src/util/Console.cpp	/^    Console* getConsole() {$/;"	f	namespace:Console	signature:()
Console::log	include/util/Console.h	/^    void log(std::string text);$/;"	p	namespace:Console	signature:(std::string text)
Console::log	src/util/Console.cpp	/^    void log(std::string text) {$/;"	f	namespace:Console	signature:(std::string text)
Console::show	include/util/Console.h	/^    void show(bool *opened);$/;"	p	namespace:Console	signature:(bool *opened)
Console::show	src/util/Console.cpp	/^    void show(bool* opened) {$/;"	f	namespace:Console	signature:(bool* opened)
ContainerAtlas	libs/imgui/imgui.h	/^    ImFontAtlas*                ContainerAtlas;     \/\/ What we has been loaded into$/;"	m	struct:ImFont	access:public
Contains	libs/imgui/imgui.cpp	/^    bool        Contains(const ImRect& r) const     { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x < Max.x && r.Max.y < Max.y; }$/;"	f	struct:ImRect	access:public	signature:(const ImRect& r) const
Contains	libs/imgui/imgui.cpp	/^    bool        Contains(const ImVec2& p) const     { return p.x >= Min.x && p.y >= Min.y && p.x < Max.x && p.y < Max.y; }$/;"	f	struct:ImRect	access:public	signature:(const ImVec2& p) const
Count	libs/imgui/imgui.cpp	/^    int    Count;$/;"	m	struct:ImGuiSimpleColumns	file:	access:public
CountGrep	libs/imgui/imgui.h	/^    int                 CountGrep;$/;"	m	struct:ImGuiTextFilter	access:public
CreateNewWindow	libs/imgui/imgui.cpp	/^static ImGuiWindow* CreateNewWindow(const char* name, ImVec2 size, ImGuiWindowFlags flags)$/;"	f	file:	signature:(const char* name, ImVec2 size, ImGuiWindowFlags flags)
CurLenA	libs/imgui/imgui.cpp	/^    int                 CurLenA, CurLenW;               \/\/ we need to maintain our buffer length in both UTF-8 and wchar format.$/;"	m	struct:ImGuiTextEditState	file:	access:public
CurLenW	libs/imgui/imgui.cpp	/^    int                 CurLenA, CurLenW;               \/\/ we need to maintain our buffer length in both UTF-8 and wchar format.$/;"	m	struct:ImGuiTextEditState	file:	access:public
CurrentLineHeight	libs/imgui/imgui.cpp	/^    float                   CurrentLineHeight;$/;"	m	struct:ImGuiDrawContext	file:	access:public
CurrentLineTextBaseOffset	libs/imgui/imgui.cpp	/^    float                   CurrentLineTextBaseOffset;$/;"	m	struct:ImGuiDrawContext	file:	access:public
CurrentPopupStack	libs/imgui/imgui.cpp	/^    ImVector<ImGuiPopupRef> CurrentPopupStack;                  \/\/ Which level of BeginPopup() we are in (reset every frame)$/;"	m	struct:ImGuiState	file:	access:public
CurrentWindow	libs/imgui/imgui.cpp	/^    ImGuiWindow*            CurrentWindow;                      \/\/ Being drawn into$/;"	m	struct:ImGuiState	file:	access:public
CurrentWindowStack	libs/imgui/imgui.cpp	/^    ImVector<ImGuiWindow*>  CurrentWindowStack;$/;"	m	struct:ImGuiState	file:	access:public
CursorAnim	libs/imgui/imgui.cpp	/^    float               CursorAnim;$/;"	m	struct:ImGuiTextEditState	file:	access:public
CursorAnimReset	libs/imgui/imgui.cpp	/^    void                CursorAnimReset()               { CursorAnim = -0.30f; }                                                \/\/ After a user-input the cursor stays on for a while without blinking$/;"	f	struct:ImGuiTextEditState	access:public	signature:()
CursorFollow	libs/imgui/imgui.cpp	/^    bool                CursorFollow;$/;"	m	struct:ImGuiTextEditState	file:	access:public
CursorIsVisible	libs/imgui/imgui.cpp	/^    bool                CursorIsVisible() const         { return CursorAnim <= 0.0f || fmodf(CursorAnim, 1.20f) <= 0.80f; }     \/\/ Blinking$/;"	f	struct:ImGuiTextEditState	access:public	signature:() const
CursorMaxPos	libs/imgui/imgui.cpp	/^    ImVec2                  CursorMaxPos;           \/\/ Implicitly calculate the size of our contents, always extending. Saved into window->SizeContents at the end of the frame$/;"	m	struct:ImGuiDrawContext	file:	access:public
CursorPos	libs/imgui/imgui.cpp	/^    ImVec2                  CursorPos;$/;"	m	struct:ImGuiDrawContext	file:	access:public
CursorPos	libs/imgui/imgui.h	/^    int                 CursorPos;      \/\/                                      \/\/ Read-write$/;"	m	struct:ImGuiTextEditCallbackData	access:public
CursorPosPrevLine	libs/imgui/imgui.cpp	/^    ImVec2                  CursorPosPrevLine;$/;"	m	struct:ImGuiDrawContext	file:	access:public
CursorStartPos	libs/imgui/imgui.cpp	/^    ImVec2                  CursorStartPos;$/;"	m	struct:ImGuiDrawContext	file:	access:public
DC	libs/imgui/imgui.cpp	/^    ImGuiDrawContext        DC;                                 \/\/ Temporary per-window data, reset at the beginning of the frame$/;"	m	struct:ImGuiWindow	file:	access:public
DEBUG	include/Input.h	/^    const int DEBUG = GLFW_KEY_F3;$/;"	m	namespace:Key
DEBUG	include/util/Log.h	/^const int DEBUG = 0x00;$/;"	v
DEBUG_MODE	include/Standard.h	5;"	d
DEFINITION_H	GaffMaker/include/Definitions.h	2;"	d
DEFINITION_H	include/Definitions.h	2;"	d
DEFS	Makefile	/^DEFS = -DDEBUG_MODE=true -DDRAW_BOX=false -DLEGACY=false -DTPS=60 -DSCALE=2 -DSWAP=0 -DPRINT_TO_TERMINAL=false$/;"	m
DESTDIR	GaffMaker/Makefile	/^DESTDIR = \/$/;"	m
DESTDIR	Makefile	/^DESTDIR = \/$/;"	m
DOWN	include/Input.h	/^    const int DOWN = GLFW_KEY_S;$/;"	m	namespace:Key
DRAWBOC	include/Standard.h	8;"	d
Data	libs/imgui/imgui.h	/^    ImVector<Pair>    Data;$/;"	m	struct:ImGuiStorage	access:public
Data	libs/imgui/imgui.h	/^    T*                          Data;$/;"	m	class:ImVector	access:public
DeIndexAllBuffers	libs/imgui/imgui.cpp	/^void ImDrawData::DeIndexAllBuffers()$/;"	f	class:ImDrawData	signature:()
DeIndexAllBuffers	libs/imgui/imgui.h	/^    void DeIndexAllBuffers();               \/\/ For backward compatibility: convert all buffers from indexed to de-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!$/;"	p	struct:ImDrawData	access:public	signature:()
DeclColumns	libs/imgui/imgui.cpp	/^    float DeclColumns(float w0, float w1, float w2) \/\/ not using va_arg because they promote float to double$/;"	f	struct:ImGuiSimpleColumns	access:public	signature:(float w0, float w1, float w2)
Decode85	libs/imgui/imgui.cpp	/^static void         Decode85(const unsigned char* src, unsigned int* dst)   { for (; *src; src += 5) *dst++ = Decode85Byte(src[0]) + 85*(Decode85Byte(src[1]) + 85*(Decode85Byte(src[2]) + 85*(Decode85Byte(src[3]) + 85*Decode85Byte(src[4])))); }$/;"	f	file:	signature:(const unsigned char* src, unsigned int* dst)
Decode85Byte	libs/imgui/imgui.cpp	/^static unsigned int Decode85Byte(char c)                                    { return c >= '\\\\' ? c-36 : c-35; }$/;"	f	file:	signature:(char c)
DeleteChars	libs/imgui/imgui.cpp	/^void ImGuiTextEditCallbackData::DeleteChars(int pos, int bytes_count)$/;"	f	class:ImGuiTextEditCallbackData	signature:(int pos, int bytes_count)
DeleteChars	libs/imgui/imgui.h	/^    void DeleteChars(int pos, int bytes_count);$/;"	p	struct:ImGuiTextEditCallbackData	access:public	signature:(int pos, int bytes_count)
DeltaTime	libs/imgui/imgui.h	/^    float         DeltaTime;                \/\/ = 1.0f\/60.0f         \/\/ Time elapsed since last frame, in seconds.$/;"	m	struct:ImGuiIO	access:public
Descent	libs/imgui/imgui.h	/^    float                       Ascent, Descent;    \/\/ Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]$/;"	m	struct:ImFont	access:public
DisableHideTextAfterDoubleHash	libs/imgui/imgui.cpp	/^    int                     DisableHideTextAfterDoubleHash;$/;"	m	struct:ImGuiState	file:	access:public
DisplayEnd	libs/imgui/imgui.h	/^    int ItemsCount, DisplayStart, DisplayEnd;$/;"	m	struct:ImGuiListClipper	access:public
DisplayOffset	libs/imgui/imgui.h	/^    ImVec2                      DisplayOffset;      \/\/ = (0.0f,0.0f)   \/\/ Offset font rendering by xx pixels$/;"	m	struct:ImFont	access:public
DisplaySafeAreaPadding	libs/imgui/imgui.h	/^    ImVec2      DisplaySafeAreaPadding;     \/\/ If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups\/tooltips as well regular windows.$/;"	m	struct:ImGuiStyle	access:public
DisplaySize	libs/imgui/imgui.h	/^    ImVec2        DisplaySize;              \/\/ <unset>              \/\/ Display size, in pixels. For clamping windows positions.$/;"	m	struct:ImGuiIO	access:public
DisplayStart	libs/imgui/imgui.h	/^    int ItemsCount, DisplayStart, DisplayEnd;$/;"	m	struct:ImGuiListClipper	access:public
DisplayVisibleMax	libs/imgui/imgui.h	/^    ImVec2        DisplayVisibleMax;        \/\/ <unset> (0.0f,0.0f)  \/\/ If the values are the same, we defaults to Min=(0.0f) and Max=DisplaySize$/;"	m	struct:ImGuiIO	access:public
DisplayVisibleMin	libs/imgui/imgui.h	/^    ImVec2        DisplayVisibleMin;        \/\/ <unset> (0.0f,0.0f)  \/\/ If you use DisplaySize as a virtual space larger than your screen, set DisplayVisibleMin\/Max to the visible area.$/;"	m	struct:ImGuiIO	access:public
DisplayWindowPadding	libs/imgui/imgui.h	/^    ImVec2      DisplayWindowPadding;       \/\/ Window positions are clamped to be visible within the display area by at least this amount. Only covers regular windows.$/;"	m	struct:ImGuiStyle	access:public
DragBehavior	libs/imgui/imgui.cpp	/^static bool DragBehavior(const ImRect& frame_bb, ImGuiID id, float* v, float v_speed, float v_min, float v_max, int decimal_precision, float power)$/;"	f	file:	signature:(const ImRect& frame_bb, ImGuiID id, float* v, float v_speed, float v_min, float v_max, int decimal_precision, float power)
DragCurrentValue	libs/imgui/imgui.cpp	/^    float                   DragCurrentValue;                   \/\/ current dragged value, always float, not rounded by end-user precision settings$/;"	m	struct:ImGuiState	file:	access:public
DragFloat	libs/imgui/imgui.cpp	/^bool ImGui::DragFloat(const char* label, float *v, float v_speed, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float *v, float v_speed, float v_min, float v_max, const char* display_format, float power)
DragFloat	libs/imgui/imgui.h	/^    IMGUI_API bool          DragFloat(const char* label, float* v, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", float power = 1.0f);     \/\/ If v_min >= v_max we have no bound$/;"	p	namespace:ImGui	signature:(const char* label, float* v, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = Ó, float power = 1.0f)
DragFloat2	libs/imgui/imgui.cpp	/^bool ImGui::DragFloat2(const char* label, float v[2], float v_speed, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float v[2], float v_speed, float v_min, float v_max, const char* display_format, float power)
DragFloat2	libs/imgui/imgui.h	/^    IMGUI_API bool          DragFloat2(const char* label, float v[2], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", float power = 1.0f);$/;"	p	namespace:ImGui	signature:(const char* label, float v[2], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = Ó, float power = 1.0f)
DragFloat3	libs/imgui/imgui.cpp	/^bool ImGui::DragFloat3(const char* label, float v[3], float v_speed, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float v[3], float v_speed, float v_min, float v_max, const char* display_format, float power)
DragFloat3	libs/imgui/imgui.h	/^    IMGUI_API bool          DragFloat3(const char* label, float v[3], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", float power = 1.0f);$/;"	p	namespace:ImGui	signature:(const char* label, float v[3], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = Ó, float power = 1.0f)
DragFloat4	libs/imgui/imgui.cpp	/^bool ImGui::DragFloat4(const char* label, float v[4], float v_speed, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float v[4], float v_speed, float v_min, float v_max, const char* display_format, float power)
DragFloat4	libs/imgui/imgui.h	/^    IMGUI_API bool          DragFloat4(const char* label, float v[4], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", float power = 1.0f);$/;"	p	namespace:ImGui	signature:(const char* label, float v[4], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = Ó, float power = 1.0f)
DragFloatN	libs/imgui/imgui.cpp	/^static bool DragFloatN(const char* label, float* v, int components, float v_speed, float v_min, float v_max, const char* display_format, float power)$/;"	f	file:	signature:(const char* label, float* v, int components, float v_speed, float v_min, float v_max, const char* display_format, float power)
DragFloatRange2	libs/imgui/imgui.cpp	/^bool ImGui::DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed, float v_min, float v_max, const char* display_format, const char* display_format_max, float power)$/;"	f	class:ImGui	signature:(const char* label, float* v_current_min, float* v_current_max, float v_speed, float v_min, float v_max, const char* display_format, const char* display_format_max, float power)
DragFloatRange2	libs/imgui/imgui.h	/^    IMGUI_API bool          DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", const char* display_format_max = NULL, float power = 1.0f);$/;"	p	namespace:ImGui	signature:(const char* label, float* v_current_min, float* v_current_max, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = Ó, const char* display_format_max = NULL, float power = 1.0f)
DragInt	libs/imgui/imgui.cpp	/^bool ImGui::DragInt(const char* label, int* v, float v_speed, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int* v, float v_speed, int v_min, int v_max, const char* display_format)
DragInt	libs/imgui/imgui.h	/^    IMGUI_API bool          DragInt(const char* label, int* v, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f");                                       \/\/ If v_min >= v_max we have no bound$/;"	p	namespace:ImGui	signature:(const char* label, int* v, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = Ó)
DragInt2	libs/imgui/imgui.cpp	/^bool ImGui::DragInt2(const char* label, int v[2], float v_speed, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int v[2], float v_speed, int v_min, int v_max, const char* display_format)
DragInt2	libs/imgui/imgui.h	/^    IMGUI_API bool          DragInt2(const char* label, int v[2], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f");$/;"	p	namespace:ImGui	signature:(const char* label, int v[2], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = Ó)
DragInt3	libs/imgui/imgui.cpp	/^bool ImGui::DragInt3(const char* label, int v[3], float v_speed, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int v[3], float v_speed, int v_min, int v_max, const char* display_format)
DragInt3	libs/imgui/imgui.h	/^    IMGUI_API bool          DragInt3(const char* label, int v[3], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f");$/;"	p	namespace:ImGui	signature:(const char* label, int v[3], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = Ó)
DragInt4	libs/imgui/imgui.cpp	/^bool ImGui::DragInt4(const char* label, int v[4], float v_speed, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int v[4], float v_speed, int v_min, int v_max, const char* display_format)
DragInt4	libs/imgui/imgui.h	/^    IMGUI_API bool          DragInt4(const char* label, int v[4], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f");$/;"	p	namespace:ImGui	signature:(const char* label, int v[4], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = Ó)
DragIntN	libs/imgui/imgui.cpp	/^static bool DragIntN(const char* label, int* v, int components, float v_speed, int v_min, int v_max, const char* display_format)$/;"	f	file:	signature:(const char* label, int* v, int components, float v_speed, int v_min, int v_max, const char* display_format)
DragIntRange2	libs/imgui/imgui.cpp	/^bool ImGui::DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed, int v_min, int v_max, const char* display_format, const char* display_format_max)$/;"	f	class:ImGui	signature:(const char* label, int* v_current_min, int* v_current_max, float v_speed, int v_min, int v_max, const char* display_format, const char* display_format_max)
DragIntRange2	libs/imgui/imgui.h	/^    IMGUI_API bool          DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f", const char* display_format_max = NULL);$/;"	p	namespace:ImGui	signature:(const char* label, int* v_current_min, int* v_current_max, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = Ó, const char* display_format_max = NULL)
DragLastMouseDelta	libs/imgui/imgui.cpp	/^    ImVec2                  DragLastMouseDelta;$/;"	m	struct:ImGuiState	file:	access:public
DragSpeedDefaultRatio	libs/imgui/imgui.cpp	/^    float                   DragSpeedDefaultRatio;              \/\/ if speed == 0.0f, uses (max-min) * DragSpeedDefaultRatio$/;"	m	struct:ImGuiState	file:	access:public
DragSpeedScaleFast	libs/imgui/imgui.cpp	/^    float                   DragSpeedScaleFast;$/;"	m	struct:ImGuiState	file:	access:public
DragSpeedScaleSlow	libs/imgui/imgui.cpp	/^    float                   DragSpeedScaleSlow;$/;"	m	struct:ImGuiState	file:	access:public
Draw	libs/imgui/imgui.cpp	/^void ImGuiTextFilter::Draw(const char* label, float width)$/;"	f	class:ImGuiTextFilter	signature:(const char* label, float width)
Draw	libs/imgui/imgui.h	/^    void Draw(const char* label = "Filter (inc,-exc)", float width = -1.0f);    \/\/ Helper calling InputText+Build$/;"	p	struct:ImGuiTextFilter	access:public	signature:(const char* label = Ó, float width = -1.0f)
DrawList	libs/imgui/imgui.cpp	/^    ImDrawList*             DrawList;$/;"	m	struct:ImGuiWindow	file:	access:public
DstFont	libs/imgui/imgui.h	/^    ImFont*         DstFont;$/;"	m	struct:ImFontConfig	access:public
Dummy	libs/imgui/imgui.cpp	/^void ImGui::Dummy(const ImVec2& size)$/;"	f	class:ImGui	signature:(const ImVec2& size)
Dummy	libs/imgui/imgui.h	/^    IMGUI_API void          Dummy(const ImVec2& size);                                          \/\/ add a dummy item of given size$/;"	p	namespace:ImGui	signature:(const ImVec2& size)
ENTITY_H	include/entities/Entity.h	2;"	d
ERROR	include/util/Log.h	/^const int ERROR = 0x04;$/;"	v
EXTRA	GaffMaker/Makefile	/^EXTRA = -Wno-write-strings #-Wno-deprecated$/;"	m
EXTRA	Makefile	/^EXTRA = -Wno-write-strings -Wno-unused-parameter #-Wno-deprecated$/;"	m
ElemCount	libs/imgui/imgui.h	/^    unsigned int    ElemCount;              \/\/ Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].$/;"	m	struct:ImDrawCmd	access:public
End	libs/imgui/imgui.cpp	/^void ImGui::End()$/;"	f	class:ImGui	signature:()
End	libs/imgui/imgui.h	/^    IMGUI_API void          End();$/;"	p	namespace:ImGui	signature:()
End	libs/imgui/imgui.h	/^    void End()$/;"	f	struct:ImGuiListClipper	access:public	signature:()
EndChild	libs/imgui/imgui.cpp	/^void ImGui::EndChild()$/;"	f	class:ImGui	signature:()
EndChild	libs/imgui/imgui.h	/^    IMGUI_API void          EndChild();$/;"	p	namespace:ImGui	signature:()
EndChildFrame	libs/imgui/imgui.cpp	/^void ImGui::EndChildFrame()$/;"	f	class:ImGui	signature:()
EndChildFrame	libs/imgui/imgui.h	/^    IMGUI_API void          EndChildFrame();$/;"	p	namespace:ImGui	signature:()
EndGroup	libs/imgui/imgui.cpp	/^void ImGui::EndGroup()$/;"	f	class:ImGui	signature:()
EndGroup	libs/imgui/imgui.h	/^    IMGUI_API void          EndGroup();$/;"	p	namespace:ImGui	signature:()
EndMainMenuBar	libs/imgui/imgui.cpp	/^void ImGui::EndMainMenuBar()$/;"	f	class:ImGui	signature:()
EndMainMenuBar	libs/imgui/imgui.h	/^    IMGUI_API void          EndMainMenuBar();$/;"	p	namespace:ImGui	signature:()
EndMenu	libs/imgui/imgui.cpp	/^void ImGui::EndMenu()$/;"	f	class:ImGui	signature:()
EndMenu	libs/imgui/imgui.h	/^    IMGUI_API void          EndMenu();$/;"	p	namespace:ImGui	signature:()
EndMenuBar	libs/imgui/imgui.cpp	/^void ImGui::EndMenuBar()$/;"	f	class:ImGui	signature:()
EndMenuBar	libs/imgui/imgui.h	/^    IMGUI_API void          EndMenuBar();$/;"	p	namespace:ImGui	signature:()
EndPopup	libs/imgui/imgui.cpp	/^void ImGui::EndPopup()$/;"	f	class:ImGui	signature:()
EndPopup	libs/imgui/imgui.h	/^    IMGUI_API void          EndPopup();$/;"	p	namespace:ImGui	signature:()
EndTooltip	libs/imgui/imgui.cpp	/^void ImGui::EndTooltip()$/;"	f	class:ImGui	signature:()
EndTooltip	libs/imgui/imgui.h	/^    IMGUI_API void          EndTooltip();$/;"	p	namespace:ImGui	signature:()
Entity	include/entities/Entity.h	/^class Entity {$/;"	c
Entity::init	include/entities/Entity.h	/^	void init();$/;"	p	class:Entity	access:public	signature:()
Entity::init	src/entities/Entity.cpp	/^void Entity::init() {$/;"	f	class:Entity	signature:()
Entity::position	include/entities/Entity.h	/^	vec4 position = vec4(0, 0, 0.0f, 1.0f);$/;"	m	class:Entity	access:public
Entity::render	include/entities/Entity.h	/^	void render();$/;"	p	class:Entity	access:public	signature:()
Entity::render	src/entities/Entity.cpp	/^void Entity::render() {$/;"	f	class:Entity	signature:()
Entity::tick	include/entities/Entity.h	/^	void tick();$/;"	p	class:Entity	access:public	signature:()
Entity::tick	src/entities/Entity.cpp	/^void Entity::tick() {$/;"	f	class:Entity	signature:()
EventChar	libs/imgui/imgui.h	/^    ImWchar             EventChar;      \/\/ Character input                      \/\/ Read-write (replace character or set to zero)$/;"	m	struct:ImGuiTextEditCallbackData	access:public
EventFlag	libs/imgui/imgui.h	/^    ImGuiInputTextFlags EventFlag;      \/\/ One of ImGuiInputTextFlags_Callback* \/\/ Read-only$/;"	m	struct:ImGuiTextEditCallbackData	access:public
EventKey	libs/imgui/imgui.h	/^    ImGuiKey            EventKey;       \/\/ Key pressed (Up\/Down\/TAB)            \/\/ Read-only$/;"	m	struct:ImGuiTextEditCallbackData	access:public
ExampleAppConsole	libs/imgui/imgui.cpp	/^    ExampleAppConsole()$/;"	f	struct:ExampleAppConsole	access:public	signature:()
ExampleAppConsole	libs/imgui/imgui.cpp	/^struct ExampleAppConsole$/;"	s	file:
ExampleAppConsole::AddLog	libs/imgui/imgui.cpp	/^    void    AddLog(const char* fmt, ...)$/;"	f	struct:ExampleAppConsole	access:public	signature:(const char* fmt, ...)
ExampleAppConsole::ClearLog	libs/imgui/imgui.cpp	/^    void    ClearLog()$/;"	f	struct:ExampleAppConsole	access:public	signature:()
ExampleAppConsole::Commands	libs/imgui/imgui.cpp	/^    ImVector<const char*> Commands;$/;"	m	struct:ExampleAppConsole	file:	access:public
ExampleAppConsole::ExampleAppConsole	libs/imgui/imgui.cpp	/^    ExampleAppConsole()$/;"	f	struct:ExampleAppConsole	access:public	signature:()
ExampleAppConsole::ExecCommand	libs/imgui/imgui.cpp	/^    void    ExecCommand(const char* command_line)$/;"	f	struct:ExampleAppConsole	access:public	signature:(const char* command_line)
ExampleAppConsole::History	libs/imgui/imgui.cpp	/^    ImVector<char*>       History;$/;"	m	struct:ExampleAppConsole	file:	access:public
ExampleAppConsole::HistoryPos	libs/imgui/imgui.cpp	/^    int                   HistoryPos;    \/\/ -1: new line, 0..History.Size-1 browsing history.$/;"	m	struct:ExampleAppConsole	file:	access:public
ExampleAppConsole::InputBuf	libs/imgui/imgui.cpp	/^    char                  InputBuf[256];$/;"	m	struct:ExampleAppConsole	file:	access:public
ExampleAppConsole::Items	libs/imgui/imgui.cpp	/^    ImVector<char*>       Items;$/;"	m	struct:ExampleAppConsole	file:	access:public
ExampleAppConsole::Run	libs/imgui/imgui.cpp	/^    void    Run(const char* title, bool* opened)$/;"	f	struct:ExampleAppConsole	access:public	signature:(const char* title, bool* opened)
ExampleAppConsole::ScrollToBottom	libs/imgui/imgui.cpp	/^    bool                  ScrollToBottom;$/;"	m	struct:ExampleAppConsole	file:	access:public
ExampleAppConsole::TextEditCallback	libs/imgui/imgui.cpp	/^    int     TextEditCallback(ImGuiTextEditCallbackData* data)$/;"	f	struct:ExampleAppConsole	access:public	signature:(ImGuiTextEditCallbackData* data)
ExampleAppConsole::TextEditCallbackStub	libs/imgui/imgui.cpp	/^    static int TextEditCallbackStub(ImGuiTextEditCallbackData* data) \/\/ In C++11 you are better off using lambdas for this sort of forwarding callbacks$/;"	f	struct:ExampleAppConsole	access:public	signature:(ImGuiTextEditCallbackData* data)
ExampleAppConsole::~ExampleAppConsole	libs/imgui/imgui.cpp	/^    ~ExampleAppConsole()$/;"	f	struct:ExampleAppConsole	access:public	signature:()
ExecCommand	libs/imgui/imgui.cpp	/^    void    ExecCommand(const char* command_line)$/;"	f	struct:ExampleAppConsole	access:public	signature:(const char* command_line)
ExecCommand	src/util/Console.cpp	/^	void    ExecCommand(const char* command_line)$/;"	f	struct:Console::Console	access:public	signature:(const char* command_line)
Expand	libs/imgui/imgui.cpp	/^    void        Expand(const ImVec2& amount)        { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }$/;"	f	struct:ImRect	access:public	signature:(const ImVec2& amount)
Expand	libs/imgui/imgui.cpp	/^    void        Expand(const float amount)          { Min.x -= amount; Min.y -= amount; Max.x += amount; Max.y += amount; }$/;"	f	struct:ImRect	access:public	signature:(const float amount)
FONT_H	include/gfx/Font.h	2;"	d
FT	include/Game.h	/^const float FT = 1.0f\/TPS;$/;"	v
FallbackChar	libs/imgui/imgui.h	/^    ImWchar                     FallbackChar;       \/\/ = '?'           \/\/ Replacement glyph if one isn't found. Only set via SetFallbackChar()$/;"	m	struct:ImFont	access:public
FallbackGlyph	libs/imgui/imgui.h	/^    const Glyph*                FallbackGlyph;      \/\/ == FindGlyph(FontFallbackChar)$/;"	m	struct:ImFont	access:public
FallbackXAdvance	libs/imgui/imgui.h	/^    float                       FallbackXAdvance;   \/\/$/;"	m	struct:ImFont	access:public
Filters	libs/imgui/imgui.h	/^    ImVector<TextRange> Filters;$/;"	m	struct:ImGuiTextFilter	access:public
FindBestPopupWindowPos	libs/imgui/imgui.cpp	/^static ImVec2 FindBestPopupWindowPos(const ImVec2& base_pos, const ImVec2& size, ImGuiWindowFlags flags, int* last_dir, const ImRect& r_inner)$/;"	f	file:	signature:(const ImVec2& base_pos, const ImVec2& size, ImGuiWindowFlags flags, int* last_dir, const ImRect& r_inner)
FindGlyph	libs/imgui/imgui.cpp	/^const ImFont::Glyph* ImFont::FindGlyph(unsigned short c) const$/;"	f	class:ImFont	signature:(unsigned short c) const
FindGlyph	libs/imgui/imgui.h	/^    IMGUI_API const Glyph*      FindGlyph(unsigned short c) const;$/;"	p	struct:ImFont	access:public	signature:(unsigned short c) const
FindHoveredWindow	libs/imgui/imgui.cpp	/^static ImGuiWindow* FindHoveredWindow(ImVec2 pos, bool excluding_childs)$/;"	f	file:	signature:(ImVec2 pos, bool excluding_childs)
FindHoveredWindow	libs/imgui/imgui.cpp	/^static ImGuiWindow* FindHoveredWindow(ImVec2 pos, bool excluding_childs);$/;"	p	file:	signature:(ImVec2 pos, bool excluding_childs)
FindTextDisplayEnd	libs/imgui/imgui.cpp	/^static const char*  FindTextDisplayEnd(const char* text, const char* text_end = NULL)$/;"	f	file:	signature:(const char* text, const char* text_end = NULL)
FindWindowByName	libs/imgui/imgui.cpp	/^static ImGuiWindow* FindWindowByName(const char* name)$/;"	f	file:	signature:(const char* name)
FindWindowSettings	libs/imgui/imgui.cpp	/^static ImGuiIniData* FindWindowSettings(const char* name)$/;"	f	file:	signature:(const char* name)
Flags	libs/imgui/imgui.cpp	/^    ImGuiWindowFlags        Flags;$/;"	m	struct:ImGuiWindow	file:	access:public
Flags	libs/imgui/imgui.h	/^    ImGuiInputTextFlags Flags;          \/\/ What user passed to InputText()      \/\/ Read-only$/;"	m	struct:ImGuiTextEditCallbackData	access:public
FocusIdxAllCounter	libs/imgui/imgui.cpp	/^    int                     FocusIdxAllCounter;                 \/\/ Start at -1 and increase as assigned via FocusItemRegister()$/;"	m	struct:ImGuiWindow	file:	access:public
FocusIdxAllRequestCurrent	libs/imgui/imgui.cpp	/^    int                     FocusIdxAllRequestCurrent;          \/\/ Item being requested for focus$/;"	m	struct:ImGuiWindow	file:	access:public
FocusIdxAllRequestNext	libs/imgui/imgui.cpp	/^    int                     FocusIdxAllRequestNext;             \/\/ Item being requested for focus, for next update (relies on layout to be stable between the frame pressing TAB and the next frame)$/;"	m	struct:ImGuiWindow	file:	access:public
FocusIdxTabCounter	libs/imgui/imgui.cpp	/^    int                     FocusIdxTabCounter;                 \/\/ (same, but only count widgets which you can Tab through)$/;"	m	struct:ImGuiWindow	file:	access:public
FocusIdxTabRequestCurrent	libs/imgui/imgui.cpp	/^    int                     FocusIdxTabRequestCurrent;          \/\/ Tab-able item being requested for focus$/;"	m	struct:ImGuiWindow	file:	access:public
FocusIdxTabRequestNext	libs/imgui/imgui.cpp	/^    int                     FocusIdxTabRequestNext;             \/\/ "$/;"	m	struct:ImGuiWindow	file:	access:public
FocusItemRegister	libs/imgui/imgui.cpp	/^    bool        FocusItemRegister(bool is_active, bool tab_stop = true);      \/\/ Return true if focus is requested$/;"	p	struct:ImGuiWindow	file:	access:public	signature:(bool is_active, bool tab_stop = true)
FocusItemRegister	libs/imgui/imgui.cpp	/^bool ImGuiWindow::FocusItemRegister(bool is_active, bool tab_stop)$/;"	f	class:ImGuiWindow	signature:(bool is_active, bool tab_stop)
FocusItemUnregister	libs/imgui/imgui.cpp	/^    void        FocusItemUnregister();$/;"	p	struct:ImGuiWindow	file:	access:public	signature:()
FocusItemUnregister	libs/imgui/imgui.cpp	/^void ImGuiWindow::FocusItemUnregister()$/;"	f	class:ImGuiWindow	signature:()
FocusWindow	libs/imgui/imgui.cpp	/^static void         FocusWindow(ImGuiWindow* window);$/;"	p	file:	signature:(ImGuiWindow* window)
FocusWindow	libs/imgui/imgui.cpp	/^static void FocusWindow(ImGuiWindow* window)$/;"	f	file:	signature:(ImGuiWindow* window)
FocusedWindow	libs/imgui/imgui.cpp	/^    ImGuiWindow*            FocusedWindow;                      \/\/ Will catch keyboard inputs$/;"	m	struct:ImGuiState	file:	access:public
Font	include/gfx/Font.h	/^namespace Font {$/;"	n
Font	libs/imgui/imgui.cpp	/^    ImFont*                 Font;                               \/\/ (Shortcut) == FontStack.empty() ? IO.Font : FontStack.back()$/;"	m	struct:ImGuiState	file:	access:public
Font	src/gfx/Font.cpp	/^namespace Font {$/;"	n	file:
Font::charCount	src/gfx/Font.cpp	/^    const int charCount = chars.length();$/;"	m	namespace:Font	file:
Font::charWidth	src/gfx/Font.cpp	/^    const float charWidth = 1.0f\/charCount;$/;"	m	namespace:Font	file:
Font::chars	src/gfx/Font.cpp	/^    const std::string chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,:;'\\"!?$%()-=+\/*[] ";$/;"	m	namespace:Font	file:
Font::fontScaleFloat	src/gfx/Font.cpp	/^    float fontScaleFloat = 1.0f;$/;"	m	namespace:Font	file:
Font::init	include/gfx/Font.h	/^    void init();$/;"	p	namespace:Font	signature:()
Font::init	src/gfx/Font.cpp	/^    void init() {$/;"	f	namespace:Font	signature:()
Font::initMatrix	src/gfx/Font.cpp	/^    mat4 initMatrix = translate(IDENTITY, vec3(0.8f * fontScaleFloat, fontScaleFloat, 0));$/;"	m	namespace:Font	file:
Font::positionMatrix	src/gfx/Font.cpp	/^    mat4 positionMatrix = translate(IDENTITY, vec3(1.0f, 0, 0));$/;"	m	namespace:Font	file:
Font::render	include/gfx/Font.h	/^    void render(vec4 position, vec4 color, std::string msg);$/;"	p	namespace:Font	signature:(vec4 position, vec4 color, std::string msg)
Font::render	src/gfx/Font.cpp	/^    void render(vec4 position, vec4 color, std::string msg) {$/;"	f	namespace:Font	signature:(vec4 position, vec4 color, std::string msg)
Font::tex	src/gfx/Font.cpp	/^    GLuint tex;$/;"	m	namespace:Font	file:
FontAllowUserScaling	libs/imgui/imgui.h	/^    bool          FontAllowUserScaling;     \/\/ = false              \/\/ Allow user scaling text of individual window with CTRL+Wheel.$/;"	m	struct:ImGuiIO	access:public
FontBaseSize	libs/imgui/imgui.cpp	/^    float                   FontBaseSize;                       \/\/ (Shortcut) == IO.FontGlobalScale * Font->Scale * Font->FontSize. Size of characters.$/;"	m	struct:ImGuiState	file:	access:public
FontData	libs/imgui/imgui.h	/^    void*           FontData;                   \/\/          \/\/ TTF data$/;"	m	struct:ImFontConfig	access:public
FontDataOwnedByAtlas	libs/imgui/imgui.h	/^    bool            FontDataOwnedByAtlas;       \/\/ true     \/\/ TTF data ownership taken by the container ImFontAtlas (will delete memory itself). Set to true $/;"	m	struct:ImFontConfig	access:public
FontDataSize	libs/imgui/imgui.h	/^    int             FontDataSize;               \/\/          \/\/ TTF data size$/;"	m	struct:ImFontConfig	access:public
FontGlobalScale	libs/imgui/imgui.h	/^    float         FontGlobalScale;          \/\/ = 1.0f               \/\/ Global scale all fonts$/;"	m	struct:ImGuiIO	access:public
FontNo	libs/imgui/imgui.h	/^    int             FontNo;                     \/\/ 0        \/\/ Index of font within TTF file$/;"	m	struct:ImFontConfig	access:public
FontSize	libs/imgui/imgui.cpp	/^    float                   FontSize;                           \/\/ (Shortcut) == FontBaseSize * g.CurrentWindow->FontWindowScale == window->FontSize()$/;"	m	struct:ImGuiState	file:	access:public
FontSize	libs/imgui/imgui.h	/^    float                       FontSize;           \/\/ <user set>      \/\/ Height of characters, set during loading (don't change after loading)$/;"	m	struct:ImFont	access:public
FontStack	libs/imgui/imgui.cpp	/^    ImVector<ImFont*>       FontStack;$/;"	m	struct:ImGuiState	file:	access:public
FontTexUvWhitePixel	libs/imgui/imgui.cpp	/^    ImVec2                  FontTexUvWhitePixel;                \/\/ (Shortcut) == Font->TexUvForWhite$/;"	m	struct:ImGuiState	file:	access:public
FontWindowScale	libs/imgui/imgui.cpp	/^    float                   FontWindowScale;                    \/\/ Scale multiplier per-window$/;"	m	struct:ImGuiWindow	file:	access:public
Fonts	libs/imgui/imgui.h	/^    ImFontAtlas*  Fonts;                    \/\/ <auto>               \/\/ Load and assemble one or more fonts into a single tightly packed texture. Output to Fonts array.$/;"	m	struct:ImGuiIO	access:public
Fonts	libs/imgui/imgui.h	/^    ImVector<ImFont*>           Fonts;$/;"	m	struct:ImFontAtlas	access:public
FrameCount	libs/imgui/imgui.cpp	/^    int                     FrameCount;$/;"	m	struct:ImGuiState	file:	access:public
FrameCountRendered	libs/imgui/imgui.cpp	/^    int                     FrameCountRendered;$/;"	m	struct:ImGuiState	file:	access:public
FramePadding	libs/imgui/imgui.h	/^    ImVec2      FramePadding;               \/\/ Padding within a framed rectangle (used by most widgets)$/;"	m	struct:ImGuiStyle	access:public
FrameRounding	libs/imgui/imgui.h	/^    float       FrameRounding;              \/\/ Radius of frame corners rounding. Set to 0.0f to have rectangular frame (used by most widgets).$/;"	m	struct:ImGuiStyle	access:public
Framerate	libs/imgui/imgui.h	/^    float       Framerate;                  \/\/ Framerate estimation, in frame per second. Rolling average estimation based on IO.DeltaTime over 120 frames$/;"	m	struct:ImGuiIO	access:public
FramerateSecPerFrame	libs/imgui/imgui.cpp	/^    float                   FramerateSecPerFrame[120];          \/\/ calculate estimate of framerate for user$/;"	m	struct:ImGuiState	file:	access:public
FramerateSecPerFrameAccum	libs/imgui/imgui.cpp	/^    float                   FramerateSecPerFrameAccum;$/;"	m	struct:ImGuiState	file:	access:public
FramerateSecPerFrameIdx	libs/imgui/imgui.cpp	/^    int                     FramerateSecPerFrameIdx;$/;"	m	struct:ImGuiState	file:	access:public
GAME_H	include/Game.h	2;"	d
GDefaultFontAtlas	libs/imgui/imgui.cpp	/^static ImFontAtlas GDefaultFontAtlas;$/;"	v	file:
GImDefaultState	libs/imgui/imgui.cpp	/^static ImGuiState   GImDefaultState;                            \/\/ Internal state storage$/;"	v	file:
GImGui	libs/imgui/imgui.cpp	/^static ImGuiState*  GImGui = &GImDefaultState;                  \/\/ We access everything through this pointer. NB: this pointer is always assumed to be != NULL$/;"	v	file:
GLFW_EXPOSE_NATIVE_WGL	libs/imgui/imgui_impl_glfw_gl3.cpp	13;"	d	file:
GLFW_EXPOSE_NATIVE_WIN32	libs/imgui/imgui_impl_glfw_gl3.cpp	12;"	d	file:
Gaff	GaffMaker/include/Definitions.h	/^class Gaff {$/;"	c
Gaff	include/Definitions.h	/^class Gaff {$/;"	c
Gaff::MAGIC	GaffMaker/include/Definitions.h	/^	static constexpr byte MAGIC[5] = {"GAFF"};$/;"	m	class:Gaff	access:public
Gaff::MAGIC	include/Definitions.h	/^	static constexpr byte MAGIC[5] = {"GAFF"};$/;"	m	class:Gaff	access:public
Gaff::VERSION	GaffMaker/include/Definitions.h	/^	static const byte VERSION = 0x01;$/;"	m	class:Gaff	access:public
Gaff::VERSION	include/Definitions.h	/^	static const byte VERSION = 0x01;$/;"	m	class:Gaff	access:public
Gaff::fileInfo	GaffMaker/include/Definitions.h	/^	struct fileInfo {$/;"	s	class:Gaff	access:public
Gaff::fileInfo	include/Definitions.h	/^	struct fileInfo {$/;"	s	class:Gaff	access:public
Gaff::fileInfo::extra	GaffMaker/include/Definitions.h	/^	    byteInt extra;$/;"	m	struct:Gaff::fileInfo	access:public
Gaff::fileInfo::extra	include/Definitions.h	/^	    byteInt extra;$/;"	m	struct:Gaff::fileInfo	access:public
Gaff::fileInfo::name	GaffMaker/include/Definitions.h	/^	    std::string name = "";$/;"	m	struct:Gaff::fileInfo	access:public
Gaff::fileInfo::name	include/Definitions.h	/^	    std::string name = "";$/;"	m	struct:Gaff::fileInfo	access:public
Gaff::fileInfo::nameSize	GaffMaker/include/Definitions.h	/^	    byte nameSize = 0x00;$/;"	m	struct:Gaff::fileInfo	access:public
Gaff::fileInfo::nameSize	include/Definitions.h	/^	    byte nameSize = 0x00;$/;"	m	struct:Gaff::fileInfo	access:public
Gaff::fileInfo::offset	GaffMaker/include/Definitions.h	/^	    byteInt offset;$/;"	m	struct:Gaff::fileInfo	access:public
Gaff::fileInfo::offset	include/Definitions.h	/^	    byteInt offset;$/;"	m	struct:Gaff::fileInfo	access:public
Gaff::fileInfo::origin	GaffMaker/include/Definitions.h	/^	    std::string origin = "";$/;"	m	struct:Gaff::fileInfo	access:public
Gaff::fileInfo::origin	include/Definitions.h	/^	    std::string origin = "";$/;"	m	struct:Gaff::fileInfo	access:public
Gaff::fileInfo::size	GaffMaker/include/Definitions.h	/^	    byteInt size;$/;"	m	struct:Gaff::fileInfo	access:public
Gaff::fileInfo::size	include/Definitions.h	/^	    byteInt size;$/;"	m	struct:Gaff::fileInfo	access:public
Gaff::fileInfo::type	GaffMaker/include/Definitions.h	/^	    byte type = 0x00;$/;"	m	struct:Gaff::fileInfo	access:public
Gaff::fileInfo::type	include/Definitions.h	/^	    byte type = 0x00;$/;"	m	struct:Gaff::fileInfo	access:public
Game	include/Game.h	/^namespace Game {$/;"	n
Game	src/Game.cpp	/^namespace Game {$/;"	n	file:
Game::actualFPS	src/Game.cpp	/^    int actualFPS = 0;$/;"	m	namespace:Game	file:
Game::actualTPS	src/Game.cpp	/^    int actualTPS = 0;$/;"	m	namespace:Game	file:
Game::avgFT	src/Game.cpp	/^    float avgFT = 0;$/;"	m	namespace:Game	file:
Game::control	src/Game.cpp	/^    void control() {$/;"	f	namespace:Game	signature:()
Game::control	src/Game.cpp	/^    void control();$/;"	p	namespace:Game	file:	signature:()
Game::end	src/Game.cpp	/^    void end() {$/;"	f	namespace:Game	signature:()
Game::end	src/Game.cpp	/^    void end();$/;"	p	namespace:Game	file:	signature:()
Game::frames	src/Game.cpp	/^    int frames = 0;$/;"	m	namespace:Game	file:
Game::gameLoop	src/Game.cpp	/^    void gameLoop() {$/;"	f	namespace:Game	signature:()
Game::gameLoop	src/Game.cpp	/^    void gameLoop();$/;"	p	namespace:Game	file:	signature:()
Game::init	src/Game.cpp	/^    void init() {$/;"	f	namespace:Game	signature:()
Game::init	src/Game.cpp	/^    void init();$/;"	p	namespace:Game	file:	signature:()
Game::lastTick	src/Game.cpp	/^    float lastTick;$/;"	m	namespace:Game	file:
Game::main	include/Game.h	/^    void main();$/;"	p	namespace:Game	signature:()
Game::main	src/Game.cpp	/^    void main() {$/;"	f	namespace:Game	signature:()
Game::maxFT	src/Game.cpp	/^    float maxFT = 0;$/;"	m	namespace:Game	file:
Game::minFT	src/Game.cpp	/^    float minFT = 10;$/;"	m	namespace:Game	file:
Game::paused	src/Game.cpp	/^    bool paused = false;$/;"	m	namespace:Game	file:
Game::player	src/Game.cpp	/^    Entity *player = Level::getPlayer();$/;"	m	namespace:Game	file:
Game::proc	src/Game.cpp	/^    struct proc_t proc;$/;"	m	namespace:Game	typeref:struct:Game::proc_t	file:
Game::render	src/Game.cpp	/^    void render() {$/;"	f	namespace:Game	signature:()
Game::render	src/Game.cpp	/^    void render();$/;"	p	namespace:Game	file:	signature:()
Game::renderDebug	src/Game.cpp	/^    void renderDebug() {$/;"	f	namespace:Game	signature:()
Game::renderDebug	src/Game.cpp	/^    void renderDebug();$/;"	p	namespace:Game	file:	signature:()
Game::showConsole	src/Game.cpp	/^    bool showConsole = false;$/;"	m	namespace:Game	file:
Game::showDebug	src/Game.cpp	/^    bool showDebug = false;$/;"	m	namespace:Game	file:
Game::switchInput	src/Game.cpp	/^    bool switchInput = false;$/;"	m	namespace:Game	file:
Game::tick	src/Game.cpp	/^    void tick() {$/;"	f	namespace:Game	signature:()
Game::tick	src/Game.cpp	/^    void tick();$/;"	p	namespace:Game	file:	signature:()
Game::ticks	src/Game.cpp	/^    int ticks = 0;$/;"	m	namespace:Game	file:
Game::vsize	src/Game.cpp	/^    float vsize = proc.vsize \/ 1000000;$/;"	m	namespace:Game	file:
GetBL	libs/imgui/imgui.cpp	/^    ImVec2      GetBL() const                       { return ImVec2(Min.x,Max.y); }$/;"	f	struct:ImRect	access:public	signature:() const
GetBR	libs/imgui/imgui.cpp	/^    ImVec2      GetBR() const                       { return Max; }$/;"	f	struct:ImRect	access:public	signature:() const
GetCenter	libs/imgui/imgui.cpp	/^    ImVec2      GetCenter() const                   { return ImVec2((Min.x+Max.x)*0.5f, (Min.y+Max.y)*0.5f); }$/;"	f	struct:ImRect	access:public	signature:() const
GetCharAdvance	libs/imgui/imgui.h	/^    IMGUI_API float             GetCharAdvance(unsigned short c) const  { return ((int)c < IndexXAdvance.Size) ? IndexXAdvance[(int)c] : FallbackXAdvance; }$/;"	f	struct:ImFont	access:public	signature:(unsigned short c) const
GetClipboardTextFn	libs/imgui/imgui.h	/^    const char* (*GetClipboardTextFn)();$/;"	m	struct:ImGuiIO	access:public
GetClipboardTextFn_DefaultImpl	libs/imgui/imgui.cpp	/^static const char*  GetClipboardTextFn_DefaultImpl();$/;"	p	file:	signature:()
GetClipboardTextFn_DefaultImpl	libs/imgui/imgui.cpp	/^static const char* GetClipboardTextFn_DefaultImpl()$/;"	f	file:	signature:()
GetClosestPoint	libs/imgui/imgui.cpp	/^    ImVec2      GetClosestPoint(ImVec2 p, bool on_edge) const$/;"	f	struct:ImRect	access:public	signature:(ImVec2 p, bool on_edge) const
GetColumnIndex	libs/imgui/imgui.cpp	/^int ImGui::GetColumnIndex()$/;"	f	class:ImGui	signature:()
GetColumnIndex	libs/imgui/imgui.h	/^    IMGUI_API int           GetColumnIndex();                                                   \/\/ get current column index$/;"	p	namespace:ImGui	signature:()
GetColumnOffset	libs/imgui/imgui.cpp	/^float ImGui::GetColumnOffset(int column_index)$/;"	f	class:ImGui	signature:(int column_index)
GetColumnOffset	libs/imgui/imgui.h	/^    IMGUI_API float         GetColumnOffset(int column_index = -1);                             \/\/ get position of column line (in pixels, from the left side of the contents region). pass -1 to use current column, otherwise 0..GetcolumnsCount() inclusive. column 0 is usually 0.0f and not resizable unless you call this$/;"	p	namespace:ImGui	signature:(int column_index = -1)
GetColumnWidth	libs/imgui/imgui.cpp	/^float ImGui::GetColumnWidth(int column_index)$/;"	f	class:ImGui	signature:(int column_index)
GetColumnWidth	libs/imgui/imgui.h	/^    IMGUI_API float         GetColumnWidth(int column_index = -1);                              \/\/ column width (== GetColumnOffset(GetColumnIndex()+1) - GetColumnOffset(GetColumnOffset())$/;"	p	namespace:ImGui	signature:(int column_index = -1)
GetColumnsCount	libs/imgui/imgui.cpp	/^int ImGui::GetColumnsCount()$/;"	f	class:ImGui	signature:()
GetColumnsCount	libs/imgui/imgui.h	/^    IMGUI_API int           GetColumnsCount();                                                  \/\/ number of columns (what was passed to Columns())$/;"	p	namespace:ImGui	signature:()
GetContentRegionMax	libs/imgui/imgui.cpp	/^ImVec2 ImGui::GetContentRegionMax()$/;"	f	class:ImGui	signature:()
GetContentRegionMax	libs/imgui/imgui.h	/^    IMGUI_API ImVec2        GetContentRegionMax();                                              \/\/ window or current column boundaries, in windows coordinates$/;"	p	namespace:ImGui	signature:()
GetCurrentWindow	libs/imgui/imgui.cpp	/^static inline ImGuiWindow* GetCurrentWindow()$/;"	f	file:	signature:()
GetCursorPos	libs/imgui/imgui.cpp	/^ImVec2 ImGui::GetCursorPos()$/;"	f	class:ImGui	signature:()
GetCursorPos	libs/imgui/imgui.h	/^    IMGUI_API ImVec2        GetCursorPos();                                                     \/\/ cursor position is relative to window position$/;"	p	namespace:ImGui	signature:()
GetCursorPosX	libs/imgui/imgui.cpp	/^float ImGui::GetCursorPosX()$/;"	f	class:ImGui	signature:()
GetCursorPosX	libs/imgui/imgui.h	/^    IMGUI_API float         GetCursorPosX();                                                    \/\/ "$/;"	p	namespace:ImGui	signature:()
GetCursorPosY	libs/imgui/imgui.cpp	/^float ImGui::GetCursorPosY()$/;"	f	class:ImGui	signature:()
GetCursorPosY	libs/imgui/imgui.h	/^    IMGUI_API float         GetCursorPosY();                                                    \/\/ "$/;"	p	namespace:ImGui	signature:()
GetCursorScreenPos	libs/imgui/imgui.cpp	/^ImVec2 ImGui::GetCursorScreenPos()$/;"	f	class:ImGui	signature:()
GetCursorScreenPos	libs/imgui/imgui.h	/^    IMGUI_API ImVec2        GetCursorScreenPos();                                               \/\/ cursor position in absolute screen coordinates [0..io.DisplaySize]$/;"	p	namespace:ImGui	signature:()
GetCursorStartPos	libs/imgui/imgui.cpp	/^ImVec2 ImGui::GetCursorStartPos()$/;"	f	class:ImGui	signature:()
GetCursorStartPos	libs/imgui/imgui.h	/^    IMGUI_API ImVec2        GetCursorStartPos();                                                \/\/ initial cursor position $/;"	p	namespace:ImGui	signature:()
GetDefaultCompressedFontDataTTFBase85	libs/imgui/imgui.cpp	/^static const char*  GetDefaultCompressedFontDataTTFBase85();$/;"	p	file:	signature:()
GetDefaultCompressedFontDataTTFBase85	libs/imgui/imgui.cpp	/^static const char* GetDefaultCompressedFontDataTTFBase85() $/;"	f	file:	signature:()
GetDraggedColumnOffset	libs/imgui/imgui.cpp	/^static float GetDraggedColumnOffset(int column_index)$/;"	f	file:	signature:(int column_index)
GetFloat	libs/imgui/imgui.cpp	/^float ImGuiStorage::GetFloat(ImU32 key, float default_val) const$/;"	f	class:ImGuiStorage	signature:(ImU32 key, float default_val) const
GetFloat	libs/imgui/imgui.h	/^    IMGUI_API float   GetFloat(ImGuiID key, float default_val = 0.0f) const;$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, float default_val = 0.0f) const
GetFloatRef	libs/imgui/imgui.cpp	/^float* ImGuiStorage::GetFloatRef(ImGuiID key, float default_val)$/;"	f	class:ImGuiStorage	signature:(ImGuiID key, float default_val)
GetFloatRef	libs/imgui/imgui.h	/^    IMGUI_API float*  GetFloatRef(ImGuiID key, float default_val = 0);$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, float default_val = 0)
GetFrameCount	libs/imgui/imgui.cpp	/^int ImGui::GetFrameCount()$/;"	f	class:ImGui	signature:()
GetFrameCount	libs/imgui/imgui.h	/^    IMGUI_API int           GetFrameCount();$/;"	p	namespace:ImGui	signature:()
GetFrontMostModalRootWindow	libs/imgui/imgui.cpp	/^static ImGuiWindow* GetFrontMostModalRootWindow()$/;"	f	file:	signature:()
GetFrontMostModalRootWindow	libs/imgui/imgui.cpp	/^static ImGuiWindow* GetFrontMostModalRootWindow();$/;"	p	file:	signature:()
GetGlyphRangesChinese	libs/imgui/imgui.cpp	/^const ImWchar*  ImFontAtlas::GetGlyphRangesChinese()$/;"	f	class:ImFontAtlas	signature:()
GetGlyphRangesChinese	libs/imgui/imgui.h	/^    IMGUI_API const ImWchar*    GetGlyphRangesChinese();    \/\/ Japanese + full set of about 21000 CJK Unified Ideographs$/;"	p	struct:ImFontAtlas	access:public	signature:()
GetGlyphRangesCyrillic	libs/imgui/imgui.cpp	/^const ImWchar*  ImFontAtlas::GetGlyphRangesCyrillic()$/;"	f	class:ImFontAtlas	signature:()
GetGlyphRangesCyrillic	libs/imgui/imgui.h	/^    IMGUI_API const ImWchar*    GetGlyphRangesCyrillic();   \/\/ Default + about 400 Cyrillic characters$/;"	p	struct:ImFontAtlas	access:public	signature:()
GetGlyphRangesDefault	libs/imgui/imgui.cpp	/^const ImWchar*   ImFontAtlas::GetGlyphRangesDefault()$/;"	f	class:ImFontAtlas	signature:()
GetGlyphRangesDefault	libs/imgui/imgui.h	/^    IMGUI_API const ImWchar*    GetGlyphRangesDefault();    \/\/ Basic Latin, Extended Latin$/;"	p	struct:ImFontAtlas	access:public	signature:()
GetGlyphRangesJapanese	libs/imgui/imgui.cpp	/^const ImWchar*  ImFontAtlas::GetGlyphRangesJapanese()$/;"	f	class:ImFontAtlas	signature:()
GetGlyphRangesJapanese	libs/imgui/imgui.h	/^    IMGUI_API const ImWchar*    GetGlyphRangesJapanese();   \/\/ Default + Hiragana, Katakana, Half-Width, Selection of 1946 Ideographs$/;"	p	struct:ImFontAtlas	access:public	signature:()
GetHeight	libs/imgui/imgui.cpp	/^    float       GetHeight() const                   { return Max.y-Min.y; }$/;"	f	struct:ImRect	access:public	signature:() const
GetID	libs/imgui/imgui.cpp	/^    ImGuiID     GetID(const char* str, const char* str_end = NULL);$/;"	p	struct:ImGuiWindow	file:	access:public	signature:(const char* str, const char* str_end = NULL)
GetID	libs/imgui/imgui.cpp	/^    ImGuiID     GetID(const void* ptr);$/;"	p	struct:ImGuiWindow	file:	access:public	signature:(const void* ptr)
GetID	libs/imgui/imgui.cpp	/^ImGuiID ImGui::GetID(const char* str_id)$/;"	f	class:ImGui	signature:(const char* str_id)
GetID	libs/imgui/imgui.cpp	/^ImGuiID ImGui::GetID(const char* str_id_begin, const char* str_id_end)$/;"	f	class:ImGui	signature:(const char* str_id_begin, const char* str_id_end)
GetID	libs/imgui/imgui.cpp	/^ImGuiID ImGui::GetID(const void* ptr_id)$/;"	f	class:ImGui	signature:(const void* ptr_id)
GetID	libs/imgui/imgui.cpp	/^ImGuiID ImGuiWindow::GetID(const char* str, const char* str_end)$/;"	f	class:ImGuiWindow	signature:(const char* str, const char* str_end)
GetID	libs/imgui/imgui.cpp	/^ImGuiID ImGuiWindow::GetID(const void* ptr)$/;"	f	class:ImGuiWindow	signature:(const void* ptr)
GetID	libs/imgui/imgui.h	/^    IMGUI_API ImGuiID       GetID(const char* str_id);                                          \/\/ calculate unique ID (hash of whole ID stack + given parameter). useful if you want to query into ImGuiStorage yourself. otherwise rarely needed$/;"	p	namespace:ImGui	signature:(const char* str_id)
GetID	libs/imgui/imgui.h	/^    IMGUI_API ImGuiID       GetID(const char* str_id_begin, const char* str_id_end);$/;"	p	namespace:ImGui	signature:(const char* str_id_begin, const char* str_id_end)
GetID	libs/imgui/imgui.h	/^    IMGUI_API ImGuiID       GetID(const void* ptr_id);$/;"	p	namespace:ImGui	signature:(const void* ptr_id)
GetIO	libs/imgui/imgui.cpp	/^ImGuiIO& ImGui::GetIO()$/;"	f	class:ImGui	signature:()
GetIO	libs/imgui/imgui.h	/^    IMGUI_API ImGuiIO&      GetIO();$/;"	p	namespace:ImGui	signature:()
GetInt	libs/imgui/imgui.cpp	/^int ImGuiStorage::GetInt(ImU32 key, int default_val) const$/;"	f	class:ImGuiStorage	signature:(ImU32 key, int default_val) const
GetInt	libs/imgui/imgui.h	/^    IMGUI_API int     GetInt(ImGuiID key, int default_val = 0) const;$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, int default_val = 0) const
GetIntRef	libs/imgui/imgui.cpp	/^int* ImGuiStorage::GetIntRef(ImGuiID key, int default_val)$/;"	f	class:ImGuiStorage	signature:(ImGuiID key, int default_val)
GetIntRef	libs/imgui/imgui.h	/^    IMGUI_API int*    GetIntRef(ImGuiID key, int default_val = 0);$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, int default_val = 0)
GetInternalState	libs/imgui/imgui.cpp	/^void* ImGui::GetInternalState()$/;"	f	class:ImGui	signature:()
GetInternalState	libs/imgui/imgui.h	/^    IMGUI_API void*         GetInternalState();$/;"	p	namespace:ImGui	signature:()
GetInternalStateSize	libs/imgui/imgui.cpp	/^size_t ImGui::GetInternalStateSize()$/;"	f	class:ImGui	signature:()
GetInternalStateSize	libs/imgui/imgui.h	/^    IMGUI_API size_t        GetInternalStateSize();$/;"	p	namespace:ImGui	signature:()
GetItemBoxMax	libs/imgui/imgui.h	/^    static inline ImVec2    GetItemBoxMax() { return GetItemRectMax(); }                       \/\/ OBSOLETE 1.36+$/;"	f	namespace:ImGui	signature:()
GetItemBoxMin	libs/imgui/imgui.h	/^    static inline ImVec2    GetItemBoxMin() { return GetItemRectMin(); }                       \/\/ OBSOLETE 1.36+$/;"	f	namespace:ImGui	signature:()
GetItemRectMax	libs/imgui/imgui.cpp	/^ImVec2 ImGui::GetItemRectMax()$/;"	f	class:ImGui	signature:()
GetItemRectMax	libs/imgui/imgui.h	/^    IMGUI_API ImVec2        GetItemRectMax();                                                   \/\/ "$/;"	p	namespace:ImGui	signature:()
GetItemRectMin	libs/imgui/imgui.cpp	/^ImVec2 ImGui::GetItemRectMin()$/;"	f	class:ImGui	signature:()
GetItemRectMin	libs/imgui/imgui.h	/^    IMGUI_API ImVec2        GetItemRectMin();                                                   \/\/ get bounding rect of last item in screen space$/;"	p	namespace:ImGui	signature:()
GetItemRectSize	libs/imgui/imgui.cpp	/^ImVec2 ImGui::GetItemRectSize()$/;"	f	class:ImGui	signature:()
GetItemRectSize	libs/imgui/imgui.h	/^    IMGUI_API ImVec2        GetItemRectSize();                                                  \/\/ "$/;"	p	namespace:ImGui	signature:()
GetItemsLineHeightWithSpacing	libs/imgui/imgui.cpp	/^float ImGui::GetItemsLineHeightWithSpacing()$/;"	f	class:ImGui	signature:()
GetItemsLineHeightWithSpacing	libs/imgui/imgui.h	/^    IMGUI_API float         GetItemsLineHeightWithSpacing();                                    \/\/ distance (in pixels) between 2 consecutive lines of standard height widgets == GetWindowFontSize() + GetStyle().FramePadding.y*2 + GetStyle().ItemSpacing.y$/;"	p	namespace:ImGui	signature:()
GetKeyIndex	libs/imgui/imgui.cpp	/^int ImGui::GetKeyIndex(ImGuiKey key)$/;"	f	class:ImGui	signature:(ImGuiKey key)
GetKeyIndex	libs/imgui/imgui.h	/^    IMGUI_API int           GetKeyIndex(ImGuiKey key);                                          \/\/ map ImGuiKey_* values into user's key index. == io.KeyMap[key]$/;"	p	namespace:ImGui	signature:(ImGuiKey key)
GetMouseCursor	libs/imgui/imgui.cpp	/^ImGuiMouseCursor ImGui::GetMouseCursor()$/;"	f	class:ImGui	signature:()
GetMouseCursor	libs/imgui/imgui.h	/^    IMGUI_API ImGuiMouseCursor GetMouseCursor();                                                \/\/ get desired cursor type, reset in ImGui::NewFrame(), this updated during the frame. valid before Render(). If you use software rendering by setting io.MouseDrawCursor ImGui will render those for you$/;"	p	namespace:ImGui	signature:()
GetMouseDragDelta	libs/imgui/imgui.cpp	/^ImVec2 ImGui::GetMouseDragDelta(int button, float lock_threshold)$/;"	f	class:ImGui	signature:(int button, float lock_threshold)
GetMouseDragDelta	libs/imgui/imgui.h	/^    IMGUI_API ImVec2        GetMouseDragDelta(int button = 0, float lock_threshold = -1.0f);    \/\/ dragging amount since clicking, also see: GetItemActiveDragDelta(). if lock_threshold < -1.0f uses io.MouseDraggingThreshold$/;"	p	namespace:ImGui	signature:(int button = 0, float lock_threshold = -1.0f)
GetMousePos	libs/imgui/imgui.cpp	/^ImVec2 ImGui::GetMousePos()$/;"	f	class:ImGui	signature:()
GetMousePos	libs/imgui/imgui.h	/^    IMGUI_API ImVec2        GetMousePos();                                                      \/\/ shortcut to ImGui::GetIO().MousePos provided by user, to be consistent with other calls$/;"	p	namespace:ImGui	signature:()
GetParentWindow	libs/imgui/imgui.cpp	/^static inline ImGuiWindow* GetParentWindow()$/;"	f	file:	signature:()
GetScrollMaxY	libs/imgui/imgui.cpp	/^float ImGui::GetScrollMaxY()$/;"	f	class:ImGui	signature:()
GetScrollMaxY	libs/imgui/imgui.h	/^    IMGUI_API float         GetScrollMaxY();                                                    \/\/ get maximum scrolling amount == ContentSize.Y - WindowSize.Y$/;"	p	namespace:ImGui	signature:()
GetScrollY	libs/imgui/imgui.cpp	/^float ImGui::GetScrollY()$/;"	f	class:ImGui	signature:()
GetScrollY	libs/imgui/imgui.h	/^    IMGUI_API float         GetScrollY();                                                       \/\/ get scrolling amount [0..GetScrollMaxY()]$/;"	p	namespace:ImGui	signature:()
GetSize	libs/imgui/imgui.cpp	/^    ImVec2      GetSize() const                     { return ImVec2(Max.x-Min.x,Max.y-Min.y); }$/;"	f	struct:ImRect	access:public	signature:() const
GetStateStorage	libs/imgui/imgui.cpp	/^ImGuiStorage* ImGui::GetStateStorage()$/;"	f	class:ImGui	signature:()
GetStateStorage	libs/imgui/imgui.h	/^    IMGUI_API ImGuiStorage* GetStateStorage();$/;"	p	namespace:ImGui	signature:()
GetStyle	libs/imgui/imgui.cpp	/^ImGuiStyle& ImGui::GetStyle()$/;"	f	class:ImGui	signature:()
GetStyle	libs/imgui/imgui.h	/^    IMGUI_API ImGuiStyle&   GetStyle();$/;"	p	namespace:ImGui	signature:()
GetStyleColName	libs/imgui/imgui.cpp	/^const char* ImGui::GetStyleColName(ImGuiCol idx)$/;"	f	class:ImGui	signature:(ImGuiCol idx)
GetStyleColName	libs/imgui/imgui.h	/^    IMGUI_API const char*   GetStyleColName(ImGuiCol idx);$/;"	p	namespace:ImGui	signature:(ImGuiCol idx)
GetStyleVarFloatAddr	libs/imgui/imgui.cpp	/^static float* GetStyleVarFloatAddr(ImGuiStyleVar idx)$/;"	f	file:	signature:(ImGuiStyleVar idx)
GetStyleVarVec2Addr	libs/imgui/imgui.cpp	/^static ImVec2* GetStyleVarVec2Addr(ImGuiStyleVar idx)$/;"	f	file:	signature:(ImGuiStyleVar idx)
GetTL	libs/imgui/imgui.cpp	/^    ImVec2      GetTL() const                       { return Min; }$/;"	f	struct:ImRect	access:public	signature:() const
GetTR	libs/imgui/imgui.cpp	/^    ImVec2      GetTR() const                       { return ImVec2(Max.x,Min.y); }$/;"	f	struct:ImRect	access:public	signature:() const
GetTexDataAsAlpha8	libs/imgui/imgui.cpp	/^void    ImFontAtlas::GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)$/;"	f	class:ImFontAtlas	signature:(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)
GetTexDataAsAlpha8	libs/imgui/imgui.h	/^    IMGUI_API void              GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  \/\/ 1 byte per-pixel$/;"	p	struct:ImFontAtlas	access:public	signature:(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL)
GetTexDataAsRGBA32	libs/imgui/imgui.cpp	/^void    ImFontAtlas::GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)$/;"	f	class:ImFontAtlas	signature:(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)
GetTexDataAsRGBA32	libs/imgui/imgui.h	/^    IMGUI_API void              GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  \/\/ 4 bytes-per-pixel$/;"	p	struct:ImFontAtlas	access:public	signature:(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL)
GetTextLineHeight	libs/imgui/imgui.cpp	/^float ImGui::GetTextLineHeight()$/;"	f	class:ImGui	signature:()
GetTextLineHeight	libs/imgui/imgui.h	/^    IMGUI_API float         GetTextLineHeight();                                                \/\/ height of font == GetWindowFontSize()$/;"	p	namespace:ImGui	signature:()
GetTextLineHeightWithSpacing	libs/imgui/imgui.cpp	/^float ImGui::GetTextLineHeightWithSpacing()$/;"	f	class:ImGui	signature:()
GetTextLineHeightWithSpacing	libs/imgui/imgui.h	/^    IMGUI_API float         GetTextLineHeightWithSpacing();                                     \/\/ distance (in pixels) between 2 consecutive lines of text == GetWindowFontSize() + GetStyle().ItemSpacing.y$/;"	p	namespace:ImGui	signature:()
GetTime	libs/imgui/imgui.cpp	/^float ImGui::GetTime()$/;"	f	class:ImGui	signature:()
GetTime	libs/imgui/imgui.h	/^    IMGUI_API float         GetTime();$/;"	p	namespace:ImGui	signature:()
GetVersion	libs/imgui/imgui.cpp	/^const char* ImGui::GetVersion()$/;"	f	class:ImGui	signature:()
GetVersion	libs/imgui/imgui.h	/^    IMGUI_API const char*   GetVersion();$/;"	p	namespace:ImGui	signature:()
GetVisibleRect	libs/imgui/imgui.cpp	/^static ImVec4 GetVisibleRect()$/;"	f	file:	signature:()
GetVoidPtr	libs/imgui/imgui.cpp	/^void* ImGuiStorage::GetVoidPtr(ImGuiID key) const$/;"	f	class:ImGuiStorage	signature:(ImGuiID key) const
GetVoidPtr	libs/imgui/imgui.h	/^    IMGUI_API void*   GetVoidPtr(ImGuiID key) const; \/\/ default_val is NULL$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key) const
GetVoidPtrRef	libs/imgui/imgui.cpp	/^void** ImGuiStorage::GetVoidPtrRef(ImGuiID key, void* default_val)$/;"	f	class:ImGuiStorage	signature:(ImGuiID key, void* default_val)
GetVoidPtrRef	libs/imgui/imgui.h	/^    IMGUI_API void**  GetVoidPtrRef(ImGuiID key, void* default_val = NULL);$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, void* default_val = NULL)
GetWidth	libs/imgui/imgui.cpp	/^    float       GetWidth() const                    { return Max.x-Min.x; }$/;"	f	struct:ImRect	access:public	signature:() const
GetWindowCollapsed	libs/imgui/imgui.h	/^    static inline bool      GetWindowCollapsed() { return ImGui::IsWindowCollapsed(); }        \/\/ OBSOLETE 1.39+$/;"	f	namespace:ImGui	signature:()
GetWindowContentRegionMax	libs/imgui/imgui.cpp	/^ImVec2 ImGui::GetWindowContentRegionMax()$/;"	f	class:ImGui	signature:()
GetWindowContentRegionMax	libs/imgui/imgui.h	/^    IMGUI_API ImVec2        GetWindowContentRegionMax();$/;"	p	namespace:ImGui	signature:()
GetWindowContentRegionMin	libs/imgui/imgui.cpp	/^ImVec2 ImGui::GetWindowContentRegionMin()$/;"	f	class:ImGui	signature:()
GetWindowContentRegionMin	libs/imgui/imgui.h	/^    IMGUI_API ImVec2        GetWindowContentRegionMin();                                        \/\/ window boundaries, in windows coordinates$/;"	p	namespace:ImGui	signature:()
GetWindowDrawList	libs/imgui/imgui.cpp	/^ImDrawList* ImGui::GetWindowDrawList()$/;"	f	class:ImGui	signature:()
GetWindowDrawList	libs/imgui/imgui.h	/^    IMGUI_API ImDrawList*   GetWindowDrawList();                                                \/\/ get rendering command-list if you want to append your own draw primitives$/;"	p	namespace:ImGui	signature:()
GetWindowFont	libs/imgui/imgui.cpp	/^ImFont* ImGui::GetWindowFont()$/;"	f	class:ImGui	signature:()
GetWindowFont	libs/imgui/imgui.h	/^    IMGUI_API ImFont*       GetWindowFont();$/;"	p	namespace:ImGui	signature:()
GetWindowFontSize	libs/imgui/imgui.cpp	/^float ImGui::GetWindowFontSize()$/;"	f	class:ImGui	signature:()
GetWindowFontSize	libs/imgui/imgui.h	/^    IMGUI_API float         GetWindowFontSize();                                                \/\/ size (also height in pixels) of current font with current scale applied$/;"	p	namespace:ImGui	signature:()
GetWindowIsFocused	libs/imgui/imgui.h	/^    static inline bool      GetWindowIsFocused() { return ImGui::IsWindowFocused(); }          \/\/ OBSOLETE 1.36+$/;"	f	namespace:ImGui	signature:()
GetWindowPos	libs/imgui/imgui.cpp	/^ImVec2 ImGui::GetWindowPos()$/;"	f	class:ImGui	signature:()
GetWindowPos	libs/imgui/imgui.h	/^    IMGUI_API ImVec2        GetWindowPos();                                                     \/\/ get current window position in screen space (useful if you want to do your own drawing via the DrawList api)$/;"	p	namespace:ImGui	signature:()
GetWindowSize	libs/imgui/imgui.cpp	/^ImVec2 ImGui::GetWindowSize()$/;"	f	class:ImGui	signature:()
GetWindowSize	libs/imgui/imgui.h	/^    IMGUI_API ImVec2        GetWindowSize();                                                    \/\/ get current window size$/;"	p	namespace:ImGui	signature:()
GetWindowWidth	libs/imgui/imgui.cpp	/^float ImGui::GetWindowWidth()$/;"	f	class:ImGui	signature:()
GetWindowWidth	libs/imgui/imgui.h	/^    IMGUI_API float         GetWindowWidth();$/;"	p	namespace:ImGui	signature:()
Glyph	libs/imgui/imgui.h	/^    struct Glyph$/;"	s	struct:ImFont	access:public
GlyphExtraSpacing	libs/imgui/imgui.h	/^    ImVec2          GlyphExtraSpacing;          \/\/ 0, 0     \/\/ Extra spacing (in pixels) between glyphs$/;"	m	struct:ImFontConfig	access:public
GlyphRanges	libs/imgui/imgui.h	/^    const ImWchar*  GlyphRanges;                \/\/          \/\/ List of Unicode range (2 value per range, values are inclusive, zero-terminated list)$/;"	m	struct:ImFontConfig	access:public
Glyphs	libs/imgui/imgui.h	/^    ImVector<Glyph>             Glyphs;$/;"	m	struct:ImFont	access:public
GrabMinSize	libs/imgui/imgui.h	/^    float       GrabMinSize;                \/\/ Minimum width\/height of a grab box for slider\/scrollbar$/;"	m	struct:ImGuiStyle	access:public
GrabRounding	libs/imgui/imgui.h	/^    float       GrabRounding;               \/\/ Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.$/;"	m	struct:ImGuiStyle	access:public
GroupStack	libs/imgui/imgui.cpp	/^    ImVector<ImGuiGroupData>GroupStack;$/;"	m	struct:ImGuiDrawContext	file:	access:public
HEADERS	GaffMaker/Makefile	/^HEADERS = $(shell find $(HEADER_PATH) -name '*.$(HEADER_EXT)' -printf '%T@\\t%p\\n' \\$/;"	m
HEADERS	Makefile	/^HEADERS = $(shell find $(HEADER_PATH) -name '*.$(HEADER_EXT)' -printf '%T@\\t%p\\n' \\$/;"	m
HEADER_EXT	GaffMaker/Makefile	/^HEADER_EXT = h$/;"	m
HEADER_EXT	Makefile	/^HEADER_EXT = h$/;"	m
HEADER_PATH	GaffMaker/Makefile	/^HEADER_PATH = .\/include$/;"	m
HEADER_PATH	Makefile	/^HEADER_PATH = .\/include$/;"	m
HEIGHT	include/Window.h	/^const int HEIGHT = (WIDTH \/ 4 * 3);$/;"	v
HSV	libs/imgui/imgui.h	/^    static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }$/;"	f	struct:ImColor	access:public	signature:(float h, float s, float v, float a = 1.0f)
HasSelection	libs/imgui/imgui.cpp	/^    bool                HasSelection() const            { return StbState.select_start != StbState.select_end; }$/;"	f	struct:ImGuiTextEditState	access:public	signature:() const
HasSelection	libs/imgui/imgui.h	/^    bool HasSelection() const { return SelectionStart != SelectionEnd; }$/;"	f	struct:ImGuiTextEditCallbackData	access:public	signature:() const
HiddenFrames	libs/imgui/imgui.cpp	/^    int                     HiddenFrames;$/;"	m	struct:ImGuiWindow	file:	access:public
History	libs/imgui/imgui.cpp	/^    ImVector<char*>       History;$/;"	m	struct:ExampleAppConsole	file:	access:public
History	src/util/Console.cpp	/^	ImVector<char*>       History;$/;"	m	struct:Console::Console	file:	access:public
HistoryPos	libs/imgui/imgui.cpp	/^    int                   HistoryPos;    \/\/ -1: new line, 0..History.Size-1 browsing history.$/;"	m	struct:ExampleAppConsole	file:	access:public
HistoryPos	src/util/Console.cpp	/^	int                   HistoryPos;    \/\/ -1: new line, 0..History.Size-1 browsing history.$/;"	m	struct:Console::Console	file:	access:public
HoveredId	libs/imgui/imgui.cpp	/^    ImGuiID                 HoveredId;                          \/\/ Hovered widget$/;"	m	struct:ImGuiState	file:	access:public
HoveredIdPreviousFrame	libs/imgui/imgui.cpp	/^    ImGuiID                 HoveredIdPreviousFrame;$/;"	m	struct:ImGuiState	file:	access:public
HoveredRootWindow	libs/imgui/imgui.cpp	/^    ImGuiWindow*            HoveredRootWindow;                  \/\/ Will catch mouse inputs (for focus\/move only)$/;"	m	struct:ImGuiState	file:	access:public
HoveredWindow	libs/imgui/imgui.cpp	/^    ImGuiWindow*            HoveredWindow;                      \/\/ Will catch mouse inputs$/;"	m	struct:ImGuiState	file:	access:public
ID	libs/imgui/imgui.cpp	/^    ImGuiID                 ID;$/;"	m	struct:ImGuiWindow	file:	access:public
ID	libs/imgui/imgui.cpp	/^    ImGuiID ID;$/;"	m	struct:ImGuiIniData	file:	access:public
IDENTITY	include/Window.h	/^const mat4 IDENTITY = mat4(1.0f);$/;"	v
IDStack	libs/imgui/imgui.cpp	/^    ImVector<ImGuiID>       IDStack;                            \/\/ ID stack. ID are hashes seeded with the value at the top of the stack$/;"	m	struct:ImGuiWindow	file:	access:public
IMGUI_API	libs/imgui/imgui.h	28;"	d
IMGUI_ONCE_UPON_A_FRAME	libs/imgui/imgui.h	811;"	d
IMGUI_STB_NAMESPACE	libs/imgui/imgui.cpp	/^namespace IMGUI_STB_NAMESPACE$/;"	n	file:
IMGUI_VERSION	libs/imgui/imgui.h	18;"	d
IM_ARRAYSIZE	include/util/Console.h	3;"	d
IM_ARRAYSIZE	libs/imgui/imgui.cpp	755;"	d	file:
IM_ASSERT	libs/imgui/imgui.h	23;"	d
IM_INT_MAX	libs/imgui/imgui.cpp	761;"	d	file:
IM_INT_MAX	libs/imgui/imgui.cpp	764;"	d	file:
IM_INT_MIN	libs/imgui/imgui.cpp	760;"	d	file:
IM_INT_MIN	libs/imgui/imgui.cpp	763;"	d	file:
IM_NEWLINE	libs/imgui/imgui.cpp	769;"	d	file:
IM_NEWLINE	libs/imgui/imgui.cpp	771;"	d	file:
IM_PI	libs/imgui/imgui.cpp	/^const float IM_PI = 3.14159265358979323846f;$/;"	v
INCLUDES	GaffMaker/Makefile	/^INCLUDES = -I $(HEADER_PATH)$/;"	m
INCLUDES	Makefile	/^INCLUDES = -I $(HEADER_PATH) -I libs\/imgui$/;"	m
INCLUDE_STB_TEXTEDIT_H	libs/imgui/stb_textedit.h	251;"	d
INFO	include/util/Log.h	/^const int INFO = 0x02;$/;"	v
INPUT_H	include/Input.h	2;"	d
IO	include/io/Reader.h	/^namespace IO {$/;"	n
IO	libs/imgui/imgui.cpp	/^    ImGuiIO                 IO;$/;"	m	struct:ImGuiState	file:	access:public
IO	src/io/Reader.cpp	/^namespace IO {$/;"	n	file:
IO::Reader	include/io/Reader.h	/^    namespace Reader {$/;"	n	namespace:IO
IO::Reader	src/io/Reader.cpp	/^    namespace Reader {$/;"	n	namespace:IO	file:
IO::Reader::files	src/io/Reader.cpp	/^	static Gaff::fileInfo files[256];$/;"	m	namespace:IO::Reader	file:
IO::Reader::freeReader	include/io/Reader.h	/^	void freeReader();$/;"	p	namespace:IO::Reader	signature:()
IO::Reader::freeReader	src/io/Reader.cpp	/^	void freeReader() {$/;"	f	namespace:IO::Reader	signature:()
IO::Reader::getId	include/io/Reader.h	/^	uint getId(std::string);$/;"	p	namespace:IO::Reader	signature:(std::string)
IO::Reader::getId	src/io/Reader.cpp	/^	uint getId(string name) {$/;"	f	namespace:IO::Reader	signature:(string name)
IO::Reader::getImageSize	include/io/Reader.h	/^	vec2 getImageSize(int id);$/;"	p	namespace:IO::Reader	signature:(int id)
IO::Reader::getImageSize	src/io/Reader.cpp	/^	vec2 getImageSize(int id) {$/;"	f	namespace:IO::Reader	signature:(int id)
IO::Reader::getName	include/io/Reader.h	/^	std::string getName(uint id);$/;"	p	namespace:IO::Reader	signature:(uint id)
IO::Reader::getName	src/io/Reader.cpp	/^	string getName(uint id) {$/;"	f	namespace:IO::Reader	signature:(uint id)
IO::Reader::getWithType	include/io/Reader.h	/^	void getWithType(byte type, uint *idList);$/;"	p	namespace:IO::Reader	signature:(byte type, uint *idList)
IO::Reader::getWithType	src/io/Reader.cpp	/^	void getWithType(byte type, uint *idList) {$/;"	f	namespace:IO::Reader	signature:(byte type, uint *idList)
IO::Reader::load	include/io/Reader.h	/^	void load(std::string*);$/;"	p	namespace:IO::Reader	signature:(std::string*)
IO::Reader::load	src/io/Reader.cpp	/^	void load(string fileName[]) {$/;"	f	namespace:IO::Reader	signature:(string fileName[])
IO::Reader::loadFile	src/io/Reader.cpp	/^	static void loadFile(std::string fileName);$/;"	p	namespace:IO::Reader	file:	signature:(std::string fileName)
IO::Reader::loadFile	src/io/Reader.cpp	/^	void loadFile(std::string fileName) {$/;"	f	namespace:IO::Reader	signature:(std::string fileName)
IO::Reader::rG	src/io/Reader.cpp	/^	uint rG = 0;$/;"	m	namespace:IO::Reader	file:
IO::Reader::read	include/io/Reader.h	/^	void read(int id, byte*);$/;"	p	namespace:IO::Reader	signature:(int id, byte*)
IO::Reader::read	src/io/Reader.cpp	/^	void read(int id, byte data[]) {$/;"	f	namespace:IO::Reader	signature:(int id, byte data[])
Id	libs/imgui/imgui.cpp	/^    ImGuiID             Id;                             \/\/ widget id owning the text state$/;"	m	struct:ImGuiTextEditState	file:	access:public
IdxBuffer	libs/imgui/imgui.h	/^    ImVector<ImDrawIdx>     IdxBuffer;          \/\/ Index buffer. Each command consume ImDrawCmd::ElemCount of those$/;"	m	struct:ImDrawList	access:public
IdxBuffer	libs/imgui/imgui.h	/^    ImVector<ImDrawIdx>     IdxBuffer;$/;"	m	struct:ImDrawChannel	access:public
ImCharIsSpace	libs/imgui/imgui.cpp	/^static inline bool  ImCharIsSpace(int c) { return c == ' ' || c == '\\t' || c == 0x3000; }$/;"	f	file:	signature:(int c)
ImClamp	libs/imgui/imgui.cpp	/^static inline ImVec2 ImClamp(const ImVec2& f, const ImVec2& mn, ImVec2 mx)      { return ImVec2(ImClamp(f.x,mn.x,mx.x), ImClamp(f.y,mn.y,mx.y)); }$/;"	f	file:	signature:(const ImVec2& f, const ImVec2& mn, ImVec2 mx)
ImClamp	libs/imgui/imgui.cpp	/^static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }$/;"	f	file:	signature:(float v, float mn, float mx)
ImClamp	libs/imgui/imgui.cpp	/^static inline int    ImClamp(int v, int mn, int mx)                             { return (v < mn) ? mn : (v > mx) ? mx : v; }$/;"	f	file:	signature:(int v, int mn, int mx)
ImColor	libs/imgui/imgui.h	/^    ImColor(const ImVec4& col)                                      { Value = col; }$/;"	f	struct:ImColor	access:public	signature:(const ImVec4& col)
ImColor	libs/imgui/imgui.h	/^    ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }$/;"	f	struct:ImColor	access:public	signature:(float r, float g, float b, float a = 1.0f)
ImColor	libs/imgui/imgui.h	/^    ImColor(int r, int g, int b, int a = 255)                       { Value.x = (float)r \/ 255.0f; Value.y = (float)g \/ 255.0f; Value.z = (float)b \/ 255.0f; Value.w = (float)a \/ 255.0f; }$/;"	f	struct:ImColor	access:public	signature:(int r, int g, int b, int a = 255)
ImColor	libs/imgui/imgui.h	/^struct ImColor$/;"	s
ImColor::HSV	libs/imgui/imgui.h	/^    static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }$/;"	f	struct:ImColor	access:public	signature:(float h, float s, float v, float a = 1.0f)
ImColor::ImColor	libs/imgui/imgui.h	/^    ImColor(const ImVec4& col)                                      { Value = col; }$/;"	f	struct:ImColor	access:public	signature:(const ImVec4& col)
ImColor::ImColor	libs/imgui/imgui.h	/^    ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }$/;"	f	struct:ImColor	access:public	signature:(float r, float g, float b, float a = 1.0f)
ImColor::ImColor	libs/imgui/imgui.h	/^    ImColor(int r, int g, int b, int a = 255)                       { Value.x = (float)r \/ 255.0f; Value.y = (float)g \/ 255.0f; Value.z = (float)b \/ 255.0f; Value.w = (float)a \/ 255.0f; }$/;"	f	struct:ImColor	access:public	signature:(int r, int g, int b, int a = 255)
ImColor::Value	libs/imgui/imgui.h	/^    ImVec4              Value;$/;"	m	struct:ImColor	access:public
ImColor::operator ImU32	libs/imgui/imgui.h	/^    operator ImU32() const                                          { return ImGui::ColorConvertFloat4ToU32(Value); }$/;"	f	struct:ImColor	access:public	signature:() const
ImColor::operator ImVec4	libs/imgui/imgui.h	/^    operator ImVec4() const                                         { return Value; }$/;"	f	struct:ImColor	access:public	signature:() const
ImDrawCallback	libs/imgui/imgui.h	/^typedef void (*ImDrawCallback)(const ImDrawList* parent_list, const ImDrawCmd* cmd);$/;"	t
ImDrawChannel	libs/imgui/imgui.h	/^struct ImDrawChannel$/;"	s
ImDrawChannel::CmdBuffer	libs/imgui/imgui.h	/^    ImVector<ImDrawCmd>     CmdBuffer;$/;"	m	struct:ImDrawChannel	access:public
ImDrawChannel::IdxBuffer	libs/imgui/imgui.h	/^    ImVector<ImDrawIdx>     IdxBuffer;$/;"	m	struct:ImDrawChannel	access:public
ImDrawCmd	libs/imgui/imgui.h	/^struct ImDrawCmd$/;"	s
ImDrawCmd::ClipRect	libs/imgui/imgui.h	/^    ImVec4          ClipRect;               \/\/ Clipping rectangle (x1, y1, x2, y2)$/;"	m	struct:ImDrawCmd	access:public
ImDrawCmd::ElemCount	libs/imgui/imgui.h	/^    unsigned int    ElemCount;              \/\/ Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].$/;"	m	struct:ImDrawCmd	access:public
ImDrawCmd::TextureId	libs/imgui/imgui.h	/^    ImTextureID     TextureId;              \/\/ User-provided texture ID. Set by user in ImfontAtlas::SetTexID() for fonts or passed to Image*() functions. Ignore if never using images or multiple fonts atlas.$/;"	m	struct:ImDrawCmd	access:public
ImDrawCmd::UserCallback	libs/imgui/imgui.h	/^    ImDrawCallback  UserCallback;           \/\/ If != NULL, call the function instead of rendering the vertices. clip_rect and texture_id will be set normally.$/;"	m	struct:ImDrawCmd	access:public
ImDrawCmd::UserCallbackData	libs/imgui/imgui.h	/^    void*           UserCallbackData;       \/\/ The draw callback code can access this.$/;"	m	struct:ImDrawCmd	access:public
ImDrawData	libs/imgui/imgui.h	/^struct ImDrawData$/;"	s
ImDrawData::CmdLists	libs/imgui/imgui.h	/^    ImDrawList**    CmdLists;$/;"	m	struct:ImDrawData	access:public
ImDrawData::CmdListsCount	libs/imgui/imgui.h	/^    int             CmdListsCount;$/;"	m	struct:ImDrawData	access:public
ImDrawData::DeIndexAllBuffers	libs/imgui/imgui.cpp	/^void ImDrawData::DeIndexAllBuffers()$/;"	f	class:ImDrawData	signature:()
ImDrawData::DeIndexAllBuffers	libs/imgui/imgui.h	/^    void DeIndexAllBuffers();               \/\/ For backward compatibility: convert all buffers from indexed to de-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!$/;"	p	struct:ImDrawData	access:public	signature:()
ImDrawData::TotalIdxCount	libs/imgui/imgui.h	/^    int             TotalIdxCount;          \/\/ For convenience, sum of all cmd_lists idx_buffer.Size$/;"	m	struct:ImDrawData	access:public
ImDrawData::TotalVtxCount	libs/imgui/imgui.h	/^    int             TotalVtxCount;          \/\/ For convenience, sum of all cmd_lists vtx_buffer.Size$/;"	m	struct:ImDrawData	access:public
ImDrawIdx	libs/imgui/imgui.h	/^typedef unsigned short ImDrawIdx;$/;"	t
ImDrawList	libs/imgui/imgui.h	/^    ImDrawList() { _OwnerName = NULL; Clear(); }$/;"	f	struct:ImDrawList	access:public	signature:()
ImDrawList	libs/imgui/imgui.h	/^struct ImDrawList$/;"	s
ImDrawList::AddCallback	libs/imgui/imgui.cpp	/^void ImDrawList::AddCallback(ImDrawCallback callback, void* callback_data)$/;"	f	class:ImDrawList	signature:(ImDrawCallback callback, void* callback_data)
ImDrawList::AddCallback	libs/imgui/imgui.h	/^    IMGUI_API void  AddCallback(ImDrawCallback callback, void* callback_data);  \/\/ Your rendering function must check for 'UserCallback' in ImDrawCmd and call the function instead of rendering triangles.$/;"	p	struct:ImDrawList	access:public	signature:(ImDrawCallback callback, void* callback_data)
ImDrawList::AddCircle	libs/imgui/imgui.cpp	/^void ImDrawList::AddCircle(const ImVec2& centre, float radius, ImU32 col, int num_segments)$/;"	f	class:ImDrawList	signature:(const ImVec2& centre, float radius, ImU32 col, int num_segments)
ImDrawList::AddCircle	libs/imgui/imgui.h	/^    IMGUI_API void  AddCircle(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12)
ImDrawList::AddCircleFilled	libs/imgui/imgui.cpp	/^void ImDrawList::AddCircleFilled(const ImVec2& centre, float radius, ImU32 col, int num_segments)$/;"	f	class:ImDrawList	signature:(const ImVec2& centre, float radius, ImU32 col, int num_segments)
ImDrawList::AddCircleFilled	libs/imgui/imgui.h	/^    IMGUI_API void  AddCircleFilled(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12)
ImDrawList::AddConvexPolyFilled	libs/imgui/imgui.cpp	/^void ImDrawList::AddConvexPolyFilled(const ImVec2* points, const int points_count, ImU32 col, bool anti_aliased)$/;"	f	class:ImDrawList	signature:(const ImVec2* points, const int points_count, ImU32 col, bool anti_aliased)
ImDrawList::AddConvexPolyFilled	libs/imgui/imgui.h	/^    IMGUI_API void  AddConvexPolyFilled(const ImVec2* points, const int num_points, ImU32 col, bool anti_aliased);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2* points, const int num_points, ImU32 col, bool anti_aliased)
ImDrawList::AddDrawCmd	libs/imgui/imgui.cpp	/^void ImDrawList::AddDrawCmd()$/;"	f	class:ImDrawList	signature:()
ImDrawList::AddDrawCmd	libs/imgui/imgui.h	/^    IMGUI_API void  AddDrawCmd();                                               \/\/ This is useful if you need to forcefully create a new draw call (to allow for dependent rendering \/ blending). Otherwise primitives are merged into the same draw-call as much as possible$/;"	p	struct:ImDrawList	access:public	signature:()
ImDrawList::AddImage	libs/imgui/imgui.cpp	/^void ImDrawList::AddImage(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv0, const ImVec2& uv1, ImU32 col)$/;"	f	class:ImDrawList	signature:(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv0, const ImVec2& uv1, ImU32 col)
ImDrawList::AddImage	libs/imgui/imgui.h	/^    IMGUI_API void  AddImage(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv0, const ImVec2& uv1, ImU32 col = 0xFFFFFFFF);$/;"	p	struct:ImDrawList	access:public	signature:(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv0, const ImVec2& uv1, ImU32 col = 0xFFFFFFFF)
ImDrawList::AddLine	libs/imgui/imgui.cpp	/^void ImDrawList::AddLine(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness)
ImDrawList::AddLine	libs/imgui/imgui.h	/^    IMGUI_API void  AddLine(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness = 1.0f);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness = 1.0f)
ImDrawList::AddPolyline	libs/imgui/imgui.cpp	/^void ImDrawList::AddPolyline(const ImVec2* points, const int points_count, ImU32 col, bool closed, float thickness, bool anti_aliased)$/;"	f	class:ImDrawList	signature:(const ImVec2* points, const int points_count, ImU32 col, bool closed, float thickness, bool anti_aliased)
ImDrawList::AddPolyline	libs/imgui/imgui.h	/^    IMGUI_API void  AddPolyline(const ImVec2* points, const int num_points, ImU32 col, bool closed, float thickness, bool anti_aliased);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2* points, const int num_points, ImU32 col, bool closed, float thickness, bool anti_aliased)
ImDrawList::AddRect	libs/imgui/imgui.cpp	/^void ImDrawList::AddRect(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding, int rounding_corners)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding, int rounding_corners)
ImDrawList::AddRect	libs/imgui/imgui.h	/^    IMGUI_API void  AddRect(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners = 0x0F);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners = 0x0F)
ImDrawList::AddRectFilled	libs/imgui/imgui.cpp	/^void ImDrawList::AddRectFilled(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding, int rounding_corners)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding, int rounding_corners)
ImDrawList::AddRectFilled	libs/imgui/imgui.h	/^    IMGUI_API void  AddRectFilled(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners = 0x0F);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners = 0x0F)
ImDrawList::AddRectFilledMultiColor	libs/imgui/imgui.cpp	/^void ImDrawList::AddRectFilledMultiColor(const ImVec2& a, const ImVec2& c, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& c, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left)
ImDrawList::AddRectFilledMultiColor	libs/imgui/imgui.h	/^    IMGUI_API void  AddRectFilledMultiColor(const ImVec2& a, const ImVec2& b, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left)
ImDrawList::AddText	libs/imgui/imgui.cpp	/^void ImDrawList::AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end, float wrap_width, const ImVec4* cpu_fine_clip_rect)$/;"	f	class:ImDrawList	signature:(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end, float wrap_width, const ImVec4* cpu_fine_clip_rect)
ImDrawList::AddText	libs/imgui/imgui.cpp	/^void ImDrawList::AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end)$/;"	f	class:ImDrawList	signature:(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end)
ImDrawList::AddText	libs/imgui/imgui.h	/^    IMGUI_API void  AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL, float wrap_width = 0.0f, const ImVec4* cpu_fine_clip_rect = NULL);$/;"	p	struct:ImDrawList	access:public	signature:(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL, float wrap_width = 0.0f, const ImVec4* cpu_fine_clip_rect = NULL)
ImDrawList::AddText	libs/imgui/imgui.h	/^    IMGUI_API void  AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL)
ImDrawList::AddTriangleFilled	libs/imgui/imgui.cpp	/^void ImDrawList::AddTriangleFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col)
ImDrawList::AddTriangleFilled	libs/imgui/imgui.h	/^    IMGUI_API void  AddTriangleFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col)
ImDrawList::ChannelsMerge	libs/imgui/imgui.cpp	/^void ImDrawList::ChannelsMerge(int channel_count)$/;"	f	class:ImDrawList	signature:(int channel_count)
ImDrawList::ChannelsMerge	libs/imgui/imgui.h	/^    IMGUI_API void  ChannelsMerge(int channel_count);$/;"	p	struct:ImDrawList	access:public	signature:(int channel_count)
ImDrawList::ChannelsSetCurrent	libs/imgui/imgui.cpp	/^void ImDrawList::ChannelsSetCurrent(int idx)$/;"	f	class:ImDrawList	signature:(int idx)
ImDrawList::ChannelsSetCurrent	libs/imgui/imgui.h	/^    IMGUI_API void  ChannelsSetCurrent(int idx);$/;"	p	struct:ImDrawList	access:public	signature:(int idx)
ImDrawList::ChannelsSplit	libs/imgui/imgui.cpp	/^void ImDrawList::ChannelsSplit(int channel_count)$/;"	f	class:ImDrawList	signature:(int channel_count)
ImDrawList::ChannelsSplit	libs/imgui/imgui.h	/^    IMGUI_API void  ChannelsSplit(int channel_count);$/;"	p	struct:ImDrawList	access:public	signature:(int channel_count)
ImDrawList::Clear	libs/imgui/imgui.cpp	/^void ImDrawList::Clear()$/;"	f	class:ImDrawList	signature:()
ImDrawList::Clear	libs/imgui/imgui.h	/^    IMGUI_API void  Clear();$/;"	p	struct:ImDrawList	access:public	signature:()
ImDrawList::ClearFreeMemory	libs/imgui/imgui.cpp	/^void ImDrawList::ClearFreeMemory()$/;"	f	class:ImDrawList	signature:()
ImDrawList::ClearFreeMemory	libs/imgui/imgui.h	/^    IMGUI_API void  ClearFreeMemory();$/;"	p	struct:ImDrawList	access:public	signature:()
ImDrawList::CmdBuffer	libs/imgui/imgui.h	/^    ImVector<ImDrawCmd>     CmdBuffer;          \/\/ Commands. Typically 1 command = 1 gpu draw call.$/;"	m	struct:ImDrawList	access:public
ImDrawList::IdxBuffer	libs/imgui/imgui.h	/^    ImVector<ImDrawIdx>     IdxBuffer;          \/\/ Index buffer. Each command consume ImDrawCmd::ElemCount of those$/;"	m	struct:ImDrawList	access:public
ImDrawList::ImDrawList	libs/imgui/imgui.h	/^    ImDrawList() { _OwnerName = NULL; Clear(); }$/;"	f	struct:ImDrawList	access:public	signature:()
ImDrawList::PathArcTo	libs/imgui/imgui.cpp	/^void ImDrawList::PathArcTo(const ImVec2& centre, float radius, float amin, float amax, int num_segments)$/;"	f	class:ImDrawList	signature:(const ImVec2& centre, float radius, float amin, float amax, int num_segments)
ImDrawList::PathArcTo	libs/imgui/imgui.h	/^    IMGUI_API void  PathArcTo(const ImVec2& centre, float radius, float a_min, float a_max, int num_segments = 10);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& centre, float radius, float a_min, float a_max, int num_segments = 10)
ImDrawList::PathArcToFast	libs/imgui/imgui.cpp	/^void ImDrawList::PathArcToFast(const ImVec2& centre, float radius, int amin, int amax)$/;"	f	class:ImDrawList	signature:(const ImVec2& centre, float radius, int amin, int amax)
ImDrawList::PathArcToFast	libs/imgui/imgui.h	/^    IMGUI_API void  PathArcToFast(const ImVec2& centre, float radius, int a_min_of_12, int a_max_of_12);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& centre, float radius, int a_min_of_12, int a_max_of_12)
ImDrawList::PathClear	libs/imgui/imgui.h	/^    inline    void  PathClear()                                                 { _Path.resize(0); }$/;"	f	struct:ImDrawList	access:public	signature:()
ImDrawList::PathFill	libs/imgui/imgui.h	/^    inline    void  PathFill(ImU32 col)                                         { AddConvexPolyFilled(_Path.Data, _Path.Size, col, true); PathClear(); }$/;"	f	struct:ImDrawList	access:public	signature:(ImU32 col)
ImDrawList::PathLineTo	libs/imgui/imgui.h	/^    inline    void  PathLineTo(const ImVec2& p)                                 { _Path.push_back(p); }$/;"	f	struct:ImDrawList	access:public	signature:(const ImVec2& p)
ImDrawList::PathRect	libs/imgui/imgui.cpp	/^void ImDrawList::PathRect(const ImVec2& a, const ImVec2& b, float rounding, int rounding_corners)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& b, float rounding, int rounding_corners)
ImDrawList::PathRect	libs/imgui/imgui.h	/^    IMGUI_API void  PathRect(const ImVec2& a, const ImVec2& b, float rounding = 0.0f, int rounding_corners = 0x0F);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, float rounding = 0.0f, int rounding_corners = 0x0F)
ImDrawList::PathStroke	libs/imgui/imgui.h	/^    inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f)  { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness, true); PathClear(); }$/;"	f	struct:ImDrawList	access:public	signature:(ImU32 col, bool closed, float thickness = 1.0f)
ImDrawList::PopClipRect	libs/imgui/imgui.cpp	/^void ImDrawList::PopClipRect()$/;"	f	class:ImDrawList	signature:()
ImDrawList::PopClipRect	libs/imgui/imgui.h	/^    IMGUI_API void  PopClipRect();$/;"	p	struct:ImDrawList	access:public	signature:()
ImDrawList::PopTextureID	libs/imgui/imgui.cpp	/^void ImDrawList::PopTextureID()$/;"	f	class:ImDrawList	signature:()
ImDrawList::PopTextureID	libs/imgui/imgui.h	/^    IMGUI_API void  PopTextureID();$/;"	p	struct:ImDrawList	access:public	signature:()
ImDrawList::PrimRect	libs/imgui/imgui.cpp	/^void ImDrawList::PrimRect(const ImVec2& a, const ImVec2& c, ImU32 col)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& c, ImU32 col)
ImDrawList::PrimRect	libs/imgui/imgui.h	/^    IMGUI_API void  PrimRect(const ImVec2& a, const ImVec2& b, ImU32 col);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, ImU32 col)
ImDrawList::PrimRectUV	libs/imgui/imgui.cpp	/^void ImDrawList::PrimRectUV(const ImVec2& a, const ImVec2& c, const ImVec2& uv_a, const ImVec2& uv_c, ImU32 col)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& c, const ImVec2& uv_a, const ImVec2& uv_c, ImU32 col)
ImDrawList::PrimRectUV	libs/imgui/imgui.h	/^    IMGUI_API void  PrimRectUV(const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col)
ImDrawList::PrimReserve	libs/imgui/imgui.cpp	/^void ImDrawList::PrimReserve(int idx_count, int vtx_count)$/;"	f	class:ImDrawList	signature:(int idx_count, int vtx_count)
ImDrawList::PrimReserve	libs/imgui/imgui.h	/^    IMGUI_API void  PrimReserve(int idx_count, int vtx_count);$/;"	p	struct:ImDrawList	access:public	signature:(int idx_count, int vtx_count)
ImDrawList::PrimVtx	libs/imgui/imgui.h	/^    inline    void  PrimVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)     { PrimWriteIdx((ImDrawIdx)_VtxCurrentIdx); PrimWriteVtx(pos, uv, col); }$/;"	f	struct:ImDrawList	access:public	signature:(const ImVec2& pos, const ImVec2& uv, ImU32 col)
ImDrawList::PrimWriteIdx	libs/imgui/imgui.h	/^    inline    void  PrimWriteIdx(ImDrawIdx idx)                                 { *_IdxWritePtr = idx; _IdxWritePtr++; }$/;"	f	struct:ImDrawList	access:public	signature:(ImDrawIdx idx)
ImDrawList::PrimWriteVtx	libs/imgui/imgui.h	/^    inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col){ _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }$/;"	f	struct:ImDrawList	access:public	signature:(const ImVec2& pos, const ImVec2& uv, ImU32 col)
ImDrawList::PushClipRect	libs/imgui/imgui.cpp	/^void ImDrawList::PushClipRect(const ImVec4& clip_rect)$/;"	f	class:ImDrawList	signature:(const ImVec4& clip_rect)
ImDrawList::PushClipRect	libs/imgui/imgui.h	/^    IMGUI_API void  PushClipRect(const ImVec4& clip_rect);          \/\/ Scissoring. The values are x1, y1, x2, y2.$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec4& clip_rect)
ImDrawList::PushClipRectFullScreen	libs/imgui/imgui.cpp	/^void ImDrawList::PushClipRectFullScreen()$/;"	f	class:ImDrawList	signature:()
ImDrawList::PushClipRectFullScreen	libs/imgui/imgui.h	/^    IMGUI_API void  PushClipRectFullScreen();$/;"	p	struct:ImDrawList	access:public	signature:()
ImDrawList::PushTextureID	libs/imgui/imgui.cpp	/^void ImDrawList::PushTextureID(const ImTextureID& texture_id)$/;"	f	class:ImDrawList	signature:(const ImTextureID& texture_id)
ImDrawList::PushTextureID	libs/imgui/imgui.h	/^    IMGUI_API void  PushTextureID(const ImTextureID& texture_id);$/;"	p	struct:ImDrawList	access:public	signature:(const ImTextureID& texture_id)
ImDrawList::UpdateClipRect	libs/imgui/imgui.cpp	/^void ImDrawList::UpdateClipRect()$/;"	f	class:ImDrawList	signature:()
ImDrawList::UpdateClipRect	libs/imgui/imgui.h	/^    IMGUI_API void  UpdateClipRect();$/;"	p	struct:ImDrawList	access:public	signature:()
ImDrawList::UpdateTextureID	libs/imgui/imgui.cpp	/^void ImDrawList::UpdateTextureID()$/;"	f	class:ImDrawList	signature:()
ImDrawList::UpdateTextureID	libs/imgui/imgui.h	/^    IMGUI_API void  UpdateTextureID();$/;"	p	struct:ImDrawList	access:public	signature:()
ImDrawList::VtxBuffer	libs/imgui/imgui.h	/^    ImVector<ImDrawVert>    VtxBuffer;          \/\/ Vertex buffer.$/;"	m	struct:ImDrawList	access:public
ImDrawList::_ChannelCurrent	libs/imgui/imgui.h	/^    int                     _ChannelCurrent;    \/\/ [Internal] current channel number (0)$/;"	m	struct:ImDrawList	access:public
ImDrawList::_Channels	libs/imgui/imgui.h	/^    ImVector<ImDrawChannel> _Channels;          \/\/ [Internal] draw channels for columns API$/;"	m	struct:ImDrawList	access:public
ImDrawList::_ClipRectStack	libs/imgui/imgui.h	/^    ImVector<ImVec4>        _ClipRectStack;     \/\/ [Internal]$/;"	m	struct:ImDrawList	access:public
ImDrawList::_IdxWritePtr	libs/imgui/imgui.h	/^    ImDrawIdx*              _IdxWritePtr;       \/\/ [Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)$/;"	m	struct:ImDrawList	access:public
ImDrawList::_OwnerName	libs/imgui/imgui.h	/^    const char*             _OwnerName;         \/\/ Pointer to owner window's name (if any) for debugging$/;"	m	struct:ImDrawList	access:public
ImDrawList::_Path	libs/imgui/imgui.h	/^    ImVector<ImVec2>        _Path;				\/\/ [Internal] current path building$/;"	m	struct:ImDrawList	access:public
ImDrawList::_TextureIdStack	libs/imgui/imgui.h	/^    ImVector<ImTextureID>   _TextureIdStack;    \/\/ [Internal] $/;"	m	struct:ImDrawList	access:public
ImDrawList::_VtxCurrentIdx	libs/imgui/imgui.h	/^    unsigned int            _VtxCurrentIdx;     \/\/ [Internal] == VtxBuffer.Size$/;"	m	struct:ImDrawList	access:public
ImDrawList::_VtxWritePtr	libs/imgui/imgui.h	/^    ImDrawVert*             _VtxWritePtr;       \/\/ [Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)$/;"	m	struct:ImDrawList	access:public
ImDrawList::~ImDrawList	libs/imgui/imgui.h	/^    ~ImDrawList() { ClearFreeMemory(); }$/;"	f	struct:ImDrawList	access:public	signature:()
ImDrawVert	libs/imgui/imgui.h	/^struct ImDrawVert$/;"	s
ImDrawVert::col	libs/imgui/imgui.h	/^    ImU32   col;$/;"	m	struct:ImDrawVert	access:public
ImDrawVert::pos	libs/imgui/imgui.h	/^    ImVec2  pos;$/;"	m	struct:ImDrawVert	access:public
ImDrawVert::uv	libs/imgui/imgui.h	/^    ImVec2  uv;$/;"	m	struct:ImDrawVert	access:public
ImFont	libs/imgui/imgui.cpp	/^ImFont::ImFont()$/;"	f	class:ImFont	signature:()
ImFont	libs/imgui/imgui.h	/^    IMGUI_API ImFont();$/;"	p	struct:ImFont	access:public	signature:()
ImFont	libs/imgui/imgui.h	/^struct ImFont$/;"	s
ImFont::Ascent	libs/imgui/imgui.h	/^    float                       Ascent, Descent;    \/\/ Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]$/;"	m	struct:ImFont	access:public
ImFont::BuildLookupTable	libs/imgui/imgui.cpp	/^void ImFont::BuildLookupTable()$/;"	f	class:ImFont	signature:()
ImFont::BuildLookupTable	libs/imgui/imgui.h	/^    IMGUI_API void              BuildLookupTable();$/;"	p	struct:ImFont	access:public	signature:()
ImFont::CalcTextSizeA	libs/imgui/imgui.cpp	/^ImVec2 ImFont::CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end, const char** remaining) const$/;"	f	class:ImFont	signature:(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end, const char** remaining) const
ImFont::CalcTextSizeA	libs/imgui/imgui.h	/^    IMGUI_API ImVec2            CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end = NULL, const char** remaining = NULL) const; \/\/ utf8$/;"	p	struct:ImFont	access:public	signature:(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end = NULL, const char** remaining = NULL) const
ImFont::CalcWordWrapPositionA	libs/imgui/imgui.cpp	/^const char* ImFont::CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const$/;"	f	class:ImFont	signature:(float scale, const char* text, const char* text_end, float wrap_width) const
ImFont::CalcWordWrapPositionA	libs/imgui/imgui.h	/^    IMGUI_API const char*       CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const;$/;"	p	struct:ImFont	access:public	signature:(float scale, const char* text, const char* text_end, float wrap_width) const
ImFont::Clear	libs/imgui/imgui.cpp	/^void    ImFont::Clear()$/;"	f	class:ImFont	signature:()
ImFont::Clear	libs/imgui/imgui.h	/^    IMGUI_API void              Clear();$/;"	p	struct:ImFont	access:public	signature:()
ImFont::ConfigData	libs/imgui/imgui.h	/^    ImFontConfig*               ConfigData;         \/\/                 \/\/ Pointer within ImFontAtlas->ConfigData$/;"	m	struct:ImFont	access:public
ImFont::ConfigDataCount	libs/imgui/imgui.h	/^    int                         ConfigDataCount;    \/\/$/;"	m	struct:ImFont	access:public
ImFont::ContainerAtlas	libs/imgui/imgui.h	/^    ImFontAtlas*                ContainerAtlas;     \/\/ What we has been loaded into$/;"	m	struct:ImFont	access:public
ImFont::Descent	libs/imgui/imgui.h	/^    float                       Ascent, Descent;    \/\/ Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]$/;"	m	struct:ImFont	access:public
ImFont::DisplayOffset	libs/imgui/imgui.h	/^    ImVec2                      DisplayOffset;      \/\/ = (0.0f,0.0f)   \/\/ Offset font rendering by xx pixels$/;"	m	struct:ImFont	access:public
ImFont::FallbackChar	libs/imgui/imgui.h	/^    ImWchar                     FallbackChar;       \/\/ = '?'           \/\/ Replacement glyph if one isn't found. Only set via SetFallbackChar()$/;"	m	struct:ImFont	access:public
ImFont::FallbackGlyph	libs/imgui/imgui.h	/^    const Glyph*                FallbackGlyph;      \/\/ == FindGlyph(FontFallbackChar)$/;"	m	struct:ImFont	access:public
ImFont::FallbackXAdvance	libs/imgui/imgui.h	/^    float                       FallbackXAdvance;   \/\/$/;"	m	struct:ImFont	access:public
ImFont::FindGlyph	libs/imgui/imgui.cpp	/^const ImFont::Glyph* ImFont::FindGlyph(unsigned short c) const$/;"	f	class:ImFont	signature:(unsigned short c) const
ImFont::FindGlyph	libs/imgui/imgui.h	/^    IMGUI_API const Glyph*      FindGlyph(unsigned short c) const;$/;"	p	struct:ImFont	access:public	signature:(unsigned short c) const
ImFont::FontSize	libs/imgui/imgui.h	/^    float                       FontSize;           \/\/ <user set>      \/\/ Height of characters, set during loading (don't change after loading)$/;"	m	struct:ImFont	access:public
ImFont::GetCharAdvance	libs/imgui/imgui.h	/^    IMGUI_API float             GetCharAdvance(unsigned short c) const  { return ((int)c < IndexXAdvance.Size) ? IndexXAdvance[(int)c] : FallbackXAdvance; }$/;"	f	struct:ImFont	access:public	signature:(unsigned short c) const
ImFont::Glyph	libs/imgui/imgui.h	/^    struct Glyph$/;"	s	struct:ImFont	access:public
ImFont::Glyph::Codepoint	libs/imgui/imgui.h	/^        ImWchar                 Codepoint;$/;"	m	struct:ImFont::Glyph	access:public
ImFont::Glyph::U0	libs/imgui/imgui.h	/^        float                   U0, V0, U1, V1;     \/\/ Texture coordinates$/;"	m	struct:ImFont::Glyph	access:public
ImFont::Glyph::U1	libs/imgui/imgui.h	/^        float                   U0, V0, U1, V1;     \/\/ Texture coordinates$/;"	m	struct:ImFont::Glyph	access:public
ImFont::Glyph::V0	libs/imgui/imgui.h	/^        float                   U0, V0, U1, V1;     \/\/ Texture coordinates$/;"	m	struct:ImFont::Glyph	access:public
ImFont::Glyph::V1	libs/imgui/imgui.h	/^        float                   U0, V0, U1, V1;     \/\/ Texture coordinates$/;"	m	struct:ImFont::Glyph	access:public
ImFont::Glyph::X0	libs/imgui/imgui.h	/^        float                   X0, Y0, X1, Y1;$/;"	m	struct:ImFont::Glyph	access:public
ImFont::Glyph::X1	libs/imgui/imgui.h	/^        float                   X0, Y0, X1, Y1;$/;"	m	struct:ImFont::Glyph	access:public
ImFont::Glyph::XAdvance	libs/imgui/imgui.h	/^        float                   XAdvance;$/;"	m	struct:ImFont::Glyph	access:public
ImFont::Glyph::Y0	libs/imgui/imgui.h	/^        float                   X0, Y0, X1, Y1;$/;"	m	struct:ImFont::Glyph	access:public
ImFont::Glyph::Y1	libs/imgui/imgui.h	/^        float                   X0, Y0, X1, Y1;$/;"	m	struct:ImFont::Glyph	access:public
ImFont::Glyphs	libs/imgui/imgui.h	/^    ImVector<Glyph>             Glyphs;$/;"	m	struct:ImFont	access:public
ImFont::ImFont	libs/imgui/imgui.cpp	/^ImFont::ImFont()$/;"	f	class:ImFont	signature:()
ImFont::ImFont	libs/imgui/imgui.h	/^    IMGUI_API ImFont();$/;"	p	struct:ImFont	access:public	signature:()
ImFont::IndexLookup	libs/imgui/imgui.h	/^    ImVector<int>               IndexLookup;        \/\/ Sparse. Index glyphs by Unicode code-point$/;"	m	struct:ImFont	access:public
ImFont::IndexXAdvance	libs/imgui/imgui.h	/^    ImVector<float>             IndexXAdvance;      \/\/ Sparse. Glyphs->XAdvance directly indexable (for CalcTextSize functions which are often bottleneck in large UI)$/;"	m	struct:ImFont	access:public
ImFont::IsLoaded	libs/imgui/imgui.h	/^    IMGUI_API bool              IsLoaded() const                        { return ContainerAtlas != NULL; }$/;"	f	struct:ImFont	access:public	signature:() const
ImFont::RenderText	libs/imgui/imgui.cpp	/^void ImFont::RenderText(float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, ImDrawList* draw_list, float wrap_width, bool cpu_fine_clip) const$/;"	f	class:ImFont	signature:(float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, ImDrawList* draw_list, float wrap_width, bool cpu_fine_clip) const
ImFont::RenderText	libs/imgui/imgui.h	/^    IMGUI_API void              RenderText(float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, ImDrawList* draw_list, float wrap_width = 0.0f, bool cpu_fine_clip = false) const;$/;"	p	struct:ImFont	access:public	signature:(float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, ImDrawList* draw_list, float wrap_width = 0.0f, bool cpu_fine_clip = false) const
ImFont::Scale	libs/imgui/imgui.h	/^    float                       Scale;              \/\/ = 1.0f          \/\/ Base font scale, multiplied by the per-window font scale which you can adjust with SetFontScale()$/;"	m	struct:ImFont	access:public
ImFont::SetFallbackChar	libs/imgui/imgui.cpp	/^void ImFont::SetFallbackChar(ImWchar c)$/;"	f	class:ImFont	signature:(ImWchar c)
ImFont::SetFallbackChar	libs/imgui/imgui.h	/^    IMGUI_API void              SetFallbackChar(ImWchar c);$/;"	p	struct:ImFont	access:public	signature:(ImWchar c)
ImFont::~ImFont	libs/imgui/imgui.cpp	/^ImFont::~ImFont()$/;"	f	class:ImFont	signature:()
ImFont::~ImFont	libs/imgui/imgui.h	/^    IMGUI_API ~ImFont();$/;"	p	struct:ImFont	access:public	signature:()
ImFontAtlas	libs/imgui/imgui.cpp	/^ImFontAtlas::ImFontAtlas()$/;"	f	class:ImFontAtlas	signature:()
ImFontAtlas	libs/imgui/imgui.h	/^    IMGUI_API ImFontAtlas();$/;"	p	struct:ImFontAtlas	access:public	signature:()
ImFontAtlas	libs/imgui/imgui.h	/^struct ImFontAtlas$/;"	s
ImFontAtlas::AddFont	libs/imgui/imgui.cpp	/^ImFont* ImFontAtlas::AddFont(const ImFontConfig* font_cfg)$/;"	f	class:ImFontAtlas	signature:(const ImFontConfig* font_cfg)
ImFontAtlas::AddFont	libs/imgui/imgui.h	/^    IMGUI_API ImFont*           AddFont(const ImFontConfig* font_cfg);$/;"	p	struct:ImFontAtlas	access:public	signature:(const ImFontConfig* font_cfg)
ImFontAtlas::AddFontDefault	libs/imgui/imgui.cpp	/^ImFont* ImFontAtlas::AddFontDefault(const ImFontConfig* font_cfg_template)$/;"	f	class:ImFontAtlas	signature:(const ImFontConfig* font_cfg_template)
ImFontAtlas::AddFontDefault	libs/imgui/imgui.h	/^    IMGUI_API ImFont*           AddFontDefault(const ImFontConfig* font_cfg = NULL);$/;"	p	struct:ImFontAtlas	access:public	signature:(const ImFontConfig* font_cfg = NULL)
ImFontAtlas::AddFontFromFileTTF	libs/imgui/imgui.cpp	/^ImFont* ImFontAtlas::AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)$/;"	f	class:ImFontAtlas	signature:(const char* filename, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
ImFontAtlas::AddFontFromFileTTF	libs/imgui/imgui.h	/^    IMGUI_API ImFont*           AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);$/;"	p	struct:ImFontAtlas	access:public	signature:(const char* filename, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL)
ImFontAtlas::AddFontFromMemoryCompressedBase85TTF	libs/imgui/imgui.cpp	/^ImFont* ImFontAtlas::AddFontFromMemoryCompressedBase85TTF(const char* compressed_ttf_data_base85, float size_pixels, const ImFontConfig* font_cfg, const ImWchar* glyph_ranges)$/;"	f	class:ImFontAtlas	signature:(const char* compressed_ttf_data_base85, float size_pixels, const ImFontConfig* font_cfg, const ImWchar* glyph_ranges)
ImFontAtlas::AddFontFromMemoryCompressedBase85TTF	libs/imgui/imgui.h	/^    IMGUI_API ImFont*           AddFontFromMemoryCompressedBase85TTF(const char* compressed_ttf_data_base85, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);              \/\/ 'compressed_ttf_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 paramaeter$/;"	p	struct:ImFontAtlas	access:public	signature:(const char* compressed_ttf_data_base85, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL)
ImFontAtlas::AddFontFromMemoryCompressedTTF	libs/imgui/imgui.cpp	/^ImFont* ImFontAtlas::AddFontFromMemoryCompressedTTF(const void* compressed_ttf_data, int compressed_ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)$/;"	f	class:ImFontAtlas	signature:(const void* compressed_ttf_data, int compressed_ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
ImFontAtlas::AddFontFromMemoryCompressedTTF	libs/imgui/imgui.h	/^    IMGUI_API ImFont*           AddFontFromMemoryCompressedTTF(const void* compressed_ttf_data, int compressed_ttf_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);  \/\/ 'compressed_ttf_data' still owned by caller. Compress with binary_to_compressed_c.cpp$/;"	p	struct:ImFontAtlas	access:public	signature:(const void* compressed_ttf_data, int compressed_ttf_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL)
ImFontAtlas::AddFontFromMemoryTTF	libs/imgui/imgui.cpp	/^ImFont* ImFontAtlas::AddFontFromMemoryTTF(void* ttf_data, int ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)$/;"	f	class:ImFontAtlas	signature:(void* ttf_data, int ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
ImFontAtlas::AddFontFromMemoryTTF	libs/imgui/imgui.h	/^    IMGUI_API ImFont*           AddFontFromMemoryTTF(void* ttf_data, int ttf_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);                                        \/\/ Transfer ownership of 'ttf_data' to ImFontAtlas, will be deleted after Build()$/;"	p	struct:ImFontAtlas	access:public	signature:(void* ttf_data, int ttf_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL)
ImFontAtlas::Build	libs/imgui/imgui.cpp	/^bool    ImFontAtlas::Build()$/;"	f	class:ImFontAtlas	signature:()
ImFontAtlas::Build	libs/imgui/imgui.h	/^    IMGUI_API bool              Build();            \/\/ Build pixels data. This is automatically for you by the GetTexData*** functions.$/;"	p	struct:ImFontAtlas	access:public	signature:()
ImFontAtlas::Clear	libs/imgui/imgui.cpp	/^void    ImFontAtlas::Clear()$/;"	f	class:ImFontAtlas	signature:()
ImFontAtlas::Clear	libs/imgui/imgui.h	/^    IMGUI_API void              Clear();                    \/\/ Clear all$/;"	p	struct:ImFontAtlas	access:public	signature:()
ImFontAtlas::ClearFonts	libs/imgui/imgui.cpp	/^void    ImFontAtlas::ClearFonts()$/;"	f	class:ImFontAtlas	signature:()
ImFontAtlas::ClearFonts	libs/imgui/imgui.h	/^    IMGUI_API void              ClearFonts();               \/\/ Clear the ImGui-side font data (glyphs storage, UV coordinates)$/;"	p	struct:ImFontAtlas	access:public	signature:()
ImFontAtlas::ClearInputData	libs/imgui/imgui.cpp	/^void    ImFontAtlas::ClearInputData()$/;"	f	class:ImFontAtlas	signature:()
ImFontAtlas::ClearInputData	libs/imgui/imgui.h	/^    IMGUI_API void              ClearInputData();           \/\/ Clear the input TTF data (inc sizes, glyph ranges)$/;"	p	struct:ImFontAtlas	access:public	signature:()
ImFontAtlas::ClearTexData	libs/imgui/imgui.cpp	/^void    ImFontAtlas::ClearTexData()$/;"	f	class:ImFontAtlas	signature:()
ImFontAtlas::ClearTexData	libs/imgui/imgui.h	/^    IMGUI_API void              ClearTexData();             \/\/ Clear the CPU-side texture data. Saves RAM once the texture has been copied to graphics memory.$/;"	p	struct:ImFontAtlas	access:public	signature:()
ImFontAtlas::ConfigData	libs/imgui/imgui.h	/^    ImVector<ImFontConfig>      ConfigData;         \/\/ Internal data$/;"	m	struct:ImFontAtlas	access:public
ImFontAtlas::Fonts	libs/imgui/imgui.h	/^    ImVector<ImFont*>           Fonts;$/;"	m	struct:ImFontAtlas	access:public
ImFontAtlas::GetGlyphRangesChinese	libs/imgui/imgui.cpp	/^const ImWchar*  ImFontAtlas::GetGlyphRangesChinese()$/;"	f	class:ImFontAtlas	signature:()
ImFontAtlas::GetGlyphRangesChinese	libs/imgui/imgui.h	/^    IMGUI_API const ImWchar*    GetGlyphRangesChinese();    \/\/ Japanese + full set of about 21000 CJK Unified Ideographs$/;"	p	struct:ImFontAtlas	access:public	signature:()
ImFontAtlas::GetGlyphRangesCyrillic	libs/imgui/imgui.cpp	/^const ImWchar*  ImFontAtlas::GetGlyphRangesCyrillic()$/;"	f	class:ImFontAtlas	signature:()
ImFontAtlas::GetGlyphRangesCyrillic	libs/imgui/imgui.h	/^    IMGUI_API const ImWchar*    GetGlyphRangesCyrillic();   \/\/ Default + about 400 Cyrillic characters$/;"	p	struct:ImFontAtlas	access:public	signature:()
ImFontAtlas::GetGlyphRangesDefault	libs/imgui/imgui.cpp	/^const ImWchar*   ImFontAtlas::GetGlyphRangesDefault()$/;"	f	class:ImFontAtlas	signature:()
ImFontAtlas::GetGlyphRangesDefault	libs/imgui/imgui.h	/^    IMGUI_API const ImWchar*    GetGlyphRangesDefault();    \/\/ Basic Latin, Extended Latin$/;"	p	struct:ImFontAtlas	access:public	signature:()
ImFontAtlas::GetGlyphRangesJapanese	libs/imgui/imgui.cpp	/^const ImWchar*  ImFontAtlas::GetGlyphRangesJapanese()$/;"	f	class:ImFontAtlas	signature:()
ImFontAtlas::GetGlyphRangesJapanese	libs/imgui/imgui.h	/^    IMGUI_API const ImWchar*    GetGlyphRangesJapanese();   \/\/ Default + Hiragana, Katakana, Half-Width, Selection of 1946 Ideographs$/;"	p	struct:ImFontAtlas	access:public	signature:()
ImFontAtlas::GetTexDataAsAlpha8	libs/imgui/imgui.cpp	/^void    ImFontAtlas::GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)$/;"	f	class:ImFontAtlas	signature:(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)
ImFontAtlas::GetTexDataAsAlpha8	libs/imgui/imgui.h	/^    IMGUI_API void              GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  \/\/ 1 byte per-pixel$/;"	p	struct:ImFontAtlas	access:public	signature:(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL)
ImFontAtlas::GetTexDataAsRGBA32	libs/imgui/imgui.cpp	/^void    ImFontAtlas::GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)$/;"	f	class:ImFontAtlas	signature:(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)
ImFontAtlas::GetTexDataAsRGBA32	libs/imgui/imgui.h	/^    IMGUI_API void              GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  \/\/ 4 bytes-per-pixel$/;"	p	struct:ImFontAtlas	access:public	signature:(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL)
ImFontAtlas::ImFontAtlas	libs/imgui/imgui.cpp	/^ImFontAtlas::ImFontAtlas()$/;"	f	class:ImFontAtlas	signature:()
ImFontAtlas::ImFontAtlas	libs/imgui/imgui.h	/^    IMGUI_API ImFontAtlas();$/;"	p	struct:ImFontAtlas	access:public	signature:()
ImFontAtlas::RenderCustomTexData	libs/imgui/imgui.cpp	/^void ImFontAtlas::RenderCustomTexData(int pass, void* p_rects)$/;"	f	class:ImFontAtlas	signature:(int pass, void* p_rects)
ImFontAtlas::RenderCustomTexData	libs/imgui/imgui.h	/^    IMGUI_API void              RenderCustomTexData(int pass, void* rects);$/;"	p	struct:ImFontAtlas	access:public	signature:(int pass, void* rects)
ImFontAtlas::SetTexID	libs/imgui/imgui.h	/^    IMGUI_API void              SetTexID(void* id)  { TexID = id; }$/;"	f	struct:ImFontAtlas	access:public	signature:(void* id)
ImFontAtlas::TexHeight	libs/imgui/imgui.h	/^    int                         TexHeight;$/;"	m	struct:ImFontAtlas	access:public
ImFontAtlas::TexID	libs/imgui/imgui.h	/^    void*                       TexID;              \/\/ User data to refer to the texture once it has been uploaded to user's graphic systems. It ia passed back to you during rendering.$/;"	m	struct:ImFontAtlas	access:public
ImFontAtlas::TexPixelsAlpha8	libs/imgui/imgui.h	/^    unsigned char*              TexPixelsAlpha8;    \/\/ 1 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight$/;"	m	struct:ImFontAtlas	access:public
ImFontAtlas::TexPixelsRGBA32	libs/imgui/imgui.h	/^    unsigned int*               TexPixelsRGBA32;    \/\/ 4 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight * 4$/;"	m	struct:ImFontAtlas	access:public
ImFontAtlas::TexUvWhitePixel	libs/imgui/imgui.h	/^    ImVec2                      TexUvWhitePixel;    \/\/ Texture coordinates to a white pixel (part of the TexExtraData block)$/;"	m	struct:ImFontAtlas	access:public
ImFontAtlas::TexWidth	libs/imgui/imgui.h	/^    int                         TexWidth;$/;"	m	struct:ImFontAtlas	access:public
ImFontAtlas::~ImFontAtlas	libs/imgui/imgui.cpp	/^ImFontAtlas::~ImFontAtlas()$/;"	f	class:ImFontAtlas	signature:()
ImFontAtlas::~ImFontAtlas	libs/imgui/imgui.h	/^    IMGUI_API ~ImFontAtlas();$/;"	p	struct:ImFontAtlas	access:public	signature:()
ImFontConfig	libs/imgui/imgui.cpp	/^ImFontConfig::ImFontConfig()$/;"	f	class:ImFontConfig	signature:()
ImFontConfig	libs/imgui/imgui.h	/^    IMGUI_API ImFontConfig();$/;"	p	struct:ImFontConfig	access:public	signature:()
ImFontConfig	libs/imgui/imgui.h	/^struct ImFontConfig$/;"	s
ImFontConfig::DstFont	libs/imgui/imgui.h	/^    ImFont*         DstFont;$/;"	m	struct:ImFontConfig	access:public
ImFontConfig::FontData	libs/imgui/imgui.h	/^    void*           FontData;                   \/\/          \/\/ TTF data$/;"	m	struct:ImFontConfig	access:public
ImFontConfig::FontDataOwnedByAtlas	libs/imgui/imgui.h	/^    bool            FontDataOwnedByAtlas;       \/\/ true     \/\/ TTF data ownership taken by the container ImFontAtlas (will delete memory itself). Set to true $/;"	m	struct:ImFontConfig	access:public
ImFontConfig::FontDataSize	libs/imgui/imgui.h	/^    int             FontDataSize;               \/\/          \/\/ TTF data size$/;"	m	struct:ImFontConfig	access:public
ImFontConfig::FontNo	libs/imgui/imgui.h	/^    int             FontNo;                     \/\/ 0        \/\/ Index of font within TTF file$/;"	m	struct:ImFontConfig	access:public
ImFontConfig::GlyphExtraSpacing	libs/imgui/imgui.h	/^    ImVec2          GlyphExtraSpacing;          \/\/ 0, 0     \/\/ Extra spacing (in pixels) between glyphs$/;"	m	struct:ImFontConfig	access:public
ImFontConfig::GlyphRanges	libs/imgui/imgui.h	/^    const ImWchar*  GlyphRanges;                \/\/          \/\/ List of Unicode range (2 value per range, values are inclusive, zero-terminated list)$/;"	m	struct:ImFontConfig	access:public
ImFontConfig::ImFontConfig	libs/imgui/imgui.cpp	/^ImFontConfig::ImFontConfig()$/;"	f	class:ImFontConfig	signature:()
ImFontConfig::ImFontConfig	libs/imgui/imgui.h	/^    IMGUI_API ImFontConfig();$/;"	p	struct:ImFontConfig	access:public	signature:()
ImFontConfig::MergeGlyphCenterV	libs/imgui/imgui.h	/^    bool            MergeGlyphCenterV;          \/\/ false    \/\/ When merging (multiple ImFontInput for one ImFont), vertically center new glyphs instead of aligning their baseline$/;"	m	struct:ImFontConfig	access:public
ImFontConfig::MergeMode	libs/imgui/imgui.h	/^    bool            MergeMode;                  \/\/ false    \/\/ Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs).$/;"	m	struct:ImFontConfig	access:public
ImFontConfig::Name	libs/imgui/imgui.h	/^    char            Name[32];                               \/\/ Name (strictly for debugging)$/;"	m	struct:ImFontConfig	access:public
ImFontConfig::OversampleH	libs/imgui/imgui.h	/^    int             OversampleH, OversampleV;   \/\/ 3, 1     \/\/ Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.$/;"	m	struct:ImFontConfig	access:public
ImFontConfig::OversampleV	libs/imgui/imgui.h	/^    int             OversampleH, OversampleV;   \/\/ 3, 1     \/\/ Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.$/;"	m	struct:ImFontConfig	access:public
ImFontConfig::PixelSnapH	libs/imgui/imgui.h	/^    bool            PixelSnapH;                 \/\/ false    \/\/ Align every character to pixel boundary (if enabled, set OversampleH\/V to 1)$/;"	m	struct:ImFontConfig	access:public
ImFontConfig::SizePixels	libs/imgui/imgui.h	/^    float           SizePixels;                 \/\/          \/\/ Size in pixels for rasterizer$/;"	m	struct:ImFontConfig	access:public
ImFormatString	libs/imgui/imgui.cpp	/^static int          ImFormatString(char* buf, int buf_size, const char* fmt, ...);$/;"	p	file:	signature:(char* buf, int buf_size, const char* fmt, ...)
ImFormatString	libs/imgui/imgui.cpp	/^static int ImFormatString(char* buf, int buf_size, const char* fmt, ...)$/;"	f	file:	signature:(char* buf, int buf_size, const char* fmt, ...)
ImFormatStringV	libs/imgui/imgui.cpp	/^static int          ImFormatStringV(char* buf, int buf_size, const char* fmt, va_list args);$/;"	p	file:	signature:(char* buf, int buf_size, const char* fmt, va_list args)
ImFormatStringV	libs/imgui/imgui.cpp	/^static int ImFormatStringV(char* buf, int buf_size, const char* fmt, va_list args)$/;"	f	file:	signature:(char* buf, int buf_size, const char* fmt, va_list args)
ImGui	libs/imgui/imgui.h	/^namespace ImGui$/;"	n
ImGui::AlignFirstTextHeightToWidgets	libs/imgui/imgui.cpp	/^void ImGui::AlignFirstTextHeightToWidgets()$/;"	f	class:ImGui	signature:()
ImGui::AlignFirstTextHeightToWidgets	libs/imgui/imgui.h	/^    IMGUI_API void          AlignFirstTextHeightToWidgets();                                    \/\/ call once if the first item on the line is a Text() item and you want to vertically lower it to match subsequent (bigger) widgets$/;"	p	namespace:ImGui	signature:()
ImGui::Begin	libs/imgui/imgui.cpp	/^bool ImGui::Begin(const char* name, bool* p_opened, ImGuiWindowFlags flags)$/;"	f	class:ImGui	signature:(const char* name, bool* p_opened, ImGuiWindowFlags flags)
ImGui::Begin	libs/imgui/imgui.cpp	/^bool ImGui::Begin(const char* name, bool* p_opened, const ImVec2& size_on_first_use, float bg_alpha, ImGuiWindowFlags flags)$/;"	f	class:ImGui	signature:(const char* name, bool* p_opened, const ImVec2& size_on_first_use, float bg_alpha, ImGuiWindowFlags flags)
ImGui::Begin	libs/imgui/imgui.h	/^    IMGUI_API bool          Begin(const char* name = "Debug", bool* p_opened = NULL, ImGuiWindowFlags flags = 0);                                           \/\/ see .cpp for details. return false when window is collapsed, so you can early out in your code. 'bool* p_opened' creates a widget on the upper-right to close the window (which sets your bool to false). $/;"	p	namespace:ImGui	signature:(const char* name = Ó, bool* p_opened = NULL, ImGuiWindowFlags flags = 0)
ImGui::Begin	libs/imgui/imgui.h	/^    IMGUI_API bool          Begin(const char* name, bool* p_opened, const ImVec2& size_on_first_use, float bg_alpha = -1.0f, ImGuiWindowFlags flags = 0);   \/\/ this is the older\/longer API. call SetNextWindowSize() instead if you want to set a window size. For regular windows, 'size_on_first_use' only applies to the first time EVER the window is created and probably not what you want! maybe obsolete this API eventually.$/;"	p	namespace:ImGui	signature:(const char* name, bool* p_opened, const ImVec2& size_on_first_use, float bg_alpha = -1.0f, ImGuiWindowFlags flags = 0)
ImGui::BeginChild	libs/imgui/imgui.cpp	/^bool ImGui::BeginChild(ImGuiID id, const ImVec2& size, bool border, ImGuiWindowFlags extra_flags)$/;"	f	class:ImGui	signature:(ImGuiID id, const ImVec2& size, bool border, ImGuiWindowFlags extra_flags)
ImGui::BeginChild	libs/imgui/imgui.cpp	/^bool ImGui::BeginChild(const char* str_id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* str_id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)
ImGui::BeginChild	libs/imgui/imgui.h	/^    IMGUI_API bool          BeginChild(ImGuiID id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags extra_flags = 0);                \/\/ "$/;"	p	namespace:ImGui	signature:(ImGuiID id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags extra_flags = 0)
ImGui::BeginChild	libs/imgui/imgui.h	/^    IMGUI_API bool          BeginChild(const char* str_id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags extra_flags = 0);        \/\/ begin a scrolling region. size==0.0f: use remaining window size, size<0.0f: use remaining window size minus abs(size). size>0.0f: fixed size. each axis can use a different mode, e.g. ImVec2(0,400).$/;"	p	namespace:ImGui	signature:(const char* str_id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags extra_flags = 0)
ImGui::BeginChildFrame	libs/imgui/imgui.cpp	/^bool ImGui::BeginChildFrame(ImGuiID id, const ImVec2& size)$/;"	f	class:ImGui	signature:(ImGuiID id, const ImVec2& size)
ImGui::BeginChildFrame	libs/imgui/imgui.h	/^    IMGUI_API bool          BeginChildFrame(ImGuiID id, const ImVec2& size);                    \/\/ helper to create a child window \/ scrolling region that looks like a normal widget frame$/;"	p	namespace:ImGui	signature:(ImGuiID id, const ImVec2& size)
ImGui::BeginGroup	libs/imgui/imgui.cpp	/^void ImGui::BeginGroup()$/;"	f	class:ImGui	signature:()
ImGui::BeginGroup	libs/imgui/imgui.h	/^    IMGUI_API void          BeginGroup();                                                       \/\/ once closing a group it is seen as a single item (so you can use IsItemHovered() on a group, SameLine() between groups, etc. $/;"	p	namespace:ImGui	signature:()
ImGui::BeginMainMenuBar	libs/imgui/imgui.cpp	/^bool ImGui::BeginMainMenuBar()$/;"	f	class:ImGui	signature:()
ImGui::BeginMainMenuBar	libs/imgui/imgui.h	/^    IMGUI_API bool          BeginMainMenuBar();                                                 \/\/ create and append to a full screen menu-bar. only call EndMainMenuBar() if this returns true!$/;"	p	namespace:ImGui	signature:()
ImGui::BeginMenu	libs/imgui/imgui.cpp	/^bool ImGui::BeginMenu(const char* label, bool enabled)$/;"	f	class:ImGui	signature:(const char* label, bool enabled)
ImGui::BeginMenu	libs/imgui/imgui.h	/^    IMGUI_API bool          BeginMenu(const char* label, bool enabled = true);                  \/\/ create a sub-menu entry. only call EndMenu() if this returns true!$/;"	p	namespace:ImGui	signature:(const char* label, bool enabled = true)
ImGui::BeginMenuBar	libs/imgui/imgui.cpp	/^bool ImGui::BeginMenuBar()$/;"	f	class:ImGui	signature:()
ImGui::BeginMenuBar	libs/imgui/imgui.h	/^    IMGUI_API bool          BeginMenuBar();                                                     \/\/ append to menu-bar of current window (requires ImGuiWindowFlags_MenuBar flag set). only call EndMenuBar() if this returns true!$/;"	p	namespace:ImGui	signature:()
ImGui::BeginPopup	libs/imgui/imgui.cpp	/^bool ImGui::BeginPopup(const char* str_id)$/;"	f	class:ImGui	signature:(const char* str_id)
ImGui::BeginPopup	libs/imgui/imgui.h	/^    IMGUI_API bool          BeginPopup(const char* str_id);                                     \/\/ return true if popup if opened and start outputting to it. only call EndPopup() if BeginPopup() returned true!$/;"	p	namespace:ImGui	signature:(const char* str_id)
ImGui::BeginPopupContextItem	libs/imgui/imgui.cpp	/^bool ImGui::BeginPopupContextItem(const char* str_id, int mouse_button)$/;"	f	class:ImGui	signature:(const char* str_id, int mouse_button)
ImGui::BeginPopupContextItem	libs/imgui/imgui.h	/^    IMGUI_API bool          BeginPopupContextItem(const char* str_id, int mouse_button = 1);                                        \/\/ helper to open and begin popup when clicked on last item$/;"	p	namespace:ImGui	signature:(const char* str_id, int mouse_button = 1)
ImGui::BeginPopupContextVoid	libs/imgui/imgui.cpp	/^bool ImGui::BeginPopupContextVoid(const char* str_id, int mouse_button)$/;"	f	class:ImGui	signature:(const char* str_id, int mouse_button)
ImGui::BeginPopupContextVoid	libs/imgui/imgui.h	/^    IMGUI_API bool          BeginPopupContextVoid(const char* str_id = NULL, int mouse_button = 1);                                 \/\/ helper to open and begin popup when clicked in void (no window)$/;"	p	namespace:ImGui	signature:(const char* str_id = NULL, int mouse_button = 1)
ImGui::BeginPopupContextWindow	libs/imgui/imgui.cpp	/^bool ImGui::BeginPopupContextWindow(bool also_over_items, const char* str_id, int mouse_button)$/;"	f	class:ImGui	signature:(bool also_over_items, const char* str_id, int mouse_button)
ImGui::BeginPopupContextWindow	libs/imgui/imgui.h	/^    IMGUI_API bool          BeginPopupContextWindow(bool also_over_items = true, const char* str_id = NULL, int mouse_button = 1);  \/\/ helper to open and begin popup when clicked on current window$/;"	p	namespace:ImGui	signature:(bool also_over_items = true, const char* str_id = NULL, int mouse_button = 1)
ImGui::BeginPopupModal	libs/imgui/imgui.cpp	/^bool ImGui::BeginPopupModal(const char* name, bool* p_opened, ImGuiWindowFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* name, bool* p_opened, ImGuiWindowFlags extra_flags)
ImGui::BeginPopupModal	libs/imgui/imgui.h	/^    IMGUI_API bool          BeginPopupModal(const char* name, bool* p_opened = NULL, ImGuiWindowFlags extra_flags = 0);             \/\/ modal dialog (can't close them by clicking outside)$/;"	p	namespace:ImGui	signature:(const char* name, bool* p_opened = NULL, ImGuiWindowFlags extra_flags = 0)
ImGui::BeginTooltip	libs/imgui/imgui.cpp	/^void ImGui::BeginTooltip()$/;"	f	class:ImGui	signature:()
ImGui::BeginTooltip	libs/imgui/imgui.h	/^    IMGUI_API void          BeginTooltip();                                                     \/\/ use to create full-featured tooltip windows that aren't just text$/;"	p	namespace:ImGui	signature:()
ImGui::Bullet	libs/imgui/imgui.cpp	/^void ImGui::Bullet()$/;"	f	class:ImGui	signature:()
ImGui::Bullet	libs/imgui/imgui.h	/^    IMGUI_API void          Bullet();$/;"	p	namespace:ImGui	signature:()
ImGui::BulletText	libs/imgui/imgui.cpp	/^void ImGui::BulletText(const char* fmt, ...)$/;"	f	class:ImGui	signature:(const char* fmt, ...)
ImGui::BulletText	libs/imgui/imgui.h	/^    IMGUI_API void          BulletText(const char* fmt, ...);$/;"	p	namespace:ImGui	signature:(const char* fmt, ...)
ImGui::BulletTextV	libs/imgui/imgui.cpp	/^void ImGui::BulletTextV(const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const char* fmt, va_list args)
ImGui::BulletTextV	libs/imgui/imgui.h	/^    IMGUI_API void          BulletTextV(const char* fmt, va_list args);$/;"	p	namespace:ImGui	signature:(const char* fmt, va_list args)
ImGui::Button	libs/imgui/imgui.cpp	/^bool ImGui::Button(const char* label, const ImVec2& size_arg)$/;"	f	class:ImGui	signature:(const char* label, const ImVec2& size_arg)
ImGui::Button	libs/imgui/imgui.h	/^    IMGUI_API bool          Button(const char* label, const ImVec2& size = ImVec2(0,0));$/;"	p	namespace:ImGui	signature:(const char* label, const ImVec2& size = ImVec2(0,0))
ImGui::CalcItemRectClosestPoint	libs/imgui/imgui.cpp	/^ImVec2 ImGui::CalcItemRectClosestPoint(const ImVec2& pos, bool on_edge, float outward)$/;"	f	class:ImGui	signature:(const ImVec2& pos, bool on_edge, float outward)
ImGui::CalcItemRectClosestPoint	libs/imgui/imgui.h	/^    IMGUI_API ImVec2        CalcItemRectClosestPoint(const ImVec2& pos, bool on_edge = false, float outward = +0.0f);   \/\/ utility to find the closest point the last item bounding rectangle edge. useful to visually link items$/;"	p	namespace:ImGui	signature:(const ImVec2& pos, bool on_edge = false, float outward = +0.0f)
ImGui::CalcItemWidth	libs/imgui/imgui.cpp	/^float ImGui::CalcItemWidth()$/;"	f	class:ImGui	signature:()
ImGui::CalcItemWidth	libs/imgui/imgui.h	/^    IMGUI_API float         CalcItemWidth();                                                    \/\/ width of item given pushed settings and current cursor position$/;"	p	namespace:ImGui	signature:()
ImGui::CalcListClipping	libs/imgui/imgui.cpp	/^void ImGui::CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end)$/;"	f	class:ImGui	signature:(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end)
ImGui::CalcListClipping	libs/imgui/imgui.h	/^    IMGUI_API void          CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end);    \/\/ calculate coarse clipping for large list of evenly sized items. Prefer using the ImGuiListClipper higher-level helper if you can.$/;"	p	namespace:ImGui	signature:(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end)
ImGui::CalcTextSize	libs/imgui/imgui.cpp	/^ImVec2 ImGui::CalcTextSize(const char* text, const char* text_end, bool hide_text_after_double_hash, float wrap_width)$/;"	f	class:ImGui	signature:(const char* text, const char* text_end, bool hide_text_after_double_hash, float wrap_width)
ImGui::CalcTextSize	libs/imgui/imgui.h	/^    IMGUI_API ImVec2        CalcTextSize(const char* text, const char* text_end = NULL, bool hide_text_after_double_hash = false, float wrap_width = -1.0f);$/;"	p	namespace:ImGui	signature:(const char* text, const char* text_end = NULL, bool hide_text_after_double_hash = false, float wrap_width = -1.0f)
ImGui::CaptureKeyboardFromApp	libs/imgui/imgui.cpp	/^void ImGui::CaptureKeyboardFromApp()$/;"	f	class:ImGui	signature:()
ImGui::CaptureKeyboardFromApp	libs/imgui/imgui.h	/^    IMGUI_API void          CaptureKeyboardFromApp();                                           \/\/ manually enforce imgui setting the io.WantCaptureKeyboard flag next frame (your application needs to handle it). e.g. capture keyboard when your widget is being hovered.$/;"	p	namespace:ImGui	signature:()
ImGui::CaptureMouseFromApp	libs/imgui/imgui.cpp	/^void ImGui::CaptureMouseFromApp()$/;"	f	class:ImGui	signature:()
ImGui::CaptureMouseFromApp	libs/imgui/imgui.h	/^    IMGUI_API void          CaptureMouseFromApp();                                              \/\/ manually enforce imgui setting the io.WantCaptureMouse flag next frame (your application needs to handle it).$/;"	p	namespace:ImGui	signature:()
ImGui::Checkbox	libs/imgui/imgui.cpp	/^bool ImGui::Checkbox(const char* label, bool* v)$/;"	f	class:ImGui	signature:(const char* label, bool* v)
ImGui::Checkbox	libs/imgui/imgui.h	/^    IMGUI_API bool          Checkbox(const char* label, bool* v);$/;"	p	namespace:ImGui	signature:(const char* label, bool* v)
ImGui::CheckboxFlags	libs/imgui/imgui.cpp	/^bool ImGui::CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value)$/;"	f	class:ImGui	signature:(const char* label, unsigned int* flags, unsigned int flags_value)
ImGui::CheckboxFlags	libs/imgui/imgui.h	/^    IMGUI_API bool          CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value);$/;"	p	namespace:ImGui	signature:(const char* label, unsigned int* flags, unsigned int flags_value)
ImGui::CloseCurrentPopup	libs/imgui/imgui.cpp	/^void ImGui::CloseCurrentPopup()$/;"	f	class:ImGui	signature:()
ImGui::CloseCurrentPopup	libs/imgui/imgui.h	/^    IMGUI_API void          CloseCurrentPopup();                                                \/\/ close the popup we have begin-ed into. clicking on a MenuItem or Selectable automatically close the current popup.$/;"	p	namespace:ImGui	signature:()
ImGui::CollapsingHeader	libs/imgui/imgui.cpp	/^bool ImGui::CollapsingHeader(const char* label, const char* str_id, bool display_frame, bool default_open)$/;"	f	class:ImGui	signature:(const char* label, const char* str_id, bool display_frame, bool default_open)
ImGui::CollapsingHeader	libs/imgui/imgui.h	/^    IMGUI_API bool          CollapsingHeader(const char* label, const char* str_id = NULL, bool display_frame = true, bool default_open = false);$/;"	p	namespace:ImGui	signature:(const char* label, const char* str_id = NULL, bool display_frame = true, bool default_open = false)
ImGui::Color	libs/imgui/imgui.cpp	/^void ImGui::Color(const char* prefix, const ImVec4& v)$/;"	f	class:ImGui	signature:(const char* prefix, const ImVec4& v)
ImGui::Color	libs/imgui/imgui.cpp	/^void ImGui::Color(const char* prefix, unsigned int v)$/;"	f	class:ImGui	signature:(const char* prefix, unsigned int v)
ImGui::Color	libs/imgui/imgui.h	/^    IMGUI_API void          Color(const char* prefix, const ImVec4& v);$/;"	p	namespace:ImGui	signature:(const char* prefix, const ImVec4& v)
ImGui::Color	libs/imgui/imgui.h	/^    IMGUI_API void          Color(const char* prefix, unsigned int v);$/;"	p	namespace:ImGui	signature:(const char* prefix, unsigned int v)
ImGui::ColorButton	libs/imgui/imgui.cpp	/^bool ImGui::ColorButton(const ImVec4& col, bool small_height, bool outline_border)$/;"	f	class:ImGui	signature:(const ImVec4& col, bool small_height, bool outline_border)
ImGui::ColorButton	libs/imgui/imgui.h	/^    IMGUI_API bool          ColorButton(const ImVec4& col, bool small_height = false, bool outline_border = true);$/;"	p	namespace:ImGui	signature:(const ImVec4& col, bool small_height = false, bool outline_border = true)
ImGui::ColorConvertFloat4ToU32	libs/imgui/imgui.cpp	/^ImU32 ImGui::ColorConvertFloat4ToU32(const ImVec4& in)$/;"	f	class:ImGui	signature:(const ImVec4& in)
ImGui::ColorConvertFloat4ToU32	libs/imgui/imgui.h	/^    IMGUI_API ImU32         ColorConvertFloat4ToU32(const ImVec4& in);$/;"	p	namespace:ImGui	signature:(const ImVec4& in)
ImGui::ColorConvertHSVtoRGB	libs/imgui/imgui.cpp	/^void ImGui::ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b)$/;"	f	class:ImGui	signature:(float h, float s, float v, float& out_r, float& out_g, float& out_b)
ImGui::ColorConvertHSVtoRGB	libs/imgui/imgui.h	/^    IMGUI_API void          ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b);$/;"	p	namespace:ImGui	signature:(float h, float s, float v, float& out_r, float& out_g, float& out_b)
ImGui::ColorConvertRGBtoHSV	libs/imgui/imgui.cpp	/^void ImGui::ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v)$/;"	f	class:ImGui	signature:(float r, float g, float b, float& out_h, float& out_s, float& out_v)
ImGui::ColorConvertRGBtoHSV	libs/imgui/imgui.h	/^    IMGUI_API void          ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v);$/;"	p	namespace:ImGui	signature:(float r, float g, float b, float& out_h, float& out_s, float& out_v)
ImGui::ColorEdit3	libs/imgui/imgui.cpp	/^bool ImGui::ColorEdit3(const char* label, float col[3])$/;"	f	class:ImGui	signature:(const char* label, float col[3])
ImGui::ColorEdit3	libs/imgui/imgui.h	/^    IMGUI_API bool          ColorEdit3(const char* label, float col[3]);$/;"	p	namespace:ImGui	signature:(const char* label, float col[3])
ImGui::ColorEdit4	libs/imgui/imgui.cpp	/^bool ImGui::ColorEdit4(const char* label, float col[4], bool alpha)$/;"	f	class:ImGui	signature:(const char* label, float col[4], bool alpha)
ImGui::ColorEdit4	libs/imgui/imgui.h	/^    IMGUI_API bool          ColorEdit4(const char* label, float col[4], bool show_alpha = true);$/;"	p	namespace:ImGui	signature:(const char* label, float col[4], bool show_alpha = true)
ImGui::ColorEditMode	libs/imgui/imgui.cpp	/^void ImGui::ColorEditMode(ImGuiColorEditMode mode)$/;"	f	class:ImGui	signature:(ImGuiColorEditMode mode)
ImGui::ColorEditMode	libs/imgui/imgui.h	/^    IMGUI_API void          ColorEditMode(ImGuiColorEditMode mode);$/;"	p	namespace:ImGui	signature:(ImGuiColorEditMode mode)
ImGui::Columns	libs/imgui/imgui.cpp	/^void ImGui::Columns(int columns_count, const char* id, bool border)$/;"	f	class:ImGui	signature:(int columns_count, const char* id, bool border)
ImGui::Columns	libs/imgui/imgui.h	/^    IMGUI_API void          Columns(int count = 1, const char* id = NULL, bool border=true);    \/\/ setup number of columns. use an identifier to distinguish multiple column sets. close with Columns(1).$/;"	p	namespace:ImGui	signature:(int count = 1, const char* id = NULL, bool border=true)
ImGui::Combo	libs/imgui/imgui.cpp	/^bool ImGui::Combo(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int height_in_items)$/;"	f	class:ImGui	signature:(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int height_in_items)
ImGui::Combo	libs/imgui/imgui.cpp	/^bool ImGui::Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int height_in_items)$/;"	f	class:ImGui	signature:(const char* label, int* current_item, const char* items_separated_by_zeros, int height_in_items)
ImGui::Combo	libs/imgui/imgui.cpp	/^bool ImGui::Combo(const char* label, int* current_item, const char** items, int items_count, int height_in_items)$/;"	f	class:ImGui	signature:(const char* label, int* current_item, const char** items, int items_count, int height_in_items)
ImGui::Combo	libs/imgui/imgui.h	/^    IMGUI_API bool          Combo(const char* label, int* current_item, bool (*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int height_in_items = -1);$/;"	p	namespace:ImGui	signature:(const char* label, int* current_item, bool (*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int height_in_items = -1)
ImGui::Combo	libs/imgui/imgui.h	/^    IMGUI_API bool          Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int height_in_items = -1);      \/\/ separate items with \\0, end item-list with \\0\\0$/;"	p	namespace:ImGui	signature:(const char* label, int* current_item, const char* items_separated_by_zeros, int height_in_items = -1)
ImGui::Combo	libs/imgui/imgui.h	/^    IMGUI_API bool          Combo(const char* label, int* current_item, const char** items, int items_count, int height_in_items = -1);$/;"	p	namespace:ImGui	signature:(const char* label, int* current_item, const char** items, int items_count, int height_in_items = -1)
ImGui::DragFloat	libs/imgui/imgui.cpp	/^bool ImGui::DragFloat(const char* label, float *v, float v_speed, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float *v, float v_speed, float v_min, float v_max, const char* display_format, float power)
ImGui::DragFloat	libs/imgui/imgui.h	/^    IMGUI_API bool          DragFloat(const char* label, float* v, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", float power = 1.0f);     \/\/ If v_min >= v_max we have no bound$/;"	p	namespace:ImGui	signature:(const char* label, float* v, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = Ó, float power = 1.0f)
ImGui::DragFloat2	libs/imgui/imgui.cpp	/^bool ImGui::DragFloat2(const char* label, float v[2], float v_speed, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float v[2], float v_speed, float v_min, float v_max, const char* display_format, float power)
ImGui::DragFloat2	libs/imgui/imgui.h	/^    IMGUI_API bool          DragFloat2(const char* label, float v[2], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", float power = 1.0f);$/;"	p	namespace:ImGui	signature:(const char* label, float v[2], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = Ó, float power = 1.0f)
ImGui::DragFloat3	libs/imgui/imgui.cpp	/^bool ImGui::DragFloat3(const char* label, float v[3], float v_speed, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float v[3], float v_speed, float v_min, float v_max, const char* display_format, float power)
ImGui::DragFloat3	libs/imgui/imgui.h	/^    IMGUI_API bool          DragFloat3(const char* label, float v[3], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", float power = 1.0f);$/;"	p	namespace:ImGui	signature:(const char* label, float v[3], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = Ó, float power = 1.0f)
ImGui::DragFloat4	libs/imgui/imgui.cpp	/^bool ImGui::DragFloat4(const char* label, float v[4], float v_speed, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float v[4], float v_speed, float v_min, float v_max, const char* display_format, float power)
ImGui::DragFloat4	libs/imgui/imgui.h	/^    IMGUI_API bool          DragFloat4(const char* label, float v[4], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", float power = 1.0f);$/;"	p	namespace:ImGui	signature:(const char* label, float v[4], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = Ó, float power = 1.0f)
ImGui::DragFloatRange2	libs/imgui/imgui.cpp	/^bool ImGui::DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed, float v_min, float v_max, const char* display_format, const char* display_format_max, float power)$/;"	f	class:ImGui	signature:(const char* label, float* v_current_min, float* v_current_max, float v_speed, float v_min, float v_max, const char* display_format, const char* display_format_max, float power)
ImGui::DragFloatRange2	libs/imgui/imgui.h	/^    IMGUI_API bool          DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", const char* display_format_max = NULL, float power = 1.0f);$/;"	p	namespace:ImGui	signature:(const char* label, float* v_current_min, float* v_current_max, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = Ó, const char* display_format_max = NULL, float power = 1.0f)
ImGui::DragInt	libs/imgui/imgui.cpp	/^bool ImGui::DragInt(const char* label, int* v, float v_speed, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int* v, float v_speed, int v_min, int v_max, const char* display_format)
ImGui::DragInt	libs/imgui/imgui.h	/^    IMGUI_API bool          DragInt(const char* label, int* v, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f");                                       \/\/ If v_min >= v_max we have no bound$/;"	p	namespace:ImGui	signature:(const char* label, int* v, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = Ó)
ImGui::DragInt2	libs/imgui/imgui.cpp	/^bool ImGui::DragInt2(const char* label, int v[2], float v_speed, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int v[2], float v_speed, int v_min, int v_max, const char* display_format)
ImGui::DragInt2	libs/imgui/imgui.h	/^    IMGUI_API bool          DragInt2(const char* label, int v[2], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f");$/;"	p	namespace:ImGui	signature:(const char* label, int v[2], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = Ó)
ImGui::DragInt3	libs/imgui/imgui.cpp	/^bool ImGui::DragInt3(const char* label, int v[3], float v_speed, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int v[3], float v_speed, int v_min, int v_max, const char* display_format)
ImGui::DragInt3	libs/imgui/imgui.h	/^    IMGUI_API bool          DragInt3(const char* label, int v[3], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f");$/;"	p	namespace:ImGui	signature:(const char* label, int v[3], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = Ó)
ImGui::DragInt4	libs/imgui/imgui.cpp	/^bool ImGui::DragInt4(const char* label, int v[4], float v_speed, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int v[4], float v_speed, int v_min, int v_max, const char* display_format)
ImGui::DragInt4	libs/imgui/imgui.h	/^    IMGUI_API bool          DragInt4(const char* label, int v[4], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f");$/;"	p	namespace:ImGui	signature:(const char* label, int v[4], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = Ó)
ImGui::DragIntRange2	libs/imgui/imgui.cpp	/^bool ImGui::DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed, int v_min, int v_max, const char* display_format, const char* display_format_max)$/;"	f	class:ImGui	signature:(const char* label, int* v_current_min, int* v_current_max, float v_speed, int v_min, int v_max, const char* display_format, const char* display_format_max)
ImGui::DragIntRange2	libs/imgui/imgui.h	/^    IMGUI_API bool          DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f", const char* display_format_max = NULL);$/;"	p	namespace:ImGui	signature:(const char* label, int* v_current_min, int* v_current_max, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = Ó, const char* display_format_max = NULL)
ImGui::Dummy	libs/imgui/imgui.cpp	/^void ImGui::Dummy(const ImVec2& size)$/;"	f	class:ImGui	signature:(const ImVec2& size)
ImGui::Dummy	libs/imgui/imgui.h	/^    IMGUI_API void          Dummy(const ImVec2& size);                                          \/\/ add a dummy item of given size$/;"	p	namespace:ImGui	signature:(const ImVec2& size)
ImGui::End	libs/imgui/imgui.cpp	/^void ImGui::End()$/;"	f	class:ImGui	signature:()
ImGui::End	libs/imgui/imgui.h	/^    IMGUI_API void          End();$/;"	p	namespace:ImGui	signature:()
ImGui::EndChild	libs/imgui/imgui.cpp	/^void ImGui::EndChild()$/;"	f	class:ImGui	signature:()
ImGui::EndChild	libs/imgui/imgui.h	/^    IMGUI_API void          EndChild();$/;"	p	namespace:ImGui	signature:()
ImGui::EndChildFrame	libs/imgui/imgui.cpp	/^void ImGui::EndChildFrame()$/;"	f	class:ImGui	signature:()
ImGui::EndChildFrame	libs/imgui/imgui.h	/^    IMGUI_API void          EndChildFrame();$/;"	p	namespace:ImGui	signature:()
ImGui::EndGroup	libs/imgui/imgui.cpp	/^void ImGui::EndGroup()$/;"	f	class:ImGui	signature:()
ImGui::EndGroup	libs/imgui/imgui.h	/^    IMGUI_API void          EndGroup();$/;"	p	namespace:ImGui	signature:()
ImGui::EndMainMenuBar	libs/imgui/imgui.cpp	/^void ImGui::EndMainMenuBar()$/;"	f	class:ImGui	signature:()
ImGui::EndMainMenuBar	libs/imgui/imgui.h	/^    IMGUI_API void          EndMainMenuBar();$/;"	p	namespace:ImGui	signature:()
ImGui::EndMenu	libs/imgui/imgui.cpp	/^void ImGui::EndMenu()$/;"	f	class:ImGui	signature:()
ImGui::EndMenu	libs/imgui/imgui.h	/^    IMGUI_API void          EndMenu();$/;"	p	namespace:ImGui	signature:()
ImGui::EndMenuBar	libs/imgui/imgui.cpp	/^void ImGui::EndMenuBar()$/;"	f	class:ImGui	signature:()
ImGui::EndMenuBar	libs/imgui/imgui.h	/^    IMGUI_API void          EndMenuBar();$/;"	p	namespace:ImGui	signature:()
ImGui::EndPopup	libs/imgui/imgui.cpp	/^void ImGui::EndPopup()$/;"	f	class:ImGui	signature:()
ImGui::EndPopup	libs/imgui/imgui.h	/^    IMGUI_API void          EndPopup();$/;"	p	namespace:ImGui	signature:()
ImGui::EndTooltip	libs/imgui/imgui.cpp	/^void ImGui::EndTooltip()$/;"	f	class:ImGui	signature:()
ImGui::EndTooltip	libs/imgui/imgui.h	/^    IMGUI_API void          EndTooltip();$/;"	p	namespace:ImGui	signature:()
ImGui::GetColumnIndex	libs/imgui/imgui.cpp	/^int ImGui::GetColumnIndex()$/;"	f	class:ImGui	signature:()
ImGui::GetColumnIndex	libs/imgui/imgui.h	/^    IMGUI_API int           GetColumnIndex();                                                   \/\/ get current column index$/;"	p	namespace:ImGui	signature:()
ImGui::GetColumnOffset	libs/imgui/imgui.cpp	/^float ImGui::GetColumnOffset(int column_index)$/;"	f	class:ImGui	signature:(int column_index)
ImGui::GetColumnOffset	libs/imgui/imgui.h	/^    IMGUI_API float         GetColumnOffset(int column_index = -1);                             \/\/ get position of column line (in pixels, from the left side of the contents region). pass -1 to use current column, otherwise 0..GetcolumnsCount() inclusive. column 0 is usually 0.0f and not resizable unless you call this$/;"	p	namespace:ImGui	signature:(int column_index = -1)
ImGui::GetColumnWidth	libs/imgui/imgui.cpp	/^float ImGui::GetColumnWidth(int column_index)$/;"	f	class:ImGui	signature:(int column_index)
ImGui::GetColumnWidth	libs/imgui/imgui.h	/^    IMGUI_API float         GetColumnWidth(int column_index = -1);                              \/\/ column width (== GetColumnOffset(GetColumnIndex()+1) - GetColumnOffset(GetColumnOffset())$/;"	p	namespace:ImGui	signature:(int column_index = -1)
ImGui::GetColumnsCount	libs/imgui/imgui.cpp	/^int ImGui::GetColumnsCount()$/;"	f	class:ImGui	signature:()
ImGui::GetColumnsCount	libs/imgui/imgui.h	/^    IMGUI_API int           GetColumnsCount();                                                  \/\/ number of columns (what was passed to Columns())$/;"	p	namespace:ImGui	signature:()
ImGui::GetContentRegionMax	libs/imgui/imgui.cpp	/^ImVec2 ImGui::GetContentRegionMax()$/;"	f	class:ImGui	signature:()
ImGui::GetContentRegionMax	libs/imgui/imgui.h	/^    IMGUI_API ImVec2        GetContentRegionMax();                                              \/\/ window or current column boundaries, in windows coordinates$/;"	p	namespace:ImGui	signature:()
ImGui::GetCursorPos	libs/imgui/imgui.cpp	/^ImVec2 ImGui::GetCursorPos()$/;"	f	class:ImGui	signature:()
ImGui::GetCursorPos	libs/imgui/imgui.h	/^    IMGUI_API ImVec2        GetCursorPos();                                                     \/\/ cursor position is relative to window position$/;"	p	namespace:ImGui	signature:()
ImGui::GetCursorPosX	libs/imgui/imgui.cpp	/^float ImGui::GetCursorPosX()$/;"	f	class:ImGui	signature:()
ImGui::GetCursorPosX	libs/imgui/imgui.h	/^    IMGUI_API float         GetCursorPosX();                                                    \/\/ "$/;"	p	namespace:ImGui	signature:()
ImGui::GetCursorPosY	libs/imgui/imgui.cpp	/^float ImGui::GetCursorPosY()$/;"	f	class:ImGui	signature:()
ImGui::GetCursorPosY	libs/imgui/imgui.h	/^    IMGUI_API float         GetCursorPosY();                                                    \/\/ "$/;"	p	namespace:ImGui	signature:()
ImGui::GetCursorScreenPos	libs/imgui/imgui.cpp	/^ImVec2 ImGui::GetCursorScreenPos()$/;"	f	class:ImGui	signature:()
ImGui::GetCursorScreenPos	libs/imgui/imgui.h	/^    IMGUI_API ImVec2        GetCursorScreenPos();                                               \/\/ cursor position in absolute screen coordinates [0..io.DisplaySize]$/;"	p	namespace:ImGui	signature:()
ImGui::GetCursorStartPos	libs/imgui/imgui.cpp	/^ImVec2 ImGui::GetCursorStartPos()$/;"	f	class:ImGui	signature:()
ImGui::GetCursorStartPos	libs/imgui/imgui.h	/^    IMGUI_API ImVec2        GetCursorStartPos();                                                \/\/ initial cursor position $/;"	p	namespace:ImGui	signature:()
ImGui::GetFrameCount	libs/imgui/imgui.cpp	/^int ImGui::GetFrameCount()$/;"	f	class:ImGui	signature:()
ImGui::GetFrameCount	libs/imgui/imgui.h	/^    IMGUI_API int           GetFrameCount();$/;"	p	namespace:ImGui	signature:()
ImGui::GetID	libs/imgui/imgui.cpp	/^ImGuiID ImGui::GetID(const char* str_id)$/;"	f	class:ImGui	signature:(const char* str_id)
ImGui::GetID	libs/imgui/imgui.cpp	/^ImGuiID ImGui::GetID(const char* str_id_begin, const char* str_id_end)$/;"	f	class:ImGui	signature:(const char* str_id_begin, const char* str_id_end)
ImGui::GetID	libs/imgui/imgui.cpp	/^ImGuiID ImGui::GetID(const void* ptr_id)$/;"	f	class:ImGui	signature:(const void* ptr_id)
ImGui::GetID	libs/imgui/imgui.h	/^    IMGUI_API ImGuiID       GetID(const char* str_id);                                          \/\/ calculate unique ID (hash of whole ID stack + given parameter). useful if you want to query into ImGuiStorage yourself. otherwise rarely needed$/;"	p	namespace:ImGui	signature:(const char* str_id)
ImGui::GetID	libs/imgui/imgui.h	/^    IMGUI_API ImGuiID       GetID(const char* str_id_begin, const char* str_id_end);$/;"	p	namespace:ImGui	signature:(const char* str_id_begin, const char* str_id_end)
ImGui::GetID	libs/imgui/imgui.h	/^    IMGUI_API ImGuiID       GetID(const void* ptr_id);$/;"	p	namespace:ImGui	signature:(const void* ptr_id)
ImGui::GetIO	libs/imgui/imgui.cpp	/^ImGuiIO& ImGui::GetIO()$/;"	f	class:ImGui	signature:()
ImGui::GetIO	libs/imgui/imgui.h	/^    IMGUI_API ImGuiIO&      GetIO();$/;"	p	namespace:ImGui	signature:()
ImGui::GetInternalState	libs/imgui/imgui.cpp	/^void* ImGui::GetInternalState()$/;"	f	class:ImGui	signature:()
ImGui::GetInternalState	libs/imgui/imgui.h	/^    IMGUI_API void*         GetInternalState();$/;"	p	namespace:ImGui	signature:()
ImGui::GetInternalStateSize	libs/imgui/imgui.cpp	/^size_t ImGui::GetInternalStateSize()$/;"	f	class:ImGui	signature:()
ImGui::GetInternalStateSize	libs/imgui/imgui.h	/^    IMGUI_API size_t        GetInternalStateSize();$/;"	p	namespace:ImGui	signature:()
ImGui::GetItemBoxMax	libs/imgui/imgui.h	/^    static inline ImVec2    GetItemBoxMax() { return GetItemRectMax(); }                       \/\/ OBSOLETE 1.36+$/;"	f	namespace:ImGui	signature:()
ImGui::GetItemBoxMin	libs/imgui/imgui.h	/^    static inline ImVec2    GetItemBoxMin() { return GetItemRectMin(); }                       \/\/ OBSOLETE 1.36+$/;"	f	namespace:ImGui	signature:()
ImGui::GetItemRectMax	libs/imgui/imgui.cpp	/^ImVec2 ImGui::GetItemRectMax()$/;"	f	class:ImGui	signature:()
ImGui::GetItemRectMax	libs/imgui/imgui.h	/^    IMGUI_API ImVec2        GetItemRectMax();                                                   \/\/ "$/;"	p	namespace:ImGui	signature:()
ImGui::GetItemRectMin	libs/imgui/imgui.cpp	/^ImVec2 ImGui::GetItemRectMin()$/;"	f	class:ImGui	signature:()
ImGui::GetItemRectMin	libs/imgui/imgui.h	/^    IMGUI_API ImVec2        GetItemRectMin();                                                   \/\/ get bounding rect of last item in screen space$/;"	p	namespace:ImGui	signature:()
ImGui::GetItemRectSize	libs/imgui/imgui.cpp	/^ImVec2 ImGui::GetItemRectSize()$/;"	f	class:ImGui	signature:()
ImGui::GetItemRectSize	libs/imgui/imgui.h	/^    IMGUI_API ImVec2        GetItemRectSize();                                                  \/\/ "$/;"	p	namespace:ImGui	signature:()
ImGui::GetItemsLineHeightWithSpacing	libs/imgui/imgui.cpp	/^float ImGui::GetItemsLineHeightWithSpacing()$/;"	f	class:ImGui	signature:()
ImGui::GetItemsLineHeightWithSpacing	libs/imgui/imgui.h	/^    IMGUI_API float         GetItemsLineHeightWithSpacing();                                    \/\/ distance (in pixels) between 2 consecutive lines of standard height widgets == GetWindowFontSize() + GetStyle().FramePadding.y*2 + GetStyle().ItemSpacing.y$/;"	p	namespace:ImGui	signature:()
ImGui::GetKeyIndex	libs/imgui/imgui.cpp	/^int ImGui::GetKeyIndex(ImGuiKey key)$/;"	f	class:ImGui	signature:(ImGuiKey key)
ImGui::GetKeyIndex	libs/imgui/imgui.h	/^    IMGUI_API int           GetKeyIndex(ImGuiKey key);                                          \/\/ map ImGuiKey_* values into user's key index. == io.KeyMap[key]$/;"	p	namespace:ImGui	signature:(ImGuiKey key)
ImGui::GetMouseCursor	libs/imgui/imgui.cpp	/^ImGuiMouseCursor ImGui::GetMouseCursor()$/;"	f	class:ImGui	signature:()
ImGui::GetMouseCursor	libs/imgui/imgui.h	/^    IMGUI_API ImGuiMouseCursor GetMouseCursor();                                                \/\/ get desired cursor type, reset in ImGui::NewFrame(), this updated during the frame. valid before Render(). If you use software rendering by setting io.MouseDrawCursor ImGui will render those for you$/;"	p	namespace:ImGui	signature:()
ImGui::GetMouseDragDelta	libs/imgui/imgui.cpp	/^ImVec2 ImGui::GetMouseDragDelta(int button, float lock_threshold)$/;"	f	class:ImGui	signature:(int button, float lock_threshold)
ImGui::GetMouseDragDelta	libs/imgui/imgui.h	/^    IMGUI_API ImVec2        GetMouseDragDelta(int button = 0, float lock_threshold = -1.0f);    \/\/ dragging amount since clicking, also see: GetItemActiveDragDelta(). if lock_threshold < -1.0f uses io.MouseDraggingThreshold$/;"	p	namespace:ImGui	signature:(int button = 0, float lock_threshold = -1.0f)
ImGui::GetMousePos	libs/imgui/imgui.cpp	/^ImVec2 ImGui::GetMousePos()$/;"	f	class:ImGui	signature:()
ImGui::GetMousePos	libs/imgui/imgui.h	/^    IMGUI_API ImVec2        GetMousePos();                                                      \/\/ shortcut to ImGui::GetIO().MousePos provided by user, to be consistent with other calls$/;"	p	namespace:ImGui	signature:()
ImGui::GetScrollMaxY	libs/imgui/imgui.cpp	/^float ImGui::GetScrollMaxY()$/;"	f	class:ImGui	signature:()
ImGui::GetScrollMaxY	libs/imgui/imgui.h	/^    IMGUI_API float         GetScrollMaxY();                                                    \/\/ get maximum scrolling amount == ContentSize.Y - WindowSize.Y$/;"	p	namespace:ImGui	signature:()
ImGui::GetScrollY	libs/imgui/imgui.cpp	/^float ImGui::GetScrollY()$/;"	f	class:ImGui	signature:()
ImGui::GetScrollY	libs/imgui/imgui.h	/^    IMGUI_API float         GetScrollY();                                                       \/\/ get scrolling amount [0..GetScrollMaxY()]$/;"	p	namespace:ImGui	signature:()
ImGui::GetStateStorage	libs/imgui/imgui.cpp	/^ImGuiStorage* ImGui::GetStateStorage()$/;"	f	class:ImGui	signature:()
ImGui::GetStateStorage	libs/imgui/imgui.h	/^    IMGUI_API ImGuiStorage* GetStateStorage();$/;"	p	namespace:ImGui	signature:()
ImGui::GetStyle	libs/imgui/imgui.cpp	/^ImGuiStyle& ImGui::GetStyle()$/;"	f	class:ImGui	signature:()
ImGui::GetStyle	libs/imgui/imgui.h	/^    IMGUI_API ImGuiStyle&   GetStyle();$/;"	p	namespace:ImGui	signature:()
ImGui::GetStyleColName	libs/imgui/imgui.cpp	/^const char* ImGui::GetStyleColName(ImGuiCol idx)$/;"	f	class:ImGui	signature:(ImGuiCol idx)
ImGui::GetStyleColName	libs/imgui/imgui.h	/^    IMGUI_API const char*   GetStyleColName(ImGuiCol idx);$/;"	p	namespace:ImGui	signature:(ImGuiCol idx)
ImGui::GetTextLineHeight	libs/imgui/imgui.cpp	/^float ImGui::GetTextLineHeight()$/;"	f	class:ImGui	signature:()
ImGui::GetTextLineHeight	libs/imgui/imgui.h	/^    IMGUI_API float         GetTextLineHeight();                                                \/\/ height of font == GetWindowFontSize()$/;"	p	namespace:ImGui	signature:()
ImGui::GetTextLineHeightWithSpacing	libs/imgui/imgui.cpp	/^float ImGui::GetTextLineHeightWithSpacing()$/;"	f	class:ImGui	signature:()
ImGui::GetTextLineHeightWithSpacing	libs/imgui/imgui.h	/^    IMGUI_API float         GetTextLineHeightWithSpacing();                                     \/\/ distance (in pixels) between 2 consecutive lines of text == GetWindowFontSize() + GetStyle().ItemSpacing.y$/;"	p	namespace:ImGui	signature:()
ImGui::GetTime	libs/imgui/imgui.cpp	/^float ImGui::GetTime()$/;"	f	class:ImGui	signature:()
ImGui::GetTime	libs/imgui/imgui.h	/^    IMGUI_API float         GetTime();$/;"	p	namespace:ImGui	signature:()
ImGui::GetVersion	libs/imgui/imgui.cpp	/^const char* ImGui::GetVersion()$/;"	f	class:ImGui	signature:()
ImGui::GetVersion	libs/imgui/imgui.h	/^    IMGUI_API const char*   GetVersion();$/;"	p	namespace:ImGui	signature:()
ImGui::GetWindowCollapsed	libs/imgui/imgui.h	/^    static inline bool      GetWindowCollapsed() { return ImGui::IsWindowCollapsed(); }        \/\/ OBSOLETE 1.39+$/;"	f	namespace:ImGui	signature:()
ImGui::GetWindowContentRegionMax	libs/imgui/imgui.cpp	/^ImVec2 ImGui::GetWindowContentRegionMax()$/;"	f	class:ImGui	signature:()
ImGui::GetWindowContentRegionMax	libs/imgui/imgui.h	/^    IMGUI_API ImVec2        GetWindowContentRegionMax();$/;"	p	namespace:ImGui	signature:()
ImGui::GetWindowContentRegionMin	libs/imgui/imgui.cpp	/^ImVec2 ImGui::GetWindowContentRegionMin()$/;"	f	class:ImGui	signature:()
ImGui::GetWindowContentRegionMin	libs/imgui/imgui.h	/^    IMGUI_API ImVec2        GetWindowContentRegionMin();                                        \/\/ window boundaries, in windows coordinates$/;"	p	namespace:ImGui	signature:()
ImGui::GetWindowDrawList	libs/imgui/imgui.cpp	/^ImDrawList* ImGui::GetWindowDrawList()$/;"	f	class:ImGui	signature:()
ImGui::GetWindowDrawList	libs/imgui/imgui.h	/^    IMGUI_API ImDrawList*   GetWindowDrawList();                                                \/\/ get rendering command-list if you want to append your own draw primitives$/;"	p	namespace:ImGui	signature:()
ImGui::GetWindowFont	libs/imgui/imgui.cpp	/^ImFont* ImGui::GetWindowFont()$/;"	f	class:ImGui	signature:()
ImGui::GetWindowFont	libs/imgui/imgui.h	/^    IMGUI_API ImFont*       GetWindowFont();$/;"	p	namespace:ImGui	signature:()
ImGui::GetWindowFontSize	libs/imgui/imgui.cpp	/^float ImGui::GetWindowFontSize()$/;"	f	class:ImGui	signature:()
ImGui::GetWindowFontSize	libs/imgui/imgui.h	/^    IMGUI_API float         GetWindowFontSize();                                                \/\/ size (also height in pixels) of current font with current scale applied$/;"	p	namespace:ImGui	signature:()
ImGui::GetWindowIsFocused	libs/imgui/imgui.h	/^    static inline bool      GetWindowIsFocused() { return ImGui::IsWindowFocused(); }          \/\/ OBSOLETE 1.36+$/;"	f	namespace:ImGui	signature:()
ImGui::GetWindowPos	libs/imgui/imgui.cpp	/^ImVec2 ImGui::GetWindowPos()$/;"	f	class:ImGui	signature:()
ImGui::GetWindowPos	libs/imgui/imgui.h	/^    IMGUI_API ImVec2        GetWindowPos();                                                     \/\/ get current window position in screen space (useful if you want to do your own drawing via the DrawList api)$/;"	p	namespace:ImGui	signature:()
ImGui::GetWindowSize	libs/imgui/imgui.cpp	/^ImVec2 ImGui::GetWindowSize()$/;"	f	class:ImGui	signature:()
ImGui::GetWindowSize	libs/imgui/imgui.h	/^    IMGUI_API ImVec2        GetWindowSize();                                                    \/\/ get current window size$/;"	p	namespace:ImGui	signature:()
ImGui::GetWindowWidth	libs/imgui/imgui.cpp	/^float ImGui::GetWindowWidth()$/;"	f	class:ImGui	signature:()
ImGui::GetWindowWidth	libs/imgui/imgui.h	/^    IMGUI_API float         GetWindowWidth();$/;"	p	namespace:ImGui	signature:()
ImGui::Image	libs/imgui/imgui.cpp	/^void ImGui::Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, const ImVec4& tint_col, const ImVec4& border_col)$/;"	f	class:ImGui	signature:(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, const ImVec4& tint_col, const ImVec4& border_col)
ImGui::Image	libs/imgui/imgui.h	/^    IMGUI_API void          Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0), const ImVec2& uv1 = ImVec2(1,1), const ImVec4& tint_col = ImVec4(1,1,1,1), const ImVec4& border_col = ImVec4(0,0,0,0));$/;"	p	namespace:ImGui	signature:(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0), const ImVec2& uv1 = ImVec2(1,1), const ImVec4& tint_col = ImVec4(1,1,1,1), const ImVec4& border_col = ImVec4(0,0,0,0))
ImGui::ImageButton	libs/imgui/imgui.cpp	/^bool ImGui::ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, int frame_padding, const ImVec4& bg_col, const ImVec4& tint_col)$/;"	f	class:ImGui	signature:(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, int frame_padding, const ImVec4& bg_col, const ImVec4& tint_col)
ImGui::ImageButton	libs/imgui/imgui.h	/^    IMGUI_API bool          ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0),  const ImVec2& uv1 = ImVec2(1,1), int frame_padding = -1, const ImVec4& bg_col = ImVec4(0,0,0,0), const ImVec4& tint_col = ImVec4(1,1,1,1));    \/\/ <0 frame_padding uses default frame padding settings. 0 for no padding$/;"	p	namespace:ImGui	signature:(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0), const ImVec2& uv1 = ImVec2(1,1), int frame_padding = -1, const ImVec4& bg_col = ImVec4(0,0,0,0), const ImVec4& tint_col = ImVec4(1,1,1,1))
ImGui::Indent	libs/imgui/imgui.cpp	/^void ImGui::Indent()$/;"	f	class:ImGui	signature:()
ImGui::Indent	libs/imgui/imgui.h	/^    IMGUI_API void          Indent();                                                           \/\/ move content position toward the right by style.IndentSpacing pixels$/;"	p	namespace:ImGui	signature:()
ImGui::InputFloat	libs/imgui/imgui.cpp	/^bool ImGui::InputFloat(const char* label, float *v, float step, float step_fast, int decimal_precision, ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, float *v, float step, float step_fast, int decimal_precision, ImGuiInputTextFlags extra_flags)
ImGui::InputFloat	libs/imgui/imgui.h	/^    IMGUI_API bool          InputFloat(const char* label, float* v, float step = 0.0f, float step_fast = 0.0f, int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, float* v, float step = 0.0f, float step_fast = 0.0f, int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0)
ImGui::InputFloat2	libs/imgui/imgui.cpp	/^bool ImGui::InputFloat2(const char* label, float v[2], int decimal_precision, ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, float v[2], int decimal_precision, ImGuiInputTextFlags extra_flags)
ImGui::InputFloat2	libs/imgui/imgui.h	/^    IMGUI_API bool          InputFloat2(const char* label, float v[2], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, float v[2], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0)
ImGui::InputFloat3	libs/imgui/imgui.cpp	/^bool ImGui::InputFloat3(const char* label, float v[3], int decimal_precision, ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, float v[3], int decimal_precision, ImGuiInputTextFlags extra_flags)
ImGui::InputFloat3	libs/imgui/imgui.h	/^    IMGUI_API bool          InputFloat3(const char* label, float v[3], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, float v[3], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0)
ImGui::InputFloat4	libs/imgui/imgui.cpp	/^bool ImGui::InputFloat4(const char* label, float v[4], int decimal_precision, ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, float v[4], int decimal_precision, ImGuiInputTextFlags extra_flags)
ImGui::InputFloat4	libs/imgui/imgui.h	/^    IMGUI_API bool          InputFloat4(const char* label, float v[4], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, float v[4], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0)
ImGui::InputInt	libs/imgui/imgui.cpp	/^bool ImGui::InputInt(const char* label, int *v, int step, int step_fast, ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, int *v, int step, int step_fast, ImGuiInputTextFlags extra_flags)
ImGui::InputInt	libs/imgui/imgui.h	/^    IMGUI_API bool          InputInt(const char* label, int* v, int step = 1, int step_fast = 100, ImGuiInputTextFlags extra_flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, int* v, int step = 1, int step_fast = 100, ImGuiInputTextFlags extra_flags = 0)
ImGui::InputInt2	libs/imgui/imgui.cpp	/^bool ImGui::InputInt2(const char* label, int v[2], ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, int v[2], ImGuiInputTextFlags extra_flags)
ImGui::InputInt2	libs/imgui/imgui.h	/^    IMGUI_API bool          InputInt2(const char* label, int v[2], ImGuiInputTextFlags extra_flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, int v[2], ImGuiInputTextFlags extra_flags = 0)
ImGui::InputInt3	libs/imgui/imgui.cpp	/^bool ImGui::InputInt3(const char* label, int v[3], ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, int v[3], ImGuiInputTextFlags extra_flags)
ImGui::InputInt3	libs/imgui/imgui.h	/^    IMGUI_API bool          InputInt3(const char* label, int v[3], ImGuiInputTextFlags extra_flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, int v[3], ImGuiInputTextFlags extra_flags = 0)
ImGui::InputInt4	libs/imgui/imgui.cpp	/^bool ImGui::InputInt4(const char* label, int v[4], ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, int v[4], ImGuiInputTextFlags extra_flags)
ImGui::InputInt4	libs/imgui/imgui.h	/^    IMGUI_API bool          InputInt4(const char* label, int v[4], ImGuiInputTextFlags extra_flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, int v[4], ImGuiInputTextFlags extra_flags = 0)
ImGui::InputText	libs/imgui/imgui.cpp	/^bool ImGui::InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)$/;"	f	class:ImGui	signature:(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)
ImGui::InputText	libs/imgui/imgui.h	/^    IMGUI_API bool          InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiTextEditCallback callback = NULL, void* user_data = NULL);$/;"	p	namespace:ImGui	signature:(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiTextEditCallback callback = NULL, void* user_data = NULL)
ImGui::InputTextMultiline	libs/imgui/imgui.cpp	/^bool ImGui::InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)$/;"	f	class:ImGui	signature:(const char* label, char* buf, size_t buf_size, const ImVec2& size, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)
ImGui::InputTextMultiline	libs/imgui/imgui.h	/^    IMGUI_API bool          InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size = ImVec2(0,0), ImGuiInputTextFlags flags = 0, ImGuiTextEditCallback callback = NULL, void* user_data = NULL);$/;"	p	namespace:ImGui	signature:(const char* label, char* buf, size_t buf_size, const ImVec2& size = ImVec2(0,0), ImGuiInputTextFlags flags = 0, ImGuiTextEditCallback callback = NULL, void* user_data = NULL)
ImGui::InvisibleButton	libs/imgui/imgui.cpp	/^bool ImGui::InvisibleButton(const char* str_id, const ImVec2& size)$/;"	f	class:ImGui	signature:(const char* str_id, const ImVec2& size)
ImGui::InvisibleButton	libs/imgui/imgui.h	/^    IMGUI_API bool          InvisibleButton(const char* str_id, const ImVec2& size);$/;"	p	namespace:ImGui	signature:(const char* str_id, const ImVec2& size)
ImGui::IsAnyItemActive	libs/imgui/imgui.cpp	/^bool ImGui::IsAnyItemActive()$/;"	f	class:ImGui	signature:()
ImGui::IsAnyItemActive	libs/imgui/imgui.h	/^    IMGUI_API bool          IsAnyItemActive();$/;"	p	namespace:ImGui	signature:()
ImGui::IsAnyItemHovered	libs/imgui/imgui.cpp	/^bool ImGui::IsAnyItemHovered()$/;"	f	class:ImGui	signature:()
ImGui::IsAnyItemHovered	libs/imgui/imgui.h	/^    IMGUI_API bool          IsAnyItemHovered();$/;"	p	namespace:ImGui	signature:()
ImGui::IsClipped	libs/imgui/imgui.h	/^    static inline bool      IsClipped(const ImVec2& size) { return !IsRectVisible(size); }     \/\/ OBSOLETE 1.38+$/;"	f	namespace:ImGui	signature:(const ImVec2& size)
ImGui::IsItemActive	libs/imgui/imgui.cpp	/^bool ImGui::IsItemActive()$/;"	f	class:ImGui	signature:()
ImGui::IsItemActive	libs/imgui/imgui.h	/^    IMGUI_API bool          IsItemActive();                                                     \/\/ was the last item active? (e.g. button being held, text field being edited- items that don't interact will always return false)$/;"	p	namespace:ImGui	signature:()
ImGui::IsItemHovered	libs/imgui/imgui.cpp	/^bool ImGui::IsItemHovered()$/;"	f	class:ImGui	signature:()
ImGui::IsItemHovered	libs/imgui/imgui.h	/^    IMGUI_API bool          IsItemHovered();                                                    \/\/ was the last item hovered by mouse?$/;"	p	namespace:ImGui	signature:()
ImGui::IsItemHoveredRect	libs/imgui/imgui.cpp	/^bool ImGui::IsItemHoveredRect()$/;"	f	class:ImGui	signature:()
ImGui::IsItemHoveredRect	libs/imgui/imgui.h	/^    IMGUI_API bool          IsItemHoveredRect();                                                \/\/ was the last item hovered by mouse? even if another item is active while we are hovering this$/;"	p	namespace:ImGui	signature:()
ImGui::IsItemVisible	libs/imgui/imgui.cpp	/^bool ImGui::IsItemVisible()$/;"	f	class:ImGui	signature:()
ImGui::IsItemVisible	libs/imgui/imgui.h	/^    IMGUI_API bool          IsItemVisible();$/;"	p	namespace:ImGui	signature:()
ImGui::IsKeyDown	libs/imgui/imgui.cpp	/^bool ImGui::IsKeyDown(int key_index)$/;"	f	class:ImGui	signature:(int key_index)
ImGui::IsKeyDown	libs/imgui/imgui.h	/^    IMGUI_API bool          IsKeyDown(int key_index);                                           \/\/ key_index into the keys_down[] array, imgui doesn't know the semantic of each entry, uses your own indices!$/;"	p	namespace:ImGui	signature:(int key_index)
ImGui::IsKeyPressed	libs/imgui/imgui.cpp	/^bool ImGui::IsKeyPressed(int key_index, bool repeat)$/;"	f	class:ImGui	signature:(int key_index, bool repeat)
ImGui::IsKeyPressed	libs/imgui/imgui.h	/^    IMGUI_API bool          IsKeyPressed(int key_index, bool repeat = true);                    \/\/ uses user's key indices as stored in the keys_down[] array. if repeat=true. uses io.KeyRepeatDelay \/ KeyRepeatRate$/;"	p	namespace:ImGui	signature:(int key_index, bool repeat = true)
ImGui::IsKeyReleased	libs/imgui/imgui.cpp	/^bool ImGui::IsKeyReleased(int key_index)$/;"	f	class:ImGui	signature:(int key_index)
ImGui::IsKeyReleased	libs/imgui/imgui.h	/^    IMGUI_API bool          IsKeyReleased(int key_index);                                       \/\/ "$/;"	p	namespace:ImGui	signature:(int key_index)
ImGui::IsMouseClicked	libs/imgui/imgui.cpp	/^bool ImGui::IsMouseClicked(int button, bool repeat)$/;"	f	class:ImGui	signature:(int button, bool repeat)
ImGui::IsMouseClicked	libs/imgui/imgui.h	/^    IMGUI_API bool          IsMouseClicked(int button, bool repeat = false);                    \/\/ did mouse button clicked (went from !Down to Down)$/;"	p	namespace:ImGui	signature:(int button, bool repeat = false)
ImGui::IsMouseDoubleClicked	libs/imgui/imgui.cpp	/^bool ImGui::IsMouseDoubleClicked(int button)$/;"	f	class:ImGui	signature:(int button)
ImGui::IsMouseDoubleClicked	libs/imgui/imgui.h	/^    IMGUI_API bool          IsMouseDoubleClicked(int button);                                   \/\/ did mouse button double-clicked. a double-click returns false in IsMouseClicked(). uses io.MouseDoubleClickTime.$/;"	p	namespace:ImGui	signature:(int button)
ImGui::IsMouseDown	libs/imgui/imgui.cpp	/^bool ImGui::IsMouseDown(int button)$/;"	f	class:ImGui	signature:(int button)
ImGui::IsMouseDown	libs/imgui/imgui.h	/^    IMGUI_API bool          IsMouseDown(int button);                                            \/\/ is mouse button held $/;"	p	namespace:ImGui	signature:(int button)
ImGui::IsMouseDragging	libs/imgui/imgui.cpp	/^bool ImGui::IsMouseDragging(int button, float lock_threshold)$/;"	f	class:ImGui	signature:(int button, float lock_threshold)
ImGui::IsMouseDragging	libs/imgui/imgui.h	/^    IMGUI_API bool          IsMouseDragging(int button = 0, float lock_threshold = -1.0f);      \/\/ is mouse dragging. if lock_threshold < -1.0f uses io.MouseDraggingThreshold$/;"	p	namespace:ImGui	signature:(int button = 0, float lock_threshold = -1.0f)
ImGui::IsMouseHoveringAnyWindow	libs/imgui/imgui.cpp	/^bool ImGui::IsMouseHoveringAnyWindow()$/;"	f	class:ImGui	signature:()
ImGui::IsMouseHoveringAnyWindow	libs/imgui/imgui.h	/^    IMGUI_API bool          IsMouseHoveringAnyWindow();                                         \/\/ is mouse hovering any active imgui window$/;"	p	namespace:ImGui	signature:()
ImGui::IsMouseHoveringBox	libs/imgui/imgui.h	/^    static inline bool      IsMouseHoveringBox(const ImVec2& rect_min, const ImVec2& rect_max) { return IsMouseHoveringRect(rect_min, rect_max); }  \/\/ OBSOLETE 1.36+$/;"	f	namespace:ImGui	signature:(const ImVec2& rect_min, const ImVec2& rect_max)
ImGui::IsMouseHoveringRect	libs/imgui/imgui.cpp	/^bool ImGui::IsMouseHoveringRect(const ImVec2& rect_min, const ImVec2& rect_max)$/;"	f	class:ImGui	signature:(const ImVec2& rect_min, const ImVec2& rect_max)
ImGui::IsMouseHoveringRect	libs/imgui/imgui.h	/^    IMGUI_API bool          IsMouseHoveringRect(const ImVec2& rect_min, const ImVec2& rect_max);\/\/ is mouse hovering given bounding rect$/;"	p	namespace:ImGui	signature:(const ImVec2& rect_min, const ImVec2& rect_max)
ImGui::IsMouseHoveringWindow	libs/imgui/imgui.cpp	/^bool ImGui::IsMouseHoveringWindow()$/;"	f	class:ImGui	signature:()
ImGui::IsMouseHoveringWindow	libs/imgui/imgui.h	/^    IMGUI_API bool          IsMouseHoveringWindow();                                            \/\/ is mouse hovering current window ("window" in API names always refer to current window)$/;"	p	namespace:ImGui	signature:()
ImGui::IsMouseReleased	libs/imgui/imgui.cpp	/^bool ImGui::IsMouseReleased(int button)$/;"	f	class:ImGui	signature:(int button)
ImGui::IsMouseReleased	libs/imgui/imgui.h	/^    IMGUI_API bool          IsMouseReleased(int button);                                        \/\/ did mouse button released (went from Down to !Down)$/;"	p	namespace:ImGui	signature:(int button)
ImGui::IsPosHoveringAnyWindow	libs/imgui/imgui.cpp	/^bool ImGui::IsPosHoveringAnyWindow(const ImVec2& pos)$/;"	f	class:ImGui	signature:(const ImVec2& pos)
ImGui::IsPosHoveringAnyWindow	libs/imgui/imgui.h	/^    IMGUI_API bool          IsPosHoveringAnyWindow(const ImVec2& pos);                          \/\/ is given position hovering any active imgui window$/;"	p	namespace:ImGui	signature:(const ImVec2& pos)
ImGui::IsRectClipped	libs/imgui/imgui.h	/^    static inline bool      IsRectClipped(const ImVec2& size) { return !IsRectVisible(size); } \/\/ OBSOLETE 1.39+$/;"	f	namespace:ImGui	signature:(const ImVec2& size)
ImGui::IsRectVisible	libs/imgui/imgui.cpp	/^bool ImGui::IsRectVisible(const ImVec2& size)$/;"	f	class:ImGui	signature:(const ImVec2& size)
ImGui::IsRectVisible	libs/imgui/imgui.h	/^    IMGUI_API bool          IsRectVisible(const ImVec2& size);                                  \/\/ test if rectangle of given size starting from cursor pos is visible (not clipped). to perform coarse clipping on user's side (as an optimization)$/;"	p	namespace:ImGui	signature:(const ImVec2& size)
ImGui::IsRootWindowFocused	libs/imgui/imgui.cpp	/^bool ImGui::IsRootWindowFocused()$/;"	f	class:ImGui	signature:()
ImGui::IsRootWindowFocused	libs/imgui/imgui.h	/^    IMGUI_API bool          IsRootWindowFocused();                                              \/\/ is current root window focused (top parent window in case of child windows)$/;"	p	namespace:ImGui	signature:()
ImGui::IsRootWindowOrAnyChildFocused	libs/imgui/imgui.cpp	/^bool ImGui::IsRootWindowOrAnyChildFocused()$/;"	f	class:ImGui	signature:()
ImGui::IsRootWindowOrAnyChildFocused	libs/imgui/imgui.h	/^    IMGUI_API bool          IsRootWindowOrAnyChildFocused();                                    \/\/ is current root window or any of its child (including current window) focused$/;"	p	namespace:ImGui	signature:()
ImGui::IsWindowCollapsed	libs/imgui/imgui.cpp	/^bool ImGui::IsWindowCollapsed()$/;"	f	class:ImGui	signature:()
ImGui::IsWindowCollapsed	libs/imgui/imgui.h	/^    IMGUI_API bool          IsWindowCollapsed();$/;"	p	namespace:ImGui	signature:()
ImGui::IsWindowFocused	libs/imgui/imgui.cpp	/^bool ImGui::IsWindowFocused()$/;"	f	class:ImGui	signature:()
ImGui::IsWindowFocused	libs/imgui/imgui.h	/^    IMGUI_API bool          IsWindowFocused();                                                  \/\/ is current window focused (differentiate child windows from each others)$/;"	p	namespace:ImGui	signature:()
ImGui::IsWindowHovered	libs/imgui/imgui.cpp	/^bool ImGui::IsWindowHovered()$/;"	f	class:ImGui	signature:()
ImGui::IsWindowHovered	libs/imgui/imgui.h	/^    IMGUI_API bool          IsWindowHovered();$/;"	p	namespace:ImGui	signature:()
ImGui::LabelText	libs/imgui/imgui.cpp	/^void ImGui::LabelText(const char* label, const char* fmt, ...)$/;"	f	class:ImGui	signature:(const char* label, const char* fmt, ...)
ImGui::LabelText	libs/imgui/imgui.h	/^    IMGUI_API void          LabelText(const char* label, const char* fmt, ...);                 \/\/ display text+label aligned the same way as value+label widgets $/;"	p	namespace:ImGui	signature:(const char* label, const char* fmt, ...)
ImGui::LabelTextV	libs/imgui/imgui.cpp	/^void ImGui::LabelTextV(const char* label, const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const char* label, const char* fmt, va_list args)
ImGui::LabelTextV	libs/imgui/imgui.h	/^    IMGUI_API void          LabelTextV(const char* label, const char* fmt, va_list args);$/;"	p	namespace:ImGui	signature:(const char* label, const char* fmt, va_list args)
ImGui::ListBox	libs/imgui/imgui.cpp	/^bool ImGui::ListBox(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int height_in_items)$/;"	f	class:ImGui	signature:(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int height_in_items)
ImGui::ListBox	libs/imgui/imgui.cpp	/^bool ImGui::ListBox(const char* label, int* current_item, const char** items, int items_count, int height_items)$/;"	f	class:ImGui	signature:(const char* label, int* current_item, const char** items, int items_count, int height_items)
ImGui::ListBox	libs/imgui/imgui.h	/^    IMGUI_API bool          ListBox(const char* label, int* current_item, bool (*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int height_in_items = -1);$/;"	p	namespace:ImGui	signature:(const char* label, int* current_item, bool (*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int height_in_items = -1)
ImGui::ListBox	libs/imgui/imgui.h	/^    IMGUI_API bool          ListBox(const char* label, int* current_item, const char** items, int items_count, int height_in_items = -1);$/;"	p	namespace:ImGui	signature:(const char* label, int* current_item, const char** items, int items_count, int height_in_items = -1)
ImGui::ListBoxFooter	libs/imgui/imgui.cpp	/^void ImGui::ListBoxFooter()$/;"	f	class:ImGui	signature:()
ImGui::ListBoxFooter	libs/imgui/imgui.h	/^    IMGUI_API void          ListBoxFooter();                                                    \/\/ terminate the scrolling region$/;"	p	namespace:ImGui	signature:()
ImGui::ListBoxHeader	libs/imgui/imgui.cpp	/^bool ImGui::ListBoxHeader(const char* label, const ImVec2& size_arg)$/;"	f	class:ImGui	signature:(const char* label, const ImVec2& size_arg)
ImGui::ListBoxHeader	libs/imgui/imgui.cpp	/^bool ImGui::ListBoxHeader(const char* label, int items_count, int height_in_items)$/;"	f	class:ImGui	signature:(const char* label, int items_count, int height_in_items)
ImGui::ListBoxHeader	libs/imgui/imgui.h	/^    IMGUI_API bool          ListBoxHeader(const char* label, const ImVec2& size = ImVec2(0,0)); \/\/ use if you want to reimplement ListBox() will custom data or interactions. make sure to call ListBoxFooter() afterwards.$/;"	p	namespace:ImGui	signature:(const char* label, const ImVec2& size = ImVec2(0,0))
ImGui::ListBoxHeader	libs/imgui/imgui.h	/^    IMGUI_API bool          ListBoxHeader(const char* label, int items_count, int height_in_items = -1); \/\/ "$/;"	p	namespace:ImGui	signature:(const char* label, int items_count, int height_in_items = -1)
ImGui::LogButtons	libs/imgui/imgui.cpp	/^void ImGui::LogButtons()$/;"	f	class:ImGui	signature:()
ImGui::LogButtons	libs/imgui/imgui.h	/^    IMGUI_API void          LogButtons();                                                       \/\/ helper to display buttons for logging to tty\/file\/clipboard$/;"	p	namespace:ImGui	signature:()
ImGui::LogFinish	libs/imgui/imgui.cpp	/^void ImGui::LogFinish()$/;"	f	class:ImGui	signature:()
ImGui::LogFinish	libs/imgui/imgui.h	/^    IMGUI_API void          LogFinish();                                                        \/\/ stop logging (close file, etc.)$/;"	p	namespace:ImGui	signature:()
ImGui::LogText	libs/imgui/imgui.cpp	/^void ImGui::LogText(const char* fmt, ...)$/;"	f	class:ImGui	signature:(const char* fmt, ...)
ImGui::LogText	libs/imgui/imgui.h	/^    IMGUI_API void          LogText(const char* fmt, ...);                                      \/\/ pass text data straight to log (without being displayed)$/;"	p	namespace:ImGui	signature:(const char* fmt, ...)
ImGui::LogToClipboard	libs/imgui/imgui.cpp	/^void ImGui::LogToClipboard(int max_depth)$/;"	f	class:ImGui	signature:(int max_depth)
ImGui::LogToClipboard	libs/imgui/imgui.h	/^    IMGUI_API void          LogToClipboard(int max_depth = -1);                                 \/\/ start logging to OS clipboard$/;"	p	namespace:ImGui	signature:(int max_depth = -1)
ImGui::LogToFile	libs/imgui/imgui.cpp	/^void ImGui::LogToFile(int max_depth, const char* filename)$/;"	f	class:ImGui	signature:(int max_depth, const char* filename)
ImGui::LogToFile	libs/imgui/imgui.h	/^    IMGUI_API void          LogToFile(int max_depth = -1, const char* filename = NULL);         \/\/ start logging to file$/;"	p	namespace:ImGui	signature:(int max_depth = -1, const char* filename = NULL)
ImGui::LogToTTY	libs/imgui/imgui.cpp	/^void ImGui::LogToTTY(int max_depth)$/;"	f	class:ImGui	signature:(int max_depth)
ImGui::LogToTTY	libs/imgui/imgui.h	/^    IMGUI_API void          LogToTTY(int max_depth = -1);                                       \/\/ start logging to tty$/;"	p	namespace:ImGui	signature:(int max_depth = -1)
ImGui::MemAlloc	libs/imgui/imgui.cpp	/^void* ImGui::MemAlloc(size_t sz)$/;"	f	class:ImGui	signature:(size_t sz)
ImGui::MemAlloc	libs/imgui/imgui.h	/^    IMGUI_API void*         MemAlloc(size_t sz);$/;"	p	namespace:ImGui	signature:(size_t sz)
ImGui::MemFree	libs/imgui/imgui.cpp	/^void ImGui::MemFree(void* ptr)$/;"	f	class:ImGui	signature:(void* ptr)
ImGui::MemFree	libs/imgui/imgui.h	/^    IMGUI_API void          MemFree(void* ptr);$/;"	p	namespace:ImGui	signature:(void* ptr)
ImGui::MenuItem	libs/imgui/imgui.cpp	/^bool ImGui::MenuItem(const char* label, const char* shortcut, bool selected, bool enabled)$/;"	f	class:ImGui	signature:(const char* label, const char* shortcut, bool selected, bool enabled)
ImGui::MenuItem	libs/imgui/imgui.cpp	/^bool ImGui::MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled)$/;"	f	class:ImGui	signature:(const char* label, const char* shortcut, bool* p_selected, bool enabled)
ImGui::MenuItem	libs/imgui/imgui.h	/^    IMGUI_API bool          MenuItem(const char* label, const char* shortcut = NULL, bool selected = false, bool enabled = true);  \/\/ return true when activated. shortcuts are displayed for convenience but not processed by ImGui at the moment$/;"	p	namespace:ImGui	signature:(const char* label, const char* shortcut = NULL, bool selected = false, bool enabled = true)
ImGui::MenuItem	libs/imgui/imgui.h	/^    IMGUI_API bool          MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled = true);              \/\/ return true when activated + toggle (*p_selected) if p_selected != NULL$/;"	p	namespace:ImGui	signature:(const char* label, const char* shortcut, bool* p_selected, bool enabled = true)
ImGui::NewFrame	libs/imgui/imgui.cpp	/^void ImGui::NewFrame()$/;"	f	class:ImGui	signature:()
ImGui::NewFrame	libs/imgui/imgui.h	/^    IMGUI_API void          NewFrame();$/;"	p	namespace:ImGui	signature:()
ImGui::NextColumn	libs/imgui/imgui.cpp	/^void ImGui::NextColumn()$/;"	f	class:ImGui	signature:()
ImGui::NextColumn	libs/imgui/imgui.h	/^    IMGUI_API void          NextColumn();                                                       \/\/ next column$/;"	p	namespace:ImGui	signature:()
ImGui::OpenNextNode	libs/imgui/imgui.h	/^    static inline void      OpenNextNode(bool open) { ImGui::SetNextTreeNodeOpened(open, 0); } \/\/ OBSOLETE 1.34+$/;"	f	namespace:ImGui	signature:(bool open)
ImGui::OpenPopup	libs/imgui/imgui.cpp	/^void ImGui::OpenPopup(const char* str_id)$/;"	f	class:ImGui	signature:(const char* str_id)
ImGui::OpenPopup	libs/imgui/imgui.h	/^    IMGUI_API void          OpenPopup(const char* str_id);                                      \/\/ mark popup as open. popup identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup needs to be at the same level). close childs popups if any. will close popup when user click outside, or activate a pressable item, or CloseCurrentPopup() is called within a BeginPopup()\/EndPopup() block.$/;"	p	namespace:ImGui	signature:(const char* str_id)
ImGui::PlotHistogram	libs/imgui/imgui.cpp	/^void ImGui::PlotHistogram(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)$/;"	f	class:ImGui	signature:(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)
ImGui::PlotHistogram	libs/imgui/imgui.cpp	/^void ImGui::PlotHistogram(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)$/;"	f	class:ImGui	signature:(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)
ImGui::PlotHistogram	libs/imgui/imgui.h	/^    IMGUI_API void          PlotHistogram(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0), int stride = sizeof(float));$/;"	p	namespace:ImGui	signature:(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0), int stride = sizeof(float))
ImGui::PlotHistogram	libs/imgui/imgui.h	/^    IMGUI_API void          PlotHistogram(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0));$/;"	p	namespace:ImGui	signature:(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0))
ImGui::PlotLines	libs/imgui/imgui.cpp	/^void ImGui::PlotLines(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)$/;"	f	class:ImGui	signature:(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)
ImGui::PlotLines	libs/imgui/imgui.cpp	/^void ImGui::PlotLines(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)$/;"	f	class:ImGui	signature:(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)
ImGui::PlotLines	libs/imgui/imgui.h	/^    IMGUI_API void          PlotLines(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0), int stride = sizeof(float));$/;"	p	namespace:ImGui	signature:(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0), int stride = sizeof(float))
ImGui::PlotLines	libs/imgui/imgui.h	/^    IMGUI_API void          PlotLines(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0));$/;"	p	namespace:ImGui	signature:(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0))
ImGui::PopAllowKeyboardFocus	libs/imgui/imgui.cpp	/^void ImGui::PopAllowKeyboardFocus()$/;"	f	class:ImGui	signature:()
ImGui::PopAllowKeyboardFocus	libs/imgui/imgui.h	/^    IMGUI_API void          PopAllowKeyboardFocus();$/;"	p	namespace:ImGui	signature:()
ImGui::PopButtonRepeat	libs/imgui/imgui.cpp	/^void ImGui::PopButtonRepeat()$/;"	f	class:ImGui	signature:()
ImGui::PopButtonRepeat	libs/imgui/imgui.h	/^    IMGUI_API void          PopButtonRepeat();$/;"	p	namespace:ImGui	signature:()
ImGui::PopFont	libs/imgui/imgui.cpp	/^void  ImGui::PopFont()$/;"	f	class:ImGui	signature:()
ImGui::PopFont	libs/imgui/imgui.h	/^    IMGUI_API void          PopFont();$/;"	p	namespace:ImGui	signature:()
ImGui::PopID	libs/imgui/imgui.cpp	/^void ImGui::PopID()$/;"	f	class:ImGui	signature:()
ImGui::PopID	libs/imgui/imgui.h	/^    IMGUI_API void          PopID();$/;"	p	namespace:ImGui	signature:()
ImGui::PopItemWidth	libs/imgui/imgui.cpp	/^void ImGui::PopItemWidth()$/;"	f	class:ImGui	signature:()
ImGui::PopItemWidth	libs/imgui/imgui.h	/^    IMGUI_API void          PopItemWidth();$/;"	p	namespace:ImGui	signature:()
ImGui::PopStyleColor	libs/imgui/imgui.cpp	/^void ImGui::PopStyleColor(int count)$/;"	f	class:ImGui	signature:(int count)
ImGui::PopStyleColor	libs/imgui/imgui.h	/^    IMGUI_API void          PopStyleColor(int count = 1);$/;"	p	namespace:ImGui	signature:(int count = 1)
ImGui::PopStyleVar	libs/imgui/imgui.cpp	/^void ImGui::PopStyleVar(int count)$/;"	f	class:ImGui	signature:(int count)
ImGui::PopStyleVar	libs/imgui/imgui.h	/^    IMGUI_API void          PopStyleVar(int count = 1);$/;"	p	namespace:ImGui	signature:(int count = 1)
ImGui::PopTextWrapPos	libs/imgui/imgui.cpp	/^void ImGui::PopTextWrapPos()$/;"	f	class:ImGui	signature:()
ImGui::PopTextWrapPos	libs/imgui/imgui.h	/^    IMGUI_API void          PopTextWrapPos();$/;"	p	namespace:ImGui	signature:()
ImGui::PushAllowKeyboardFocus	libs/imgui/imgui.cpp	/^void ImGui::PushAllowKeyboardFocus(bool allow_keyboard_focus)$/;"	f	class:ImGui	signature:(bool allow_keyboard_focus)
ImGui::PushAllowKeyboardFocus	libs/imgui/imgui.h	/^    IMGUI_API void          PushAllowKeyboardFocus(bool v);                                     \/\/ allow focusing using TAB\/Shift-TAB, enabled by default but you can disable it for certain widgets$/;"	p	namespace:ImGui	signature:(bool v)
ImGui::PushButtonRepeat	libs/imgui/imgui.cpp	/^void ImGui::PushButtonRepeat(bool repeat)$/;"	f	class:ImGui	signature:(bool repeat)
ImGui::PushButtonRepeat	libs/imgui/imgui.h	/^    IMGUI_API void          PushButtonRepeat(bool repeat);                                      \/\/ in 'repeat' mode, Button*() functions return true multiple times as you hold them (uses io.KeyRepeatDelay\/io.KeyRepeatRate for now)$/;"	p	namespace:ImGui	signature:(bool repeat)
ImGui::PushFont	libs/imgui/imgui.cpp	/^void ImGui::PushFont(ImFont* font)$/;"	f	class:ImGui	signature:(ImFont* font)
ImGui::PushFont	libs/imgui/imgui.h	/^    IMGUI_API void          PushFont(ImFont* font);                                             \/\/ use NULL as a shortcut to push default font$/;"	p	namespace:ImGui	signature:(ImFont* font)
ImGui::PushID	libs/imgui/imgui.cpp	/^void ImGui::PushID(const char* str_id)$/;"	f	class:ImGui	signature:(const char* str_id)
ImGui::PushID	libs/imgui/imgui.cpp	/^void ImGui::PushID(const char* str_id_begin, const char* str_id_end)$/;"	f	class:ImGui	signature:(const char* str_id_begin, const char* str_id_end)
ImGui::PushID	libs/imgui/imgui.cpp	/^void ImGui::PushID(const void* ptr_id)$/;"	f	class:ImGui	signature:(const void* ptr_id)
ImGui::PushID	libs/imgui/imgui.cpp	/^void ImGui::PushID(int int_id)$/;"	f	class:ImGui	signature:(int int_id)
ImGui::PushID	libs/imgui/imgui.h	/^    IMGUI_API void          PushID(const char* str_id);                                         \/\/ push identifier into the ID stack. IDs are hash of the *entire* stack!$/;"	p	namespace:ImGui	signature:(const char* str_id)
ImGui::PushID	libs/imgui/imgui.h	/^    IMGUI_API void          PushID(const char* str_id_begin, const char* str_id_end);$/;"	p	namespace:ImGui	signature:(const char* str_id_begin, const char* str_id_end)
ImGui::PushID	libs/imgui/imgui.h	/^    IMGUI_API void          PushID(const void* ptr_id);$/;"	p	namespace:ImGui	signature:(const void* ptr_id)
ImGui::PushID	libs/imgui/imgui.h	/^    IMGUI_API void          PushID(int int_id);$/;"	p	namespace:ImGui	signature:(int int_id)
ImGui::PushItemWidth	libs/imgui/imgui.cpp	/^void ImGui::PushItemWidth(float item_width)$/;"	f	class:ImGui	signature:(float item_width)
ImGui::PushItemWidth	libs/imgui/imgui.h	/^    IMGUI_API void          PushItemWidth(float item_width);                                    \/\/ width of items for the common item+label case, pixels. 0.0f = default to ~2\/3 of windows width, >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -1.0f always align width to the right side)$/;"	p	namespace:ImGui	signature:(float item_width)
ImGui::PushStyleColor	libs/imgui/imgui.cpp	/^void ImGui::PushStyleColor(ImGuiCol idx, const ImVec4& col)$/;"	f	class:ImGui	signature:(ImGuiCol idx, const ImVec4& col)
ImGui::PushStyleColor	libs/imgui/imgui.h	/^    IMGUI_API void          PushStyleColor(ImGuiCol idx, const ImVec4& col);$/;"	p	namespace:ImGui	signature:(ImGuiCol idx, const ImVec4& col)
ImGui::PushStyleVar	libs/imgui/imgui.cpp	/^void ImGui::PushStyleVar(ImGuiStyleVar idx, const ImVec2& val)$/;"	f	class:ImGui	signature:(ImGuiStyleVar idx, const ImVec2& val)
ImGui::PushStyleVar	libs/imgui/imgui.cpp	/^void ImGui::PushStyleVar(ImGuiStyleVar idx, float val)$/;"	f	class:ImGui	signature:(ImGuiStyleVar idx, float val)
ImGui::PushStyleVar	libs/imgui/imgui.h	/^    IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, const ImVec2& val);$/;"	p	namespace:ImGui	signature:(ImGuiStyleVar idx, const ImVec2& val)
ImGui::PushStyleVar	libs/imgui/imgui.h	/^    IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, float val);$/;"	p	namespace:ImGui	signature:(ImGuiStyleVar idx, float val)
ImGui::PushTextWrapPos	libs/imgui/imgui.cpp	/^void ImGui::PushTextWrapPos(float wrap_pos_x)$/;"	f	class:ImGui	signature:(float wrap_pos_x)
ImGui::PushTextWrapPos	libs/imgui/imgui.h	/^    IMGUI_API void          PushTextWrapPos(float wrap_pos_x = 0.0f);                           \/\/ word-wrapping for Text*() commands. < 0.0f: no wrapping; 0.0f: wrap to end of window (or column); > 0.0f: wrap at 'wrap_pos_x' position in window local space$/;"	p	namespace:ImGui	signature:(float wrap_pos_x = 0.0f)
ImGui::RadioButton	libs/imgui/imgui.cpp	/^bool ImGui::RadioButton(const char* label, bool active)$/;"	f	class:ImGui	signature:(const char* label, bool active)
ImGui::RadioButton	libs/imgui/imgui.cpp	/^bool ImGui::RadioButton(const char* label, int* v, int v_button)$/;"	f	class:ImGui	signature:(const char* label, int* v, int v_button)
ImGui::RadioButton	libs/imgui/imgui.h	/^    IMGUI_API bool          RadioButton(const char* label, bool active);$/;"	p	namespace:ImGui	signature:(const char* label, bool active)
ImGui::RadioButton	libs/imgui/imgui.h	/^    IMGUI_API bool          RadioButton(const char* label, int* v, int v_button);$/;"	p	namespace:ImGui	signature:(const char* label, int* v, int v_button)
ImGui::Render	libs/imgui/imgui.cpp	/^void ImGui::Render()$/;"	f	class:ImGui	signature:()
ImGui::Render	libs/imgui/imgui.h	/^    IMGUI_API void          Render();$/;"	p	namespace:ImGui	signature:()
ImGui::ResetMouseDragDelta	libs/imgui/imgui.cpp	/^void ImGui::ResetMouseDragDelta(int button)$/;"	f	class:ImGui	signature:(int button)
ImGui::ResetMouseDragDelta	libs/imgui/imgui.h	/^    IMGUI_API void          ResetMouseDragDelta(int button = 0);                                \/\/ $/;"	p	namespace:ImGui	signature:(int button = 0)
ImGui::SameLine	libs/imgui/imgui.cpp	/^void ImGui::SameLine(float pos_x, float spacing_w)$/;"	f	class:ImGui	signature:(float pos_x, float spacing_w)
ImGui::SameLine	libs/imgui/imgui.h	/^    IMGUI_API void          SameLine(float pos_x = 0.0f, float spacing_w = -1.0f);              \/\/ call between widgets or groups to layout them horizontally$/;"	p	namespace:ImGui	signature:(float pos_x = 0.0f, float spacing_w = -1.0f)
ImGui::Selectable	libs/imgui/imgui.cpp	/^bool ImGui::Selectable(const char* label, bool selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)$/;"	f	class:ImGui	signature:(const char* label, bool selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)
ImGui::Selectable	libs/imgui/imgui.cpp	/^bool ImGui::Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)$/;"	f	class:ImGui	signature:(const char* label, bool* p_selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)
ImGui::Selectable	libs/imgui/imgui.h	/^    IMGUI_API bool          Selectable(const char* label, bool selected = false, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0));  \/\/ size.x==0.0: use remaining width, size.x>0.0: specify width. size.y==0.0: use label height, size.y>0.0: specify height $/;"	p	namespace:ImGui	signature:(const char* label, bool selected = false, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0))
ImGui::Selectable	libs/imgui/imgui.h	/^    IMGUI_API bool          Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0));$/;"	p	namespace:ImGui	signature:(const char* label, bool* p_selected, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0))
ImGui::Separator	libs/imgui/imgui.cpp	/^void ImGui::Separator()$/;"	f	class:ImGui	signature:()
ImGui::Separator	libs/imgui/imgui.h	/^    IMGUI_API void          Separator();                                                        \/\/ horizontal line$/;"	p	namespace:ImGui	signature:()
ImGui::SetColumnOffset	libs/imgui/imgui.cpp	/^void ImGui::SetColumnOffset(int column_index, float offset)$/;"	f	class:ImGui	signature:(int column_index, float offset)
ImGui::SetColumnOffset	libs/imgui/imgui.h	/^    IMGUI_API void          SetColumnOffset(int column_index, float offset_x);                  \/\/ set position of column line (in pixels, from the left side of the contents region). pass -1 to use current column$/;"	p	namespace:ImGui	signature:(int column_index, float offset_x)
ImGui::SetCursorPos	libs/imgui/imgui.cpp	/^void ImGui::SetCursorPos(const ImVec2& pos)$/;"	f	class:ImGui	signature:(const ImVec2& pos)
ImGui::SetCursorPos	libs/imgui/imgui.h	/^    IMGUI_API void          SetCursorPos(const ImVec2& pos);                                    \/\/ "$/;"	p	namespace:ImGui	signature:(const ImVec2& pos)
ImGui::SetCursorPosX	libs/imgui/imgui.cpp	/^void ImGui::SetCursorPosX(float x)$/;"	f	class:ImGui	signature:(float x)
ImGui::SetCursorPosX	libs/imgui/imgui.h	/^    IMGUI_API void          SetCursorPosX(float x);                                             \/\/ "$/;"	p	namespace:ImGui	signature:(float x)
ImGui::SetCursorPosY	libs/imgui/imgui.cpp	/^void ImGui::SetCursorPosY(float y)$/;"	f	class:ImGui	signature:(float y)
ImGui::SetCursorPosY	libs/imgui/imgui.h	/^    IMGUI_API void          SetCursorPosY(float y);                                             \/\/ "$/;"	p	namespace:ImGui	signature:(float y)
ImGui::SetCursorScreenPos	libs/imgui/imgui.cpp	/^void ImGui::SetCursorScreenPos(const ImVec2& screen_pos)$/;"	f	class:ImGui	signature:(const ImVec2& screen_pos)
ImGui::SetCursorScreenPos	libs/imgui/imgui.h	/^    IMGUI_API void          SetCursorScreenPos(const ImVec2& pos);                              \/\/ cursor position in absolute screen coordinates [0..io.DisplaySize]$/;"	p	namespace:ImGui	signature:(const ImVec2& pos)
ImGui::SetInternalState	libs/imgui/imgui.cpp	/^void ImGui::SetInternalState(void* state, bool construct)$/;"	f	class:ImGui	signature:(void* state, bool construct)
ImGui::SetInternalState	libs/imgui/imgui.h	/^    IMGUI_API void          SetInternalState(void* state, bool construct = false);$/;"	p	namespace:ImGui	signature:(void* state, bool construct = false)
ImGui::SetKeyboardFocusHere	libs/imgui/imgui.cpp	/^void ImGui::SetKeyboardFocusHere(int offset)$/;"	f	class:ImGui	signature:(int offset)
ImGui::SetKeyboardFocusHere	libs/imgui/imgui.h	/^    IMGUI_API void          SetKeyboardFocusHere(int offset = 0);                               \/\/ focus keyboard on the next widget. Use positive 'offset' to access sub components of a multiple component widget$/;"	p	namespace:ImGui	signature:(int offset = 0)
ImGui::SetMouseCursor	libs/imgui/imgui.cpp	/^void ImGui::SetMouseCursor(ImGuiMouseCursor cursor_type)$/;"	f	class:ImGui	signature:(ImGuiMouseCursor cursor_type)
ImGui::SetMouseCursor	libs/imgui/imgui.h	/^    IMGUI_API void          SetMouseCursor(ImGuiMouseCursor type);                              \/\/ set desired cursor type$/;"	p	namespace:ImGui	signature:(ImGuiMouseCursor type)
ImGui::SetNextTreeNodeOpened	libs/imgui/imgui.cpp	/^void ImGui::SetNextTreeNodeOpened(bool opened, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(bool opened, ImGuiSetCond cond)
ImGui::SetNextTreeNodeOpened	libs/imgui/imgui.h	/^    IMGUI_API void          SetNextTreeNodeOpened(bool opened, ImGuiSetCond cond = 0);          \/\/ set next tree node to be opened.$/;"	p	namespace:ImGui	signature:(bool opened, ImGuiSetCond cond = 0)
ImGui::SetNextWindowCollapsed	libs/imgui/imgui.cpp	/^void ImGui::SetNextWindowCollapsed(bool collapsed, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(bool collapsed, ImGuiSetCond cond)
ImGui::SetNextWindowCollapsed	libs/imgui/imgui.h	/^    IMGUI_API void          SetNextWindowCollapsed(bool collapsed, ImGuiSetCond cond = 0);      \/\/ set next window collapsed state. call before Begin()$/;"	p	namespace:ImGui	signature:(bool collapsed, ImGuiSetCond cond = 0)
ImGui::SetNextWindowFocus	libs/imgui/imgui.cpp	/^void ImGui::SetNextWindowFocus()$/;"	f	class:ImGui	signature:()
ImGui::SetNextWindowFocus	libs/imgui/imgui.h	/^    IMGUI_API void          SetNextWindowFocus();                                               \/\/ set next window to be focused \/ front-most. call before Begin()$/;"	p	namespace:ImGui	signature:()
ImGui::SetNextWindowPos	libs/imgui/imgui.cpp	/^void ImGui::SetNextWindowPos(const ImVec2& pos, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(const ImVec2& pos, ImGuiSetCond cond)
ImGui::SetNextWindowPos	libs/imgui/imgui.h	/^    IMGUI_API void          SetNextWindowPos(const ImVec2& pos, ImGuiSetCond cond = 0);         \/\/ set next window position. call before Begin()$/;"	p	namespace:ImGui	signature:(const ImVec2& pos, ImGuiSetCond cond = 0)
ImGui::SetNextWindowPosCenter	libs/imgui/imgui.cpp	/^void ImGui::SetNextWindowPosCenter(ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(ImGuiSetCond cond)
ImGui::SetNextWindowPosCenter	libs/imgui/imgui.h	/^    IMGUI_API void          SetNextWindowPosCenter(ImGuiSetCond cond = 0);                      \/\/ set next window position to be centered on screen. call before Begin()$/;"	p	namespace:ImGui	signature:(ImGuiSetCond cond = 0)
ImGui::SetNextWindowSize	libs/imgui/imgui.cpp	/^void ImGui::SetNextWindowSize(const ImVec2& size, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(const ImVec2& size, ImGuiSetCond cond)
ImGui::SetNextWindowSize	libs/imgui/imgui.h	/^    IMGUI_API void          SetNextWindowSize(const ImVec2& size, ImGuiSetCond cond = 0);       \/\/ set next window size. set to ImVec2(0,0) to force an auto-fit. call before Begin()$/;"	p	namespace:ImGui	signature:(const ImVec2& size, ImGuiSetCond cond = 0)
ImGui::SetScrollFromPosY	libs/imgui/imgui.cpp	/^void ImGui::SetScrollFromPosY(float pos_y, float center_y_ratio)$/;"	f	class:ImGui	signature:(float pos_y, float center_y_ratio)
ImGui::SetScrollFromPosY	libs/imgui/imgui.h	/^    IMGUI_API void          SetScrollFromPosY(float pos_y, float center_y_ratio = 0.5f);        \/\/ adjust scrolling amount to make given position valid. use GetCursorPos() or GetCursorStartPos()+offset to get valid positions.$/;"	p	namespace:ImGui	signature:(float pos_y, float center_y_ratio = 0.5f)
ImGui::SetScrollHere	libs/imgui/imgui.cpp	/^void ImGui::SetScrollHere(float center_y_ratio)$/;"	f	class:ImGui	signature:(float center_y_ratio)
ImGui::SetScrollHere	libs/imgui/imgui.h	/^    IMGUI_API void          SetScrollHere(float center_y_ratio = 0.5f);                         \/\/ adjust scrolling amount to make current cursor position visible. center_y_ratio=0.0: top, 0.5: center, 1.0: bottom.$/;"	p	namespace:ImGui	signature:(float center_y_ratio = 0.5f)
ImGui::SetScrollPosHere	libs/imgui/imgui.h	/^    static inline void      SetScrollPosHere() { SetScrollHere(); }                            \/\/ OBSOLETE 1.42+$/;"	f	namespace:ImGui	signature:()
ImGui::SetScrollY	libs/imgui/imgui.cpp	/^void ImGui::SetScrollY(float scroll_y)$/;"	f	class:ImGui	signature:(float scroll_y)
ImGui::SetScrollY	libs/imgui/imgui.h	/^    IMGUI_API void          SetScrollY(float scroll_y);                                         \/\/ set scrolling amount [0..GetScrollMaxY()]$/;"	p	namespace:ImGui	signature:(float scroll_y)
ImGui::SetStateStorage	libs/imgui/imgui.cpp	/^void ImGui::SetStateStorage(ImGuiStorage* tree)$/;"	f	class:ImGui	signature:(ImGuiStorage* tree)
ImGui::SetStateStorage	libs/imgui/imgui.h	/^    IMGUI_API void          SetStateStorage(ImGuiStorage* tree);                                \/\/ replace tree state storage with our own (if you want to manipulate it yourself, typically clear subsection of it)$/;"	p	namespace:ImGui	signature:(ImGuiStorage* tree)
ImGui::SetTooltip	libs/imgui/imgui.cpp	/^void ImGui::SetTooltip(const char* fmt, ...)$/;"	f	class:ImGui	signature:(const char* fmt, ...)
ImGui::SetTooltip	libs/imgui/imgui.h	/^    IMGUI_API void          SetTooltip(const char* fmt, ...);                                   \/\/ set tooltip under mouse-cursor, typically use with ImGui::IsHovered(). last call wins$/;"	p	namespace:ImGui	signature:(const char* fmt, ...)
ImGui::SetTooltipV	libs/imgui/imgui.cpp	/^void ImGui::SetTooltipV(const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const char* fmt, va_list args)
ImGui::SetTooltipV	libs/imgui/imgui.h	/^    IMGUI_API void          SetTooltipV(const char* fmt, va_list args);$/;"	p	namespace:ImGui	signature:(const char* fmt, va_list args)
ImGui::SetWindowCollapsed	libs/imgui/imgui.cpp	/^void ImGui::SetWindowCollapsed(bool collapsed, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(bool collapsed, ImGuiSetCond cond)
ImGui::SetWindowCollapsed	libs/imgui/imgui.cpp	/^void ImGui::SetWindowCollapsed(const char* name, bool collapsed, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(const char* name, bool collapsed, ImGuiSetCond cond)
ImGui::SetWindowCollapsed	libs/imgui/imgui.h	/^    IMGUI_API void          SetWindowCollapsed(bool collapsed, ImGuiSetCond cond = 0);          \/\/ set current window collapsed state$/;"	p	namespace:ImGui	signature:(bool collapsed, ImGuiSetCond cond = 0)
ImGui::SetWindowCollapsed	libs/imgui/imgui.h	/^    IMGUI_API void          SetWindowCollapsed(const char* name, bool collapsed, ImGuiSetCond cond = 0);   \/\/ set named window collapsed state$/;"	p	namespace:ImGui	signature:(const char* name, bool collapsed, ImGuiSetCond cond = 0)
ImGui::SetWindowFocus	libs/imgui/imgui.cpp	/^void ImGui::SetWindowFocus()$/;"	f	class:ImGui	signature:()
ImGui::SetWindowFocus	libs/imgui/imgui.cpp	/^void ImGui::SetWindowFocus(const char* name)$/;"	f	class:ImGui	signature:(const char* name)
ImGui::SetWindowFocus	libs/imgui/imgui.h	/^    IMGUI_API void          SetWindowFocus();                                                   \/\/ set current window to be focused \/ front-most$/;"	p	namespace:ImGui	signature:()
ImGui::SetWindowFocus	libs/imgui/imgui.h	/^    IMGUI_API void          SetWindowFocus(const char* name);                                              \/\/ set named window to be focused \/ front-most. use NULL to remove focus.$/;"	p	namespace:ImGui	signature:(const char* name)
ImGui::SetWindowFontScale	libs/imgui/imgui.cpp	/^void ImGui::SetWindowFontScale(float scale)$/;"	f	class:ImGui	signature:(float scale)
ImGui::SetWindowFontScale	libs/imgui/imgui.h	/^    IMGUI_API void          SetWindowFontScale(float scale);                                    \/\/ per-window font scale. Adjust IO.FontGlobalScale if you want to scale all windows$/;"	p	namespace:ImGui	signature:(float scale)
ImGui::SetWindowPos	libs/imgui/imgui.cpp	/^void ImGui::SetWindowPos(const ImVec2& pos, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(const ImVec2& pos, ImGuiSetCond cond)
ImGui::SetWindowPos	libs/imgui/imgui.cpp	/^void ImGui::SetWindowPos(const char* name, const ImVec2& pos, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(const char* name, const ImVec2& pos, ImGuiSetCond cond)
ImGui::SetWindowPos	libs/imgui/imgui.h	/^    IMGUI_API void          SetWindowPos(const ImVec2& pos, ImGuiSetCond cond = 0);             \/\/ set current window position - call within Begin()\/End(). may incur tearing$/;"	p	namespace:ImGui	signature:(const ImVec2& pos, ImGuiSetCond cond = 0)
ImGui::SetWindowPos	libs/imgui/imgui.h	/^    IMGUI_API void          SetWindowPos(const char* name, const ImVec2& pos, ImGuiSetCond cond = 0);      \/\/ set named window position - call within Begin()\/End(). may incur tearing$/;"	p	namespace:ImGui	signature:(const char* name, const ImVec2& pos, ImGuiSetCond cond = 0)
ImGui::SetWindowSize	libs/imgui/imgui.cpp	/^void ImGui::SetWindowSize(const ImVec2& size, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(const ImVec2& size, ImGuiSetCond cond)
ImGui::SetWindowSize	libs/imgui/imgui.cpp	/^void ImGui::SetWindowSize(const char* name, const ImVec2& size, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(const char* name, const ImVec2& size, ImGuiSetCond cond)
ImGui::SetWindowSize	libs/imgui/imgui.h	/^    IMGUI_API void          SetWindowSize(const ImVec2& size, ImGuiSetCond cond = 0);           \/\/ set current window size. set to ImVec2(0,0) to force an auto-fit. may incur tearing$/;"	p	namespace:ImGui	signature:(const ImVec2& size, ImGuiSetCond cond = 0)
ImGui::SetWindowSize	libs/imgui/imgui.h	/^    IMGUI_API void          SetWindowSize(const char* name, const ImVec2& size, ImGuiSetCond cond = 0);    \/\/ set named window size. set to ImVec2(0,0) to force an auto-fit. may incur tearing$/;"	p	namespace:ImGui	signature:(const char* name, const ImVec2& size, ImGuiSetCond cond = 0)
ImGui::ShowMetricsWindow	libs/imgui/imgui.cpp	/^void ImGui::ShowMetricsWindow(bool* opened)$/;"	f	class:ImGui	signature:(bool* opened)
ImGui::ShowMetricsWindow	libs/imgui/imgui.h	/^    IMGUI_API void          ShowMetricsWindow(bool* opened = NULL);     \/\/ metrics window for debugging imgui$/;"	p	namespace:ImGui	signature:(bool* opened = NULL)
ImGui::ShowStyleEditor	libs/imgui/imgui.cpp	/^void ImGui::ShowStyleEditor(ImGuiStyle* ref)$/;"	f	class:ImGui	signature:(ImGuiStyle* ref)
ImGui::ShowStyleEditor	libs/imgui/imgui.h	/^    IMGUI_API void          ShowStyleEditor(ImGuiStyle* ref = NULL);    \/\/ style editor block$/;"	p	namespace:ImGui	signature:(ImGuiStyle* ref = NULL)
ImGui::ShowTestWindow	libs/imgui/imgui.cpp	/^void ImGui::ShowTestWindow(bool* opened)$/;"	f	class:ImGui	signature:(bool* opened)
ImGui::ShowTestWindow	libs/imgui/imgui.cpp	/^void ImGui::ShowTestWindow(bool*) {}$/;"	f	class:ImGui	signature:(bool*)
ImGui::ShowTestWindow	libs/imgui/imgui.h	/^    IMGUI_API void          ShowTestWindow(bool* opened = NULL);        \/\/ test window, demonstrate ImGui features$/;"	p	namespace:ImGui	signature:(bool* opened = NULL)
ImGui::ShowUserGuide	libs/imgui/imgui.cpp	/^void ImGui::ShowUserGuide()$/;"	f	class:ImGui	signature:()
ImGui::ShowUserGuide	libs/imgui/imgui.h	/^    IMGUI_API void          ShowUserGuide();                            \/\/ help block$/;"	p	namespace:ImGui	signature:()
ImGui::Shutdown	libs/imgui/imgui.cpp	/^void ImGui::Shutdown()$/;"	f	class:ImGui	signature:()
ImGui::Shutdown	libs/imgui/imgui.h	/^    IMGUI_API void          Shutdown();$/;"	p	namespace:ImGui	signature:()
ImGui::SliderAngle	libs/imgui/imgui.cpp	/^bool ImGui::SliderAngle(const char* label, float* v_rad, float v_degrees_min, float v_degrees_max)$/;"	f	class:ImGui	signature:(const char* label, float* v_rad, float v_degrees_min, float v_degrees_max)
ImGui::SliderAngle	libs/imgui/imgui.h	/^    IMGUI_API bool          SliderAngle(const char* label, float* v_rad, float v_degrees_min = -360.0f, float v_degrees_max = +360.0f);$/;"	p	namespace:ImGui	signature:(const char* label, float* v_rad, float v_degrees_min = -360.0f, float v_degrees_max = +360.0f)
ImGui::SliderFloat	libs/imgui/imgui.cpp	/^bool ImGui::SliderFloat(const char* label, float* v, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float* v, float v_min, float v_max, const char* display_format, float power)
ImGui::SliderFloat	libs/imgui/imgui.h	/^    IMGUI_API bool          SliderFloat(const char* label, float* v, float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);     \/\/ adjust display_format to decorate the value with a prefix or a suffix. Use power!=1.0 for logarithmic sliders$/;"	p	namespace:ImGui	signature:(const char* label, float* v, float v_min, float v_max, const char* display_format = Ó, float power = 1.0f)
ImGui::SliderFloat2	libs/imgui/imgui.cpp	/^bool ImGui::SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float v[2], float v_min, float v_max, const char* display_format, float power)
ImGui::SliderFloat2	libs/imgui/imgui.h	/^    IMGUI_API bool          SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);$/;"	p	namespace:ImGui	signature:(const char* label, float v[2], float v_min, float v_max, const char* display_format = Ó, float power = 1.0f)
ImGui::SliderFloat3	libs/imgui/imgui.cpp	/^bool ImGui::SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float v[3], float v_min, float v_max, const char* display_format, float power)
ImGui::SliderFloat3	libs/imgui/imgui.h	/^    IMGUI_API bool          SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);$/;"	p	namespace:ImGui	signature:(const char* label, float v[3], float v_min, float v_max, const char* display_format = Ó, float power = 1.0f)
ImGui::SliderFloat4	libs/imgui/imgui.cpp	/^bool ImGui::SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float v[4], float v_min, float v_max, const char* display_format, float power)
ImGui::SliderFloat4	libs/imgui/imgui.h	/^    IMGUI_API bool          SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);$/;"	p	namespace:ImGui	signature:(const char* label, float v[4], float v_min, float v_max, const char* display_format = Ó, float power = 1.0f)
ImGui::SliderInt	libs/imgui/imgui.cpp	/^bool ImGui::SliderInt(const char* label, int* v, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int* v, int v_min, int v_max, const char* display_format)
ImGui::SliderInt	libs/imgui/imgui.h	/^    IMGUI_API bool          SliderInt(const char* label, int* v, int v_min, int v_max, const char* display_format = "%.0f");$/;"	p	namespace:ImGui	signature:(const char* label, int* v, int v_min, int v_max, const char* display_format = Ó)
ImGui::SliderInt2	libs/imgui/imgui.cpp	/^bool ImGui::SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int v[2], int v_min, int v_max, const char* display_format)
ImGui::SliderInt2	libs/imgui/imgui.h	/^    IMGUI_API bool          SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* display_format = "%.0f");$/;"	p	namespace:ImGui	signature:(const char* label, int v[2], int v_min, int v_max, const char* display_format = Ó)
ImGui::SliderInt3	libs/imgui/imgui.cpp	/^bool ImGui::SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int v[3], int v_min, int v_max, const char* display_format)
ImGui::SliderInt3	libs/imgui/imgui.h	/^    IMGUI_API bool          SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* display_format = "%.0f");$/;"	p	namespace:ImGui	signature:(const char* label, int v[3], int v_min, int v_max, const char* display_format = Ó)
ImGui::SliderInt4	libs/imgui/imgui.cpp	/^bool ImGui::SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int v[4], int v_min, int v_max, const char* display_format)
ImGui::SliderInt4	libs/imgui/imgui.h	/^    IMGUI_API bool          SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* display_format = "%.0f");$/;"	p	namespace:ImGui	signature:(const char* label, int v[4], int v_min, int v_max, const char* display_format = Ó)
ImGui::SmallButton	libs/imgui/imgui.cpp	/^bool ImGui::SmallButton(const char* label)$/;"	f	class:ImGui	signature:(const char* label)
ImGui::SmallButton	libs/imgui/imgui.h	/^    IMGUI_API bool          SmallButton(const char* label);$/;"	p	namespace:ImGui	signature:(const char* label)
ImGui::Spacing	libs/imgui/imgui.cpp	/^void ImGui::Spacing()$/;"	f	class:ImGui	signature:()
ImGui::Spacing	libs/imgui/imgui.h	/^    IMGUI_API void          Spacing();                                                          \/\/ add spacing$/;"	p	namespace:ImGui	signature:()
ImGui::Text	libs/imgui/imgui.cpp	/^void ImGui::Text(const char* fmt, ...)$/;"	f	class:ImGui	signature:(const char* fmt, ...)
ImGui::Text	libs/imgui/imgui.h	/^    IMGUI_API void          Text(const char* fmt, ...);$/;"	p	namespace:ImGui	signature:(const char* fmt, ...)
ImGui::TextColored	libs/imgui/imgui.cpp	/^void ImGui::TextColored(const ImVec4& col, const char* fmt, ...)$/;"	f	class:ImGui	signature:(const ImVec4& col, const char* fmt, ...)
ImGui::TextColored	libs/imgui/imgui.h	/^    IMGUI_API void          TextColored(const ImVec4& col, const char* fmt, ...);               \/\/ shortcut for PushStyleColor(ImGuiCol_Text, col); Text(fmt, ...); PopStyleColor();$/;"	p	namespace:ImGui	signature:(const ImVec4& col, const char* fmt, ...)
ImGui::TextColoredV	libs/imgui/imgui.cpp	/^void ImGui::TextColoredV(const ImVec4& col, const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const ImVec4& col, const char* fmt, va_list args)
ImGui::TextColoredV	libs/imgui/imgui.h	/^    IMGUI_API void          TextColoredV(const ImVec4& col, const char* fmt, va_list args);$/;"	p	namespace:ImGui	signature:(const ImVec4& col, const char* fmt, va_list args)
ImGui::TextDisabled	libs/imgui/imgui.cpp	/^void ImGui::TextDisabled(const char* fmt, ...)$/;"	f	class:ImGui	signature:(const char* fmt, ...)
ImGui::TextDisabled	libs/imgui/imgui.h	/^    IMGUI_API void          TextDisabled(const char* fmt, ...);                                 \/\/ shortcut for PushStyleColor(ImGuiCol_Text, style.Colors[ImGuiCol_TextDisabled]); Text(fmt, ...); PopStyleColor();$/;"	p	namespace:ImGui	signature:(const char* fmt, ...)
ImGui::TextDisabledV	libs/imgui/imgui.cpp	/^void ImGui::TextDisabledV(const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const char* fmt, va_list args)
ImGui::TextDisabledV	libs/imgui/imgui.h	/^    IMGUI_API void          TextDisabledV(const char* fmt, va_list args);$/;"	p	namespace:ImGui	signature:(const char* fmt, va_list args)
ImGui::TextUnformatted	libs/imgui/imgui.cpp	/^void ImGui::TextUnformatted(const char* text, const char* text_end)$/;"	f	class:ImGui	signature:(const char* text, const char* text_end)
ImGui::TextUnformatted	libs/imgui/imgui.h	/^    IMGUI_API void          TextUnformatted(const char* text, const char* text_end = NULL);     \/\/ doesn't require null terminated string if 'text_end' is specified. no copy done to any bounded stack buffer, recommended for long chunks of text$/;"	p	namespace:ImGui	signature:(const char* text, const char* text_end = NULL)
ImGui::TextV	libs/imgui/imgui.cpp	/^void ImGui::TextV(const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const char* fmt, va_list args)
ImGui::TextV	libs/imgui/imgui.h	/^    IMGUI_API void          TextV(const char* fmt, va_list args);$/;"	p	namespace:ImGui	signature:(const char* fmt, va_list args)
ImGui::TextWrapped	libs/imgui/imgui.cpp	/^void ImGui::TextWrapped(const char* fmt, ...)$/;"	f	class:ImGui	signature:(const char* fmt, ...)
ImGui::TextWrapped	libs/imgui/imgui.h	/^    IMGUI_API void          TextWrapped(const char* fmt, ...);                                  \/\/ shortcut for PushTextWrapPos(0.0f); Text(fmt, ...); PopTextWrapPos();. Note that this won't work on an auto-resizing window if there's no other widgets to extend the window width, yoy may need to set a size using SetNextWindowSize().$/;"	p	namespace:ImGui	signature:(const char* fmt, ...)
ImGui::TextWrappedV	libs/imgui/imgui.cpp	/^void ImGui::TextWrappedV(const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const char* fmt, va_list args)
ImGui::TextWrappedV	libs/imgui/imgui.h	/^    IMGUI_API void          TextWrappedV(const char* fmt, va_list args);$/;"	p	namespace:ImGui	signature:(const char* fmt, va_list args)
ImGui::TreeNode	libs/imgui/imgui.cpp	/^bool ImGui::TreeNode(const char* str_id, const char* fmt, ...)$/;"	f	class:ImGui	signature:(const char* str_id, const char* fmt, ...)
ImGui::TreeNode	libs/imgui/imgui.cpp	/^bool ImGui::TreeNode(const char* str_label_id)$/;"	f	class:ImGui	signature:(const char* str_label_id)
ImGui::TreeNode	libs/imgui/imgui.cpp	/^bool ImGui::TreeNode(const void* ptr_id, const char* fmt, ...)$/;"	f	class:ImGui	signature:(const void* ptr_id, const char* fmt, ...)
ImGui::TreeNode	libs/imgui/imgui.h	/^    IMGUI_API bool          TreeNode(const char* str_id, const char* fmt, ...);                 \/\/ "$/;"	p	namespace:ImGui	signature:(const char* str_id, const char* fmt, ...)
ImGui::TreeNode	libs/imgui/imgui.h	/^    IMGUI_API bool          TreeNode(const char* str_label_id);                                 \/\/ if returning 'true' the node is open and the user is responsible for calling TreePop$/;"	p	namespace:ImGui	signature:(const char* str_label_id)
ImGui::TreeNode	libs/imgui/imgui.h	/^    IMGUI_API bool          TreeNode(const void* ptr_id, const char* fmt, ...);                 \/\/ "$/;"	p	namespace:ImGui	signature:(const void* ptr_id, const char* fmt, ...)
ImGui::TreeNodeV	libs/imgui/imgui.cpp	/^bool ImGui::TreeNodeV(const char* str_id, const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const char* str_id, const char* fmt, va_list args)
ImGui::TreeNodeV	libs/imgui/imgui.cpp	/^bool ImGui::TreeNodeV(const void* ptr_id, const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const void* ptr_id, const char* fmt, va_list args)
ImGui::TreeNodeV	libs/imgui/imgui.h	/^    IMGUI_API bool          TreeNodeV(const char* str_id, const char* fmt, va_list args);       \/\/ "$/;"	p	namespace:ImGui	signature:(const char* str_id, const char* fmt, va_list args)
ImGui::TreeNodeV	libs/imgui/imgui.h	/^    IMGUI_API bool          TreeNodeV(const void* ptr_id, const char* fmt, va_list args);       \/\/ "$/;"	p	namespace:ImGui	signature:(const void* ptr_id, const char* fmt, va_list args)
ImGui::TreePop	libs/imgui/imgui.cpp	/^void ImGui::TreePop()$/;"	f	class:ImGui	signature:()
ImGui::TreePop	libs/imgui/imgui.h	/^    IMGUI_API void          TreePop();$/;"	p	namespace:ImGui	signature:()
ImGui::TreePush	libs/imgui/imgui.cpp	/^void ImGui::TreePush(const char* str_id)$/;"	f	class:ImGui	signature:(const char* str_id)
ImGui::TreePush	libs/imgui/imgui.cpp	/^void ImGui::TreePush(const void* ptr_id)$/;"	f	class:ImGui	signature:(const void* ptr_id)
ImGui::TreePush	libs/imgui/imgui.h	/^    IMGUI_API void          TreePush(const char* str_id = NULL);                                \/\/ already called by TreeNode(), but you can call Push\/Pop yourself for layouting purpose$/;"	p	namespace:ImGui	signature:(const char* str_id = NULL)
ImGui::TreePush	libs/imgui/imgui.h	/^    IMGUI_API void          TreePush(const void* ptr_id = NULL);                                \/\/ "$/;"	p	namespace:ImGui	signature:(const void* ptr_id = NULL)
ImGui::Unindent	libs/imgui/imgui.cpp	/^void ImGui::Unindent()$/;"	f	class:ImGui	signature:()
ImGui::Unindent	libs/imgui/imgui.h	/^    IMGUI_API void          Unindent();                                                         \/\/ move content position back to the left (cancel Indent)$/;"	p	namespace:ImGui	signature:()
ImGui::VSliderFloat	libs/imgui/imgui.cpp	/^bool ImGui::VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* display_format, float power)
ImGui::VSliderFloat	libs/imgui/imgui.h	/^    IMGUI_API bool          VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);$/;"	p	namespace:ImGui	signature:(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* display_format = Ó, float power = 1.0f)
ImGui::VSliderInt	libs/imgui/imgui.cpp	/^bool ImGui::VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* display_format)
ImGui::VSliderInt	libs/imgui/imgui.h	/^    IMGUI_API bool          VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* display_format = "%.0f");$/;"	p	namespace:ImGui	signature:(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* display_format = Ó)
ImGui::Value	libs/imgui/imgui.cpp	/^void ImGui::Value(const char* prefix, bool b)$/;"	f	class:ImGui	signature:(const char* prefix, bool b)
ImGui::Value	libs/imgui/imgui.cpp	/^void ImGui::Value(const char* prefix, float v, const char* float_format)$/;"	f	class:ImGui	signature:(const char* prefix, float v, const char* float_format)
ImGui::Value	libs/imgui/imgui.cpp	/^void ImGui::Value(const char* prefix, int v)$/;"	f	class:ImGui	signature:(const char* prefix, int v)
ImGui::Value	libs/imgui/imgui.cpp	/^void ImGui::Value(const char* prefix, unsigned int v)$/;"	f	class:ImGui	signature:(const char* prefix, unsigned int v)
ImGui::Value	libs/imgui/imgui.h	/^    IMGUI_API void          Value(const char* prefix, bool b);$/;"	p	namespace:ImGui	signature:(const char* prefix, bool b)
ImGui::Value	libs/imgui/imgui.h	/^    IMGUI_API void          Value(const char* prefix, float v, const char* float_format = NULL);$/;"	p	namespace:ImGui	signature:(const char* prefix, float v, const char* float_format = NULL)
ImGui::Value	libs/imgui/imgui.h	/^    IMGUI_API void          Value(const char* prefix, int v);$/;"	p	namespace:ImGui	signature:(const char* prefix, int v)
ImGui::Value	libs/imgui/imgui.h	/^    IMGUI_API void          Value(const char* prefix, unsigned int v);$/;"	p	namespace:ImGui	signature:(const char* prefix, unsigned int v)
ImGuiAlign	libs/imgui/imgui.h	/^typedef int ImGuiAlign;             \/\/ enum ImGuiAlign_$/;"	t
ImGuiAlign_	libs/imgui/imgui.h	/^enum ImGuiAlign_$/;"	g
ImGuiAlign_Center	libs/imgui/imgui.h	/^    ImGuiAlign_Center   = 1 << 1,$/;"	e	enum:ImGuiAlign_
ImGuiAlign_Default	libs/imgui/imgui.h	/^    ImGuiAlign_Default  = ImGuiAlign_Left | ImGuiAlign_Top$/;"	e	enum:ImGuiAlign_
ImGuiAlign_Left	libs/imgui/imgui.h	/^    ImGuiAlign_Left     = 1 << 0,$/;"	e	enum:ImGuiAlign_
ImGuiAlign_Right	libs/imgui/imgui.h	/^    ImGuiAlign_Right    = 1 << 2,$/;"	e	enum:ImGuiAlign_
ImGuiAlign_Top	libs/imgui/imgui.h	/^    ImGuiAlign_Top      = 1 << 3,$/;"	e	enum:ImGuiAlign_
ImGuiAlign_VCenter	libs/imgui/imgui.h	/^    ImGuiAlign_VCenter  = 1 << 4,$/;"	e	enum:ImGuiAlign_
ImGuiButtonFlags	libs/imgui/imgui.cpp	/^typedef int ImGuiButtonFlags;     \/\/ enum ImGuiButtonFlags_$/;"	t	file:
ImGuiButtonFlags_	libs/imgui/imgui.cpp	/^enum ImGuiButtonFlags_$/;"	g	file:
ImGuiButtonFlags_AlignTextBaseLine	libs/imgui/imgui.cpp	/^    ImGuiButtonFlags_AlignTextBaseLine  = 1 << 6$/;"	e	enum:ImGuiButtonFlags_	file:
ImGuiButtonFlags_Disabled	libs/imgui/imgui.cpp	/^    ImGuiButtonFlags_Disabled           = 1 << 5,$/;"	e	enum:ImGuiButtonFlags_	file:
ImGuiButtonFlags_DontClosePopups	libs/imgui/imgui.cpp	/^    ImGuiButtonFlags_DontClosePopups    = 1 << 4,$/;"	e	enum:ImGuiButtonFlags_	file:
ImGuiButtonFlags_FlattenChilds	libs/imgui/imgui.cpp	/^    ImGuiButtonFlags_FlattenChilds      = 1 << 3,$/;"	e	enum:ImGuiButtonFlags_	file:
ImGuiButtonFlags_PressedOnClick	libs/imgui/imgui.cpp	/^    ImGuiButtonFlags_PressedOnClick     = 1 << 1,   \/\/ return pressed on click only (default requires click+release)$/;"	e	enum:ImGuiButtonFlags_	file:
ImGuiButtonFlags_PressedOnRelease	libs/imgui/imgui.cpp	/^    ImGuiButtonFlags_PressedOnRelease   = 1 << 2,   \/\/ return pressed on release only (default requires click+release)$/;"	e	enum:ImGuiButtonFlags_	file:
ImGuiButtonFlags_Repeat	libs/imgui/imgui.cpp	/^    ImGuiButtonFlags_Repeat             = 1 << 0,$/;"	e	enum:ImGuiButtonFlags_	file:
ImGuiCol	libs/imgui/imgui.h	/^typedef int ImGuiCol;               \/\/ enum ImGuiCol_$/;"	t
ImGuiColMod	libs/imgui/imgui.cpp	/^struct ImGuiColMod       \/\/ Color modifier, backup of modified data so we can restore it$/;"	s	file:
ImGuiColMod::Col	libs/imgui/imgui.cpp	/^    ImGuiCol    Col;$/;"	m	struct:ImGuiColMod	file:	access:public
ImGuiColMod::PreviousValue	libs/imgui/imgui.cpp	/^    ImVec4      PreviousValue;$/;"	m	struct:ImGuiColMod	file:	access:public
ImGuiCol_	libs/imgui/imgui.h	/^enum ImGuiCol_$/;"	g
ImGuiCol_Border	libs/imgui/imgui.h	/^    ImGuiCol_Border,$/;"	e	enum:ImGuiCol_
ImGuiCol_BorderShadow	libs/imgui/imgui.h	/^    ImGuiCol_BorderShadow,$/;"	e	enum:ImGuiCol_
ImGuiCol_Button	libs/imgui/imgui.h	/^    ImGuiCol_Button,$/;"	e	enum:ImGuiCol_
ImGuiCol_ButtonActive	libs/imgui/imgui.h	/^    ImGuiCol_ButtonActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_ButtonHovered	libs/imgui/imgui.h	/^    ImGuiCol_ButtonHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_COUNT	libs/imgui/imgui.h	/^    ImGuiCol_COUNT$/;"	e	enum:ImGuiCol_
ImGuiCol_CheckMark	libs/imgui/imgui.h	/^    ImGuiCol_CheckMark,$/;"	e	enum:ImGuiCol_
ImGuiCol_ChildWindowBg	libs/imgui/imgui.h	/^    ImGuiCol_ChildWindowBg,$/;"	e	enum:ImGuiCol_
ImGuiCol_CloseButton	libs/imgui/imgui.h	/^    ImGuiCol_CloseButton,$/;"	e	enum:ImGuiCol_
ImGuiCol_CloseButtonActive	libs/imgui/imgui.h	/^    ImGuiCol_CloseButtonActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_CloseButtonHovered	libs/imgui/imgui.h	/^    ImGuiCol_CloseButtonHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_Column	libs/imgui/imgui.h	/^    ImGuiCol_Column,$/;"	e	enum:ImGuiCol_
ImGuiCol_ColumnActive	libs/imgui/imgui.h	/^    ImGuiCol_ColumnActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_ColumnHovered	libs/imgui/imgui.h	/^    ImGuiCol_ColumnHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_ComboBg	libs/imgui/imgui.h	/^    ImGuiCol_ComboBg,$/;"	e	enum:ImGuiCol_
ImGuiCol_FrameBg	libs/imgui/imgui.h	/^    ImGuiCol_FrameBg,               \/\/ Background of checkbox, radio button, plot, slider, text input$/;"	e	enum:ImGuiCol_
ImGuiCol_FrameBgActive	libs/imgui/imgui.h	/^    ImGuiCol_FrameBgActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_FrameBgHovered	libs/imgui/imgui.h	/^    ImGuiCol_FrameBgHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_Header	libs/imgui/imgui.h	/^    ImGuiCol_Header,$/;"	e	enum:ImGuiCol_
ImGuiCol_HeaderActive	libs/imgui/imgui.h	/^    ImGuiCol_HeaderActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_HeaderHovered	libs/imgui/imgui.h	/^    ImGuiCol_HeaderHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_MenuBarBg	libs/imgui/imgui.h	/^    ImGuiCol_MenuBarBg,$/;"	e	enum:ImGuiCol_
ImGuiCol_ModalWindowDarkening	libs/imgui/imgui.h	/^    ImGuiCol_ModalWindowDarkening,  \/\/ darken entire screen when a modal window is active$/;"	e	enum:ImGuiCol_
ImGuiCol_PlotHistogram	libs/imgui/imgui.h	/^    ImGuiCol_PlotHistogram,$/;"	e	enum:ImGuiCol_
ImGuiCol_PlotHistogramHovered	libs/imgui/imgui.h	/^    ImGuiCol_PlotHistogramHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_PlotLines	libs/imgui/imgui.h	/^    ImGuiCol_PlotLines,$/;"	e	enum:ImGuiCol_
ImGuiCol_PlotLinesHovered	libs/imgui/imgui.h	/^    ImGuiCol_PlotLinesHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_ResizeGrip	libs/imgui/imgui.h	/^    ImGuiCol_ResizeGrip,$/;"	e	enum:ImGuiCol_
ImGuiCol_ResizeGripActive	libs/imgui/imgui.h	/^    ImGuiCol_ResizeGripActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_ResizeGripHovered	libs/imgui/imgui.h	/^    ImGuiCol_ResizeGripHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_ScrollbarBg	libs/imgui/imgui.h	/^    ImGuiCol_ScrollbarBg,$/;"	e	enum:ImGuiCol_
ImGuiCol_ScrollbarGrab	libs/imgui/imgui.h	/^    ImGuiCol_ScrollbarGrab,$/;"	e	enum:ImGuiCol_
ImGuiCol_ScrollbarGrabActive	libs/imgui/imgui.h	/^    ImGuiCol_ScrollbarGrabActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_ScrollbarGrabHovered	libs/imgui/imgui.h	/^    ImGuiCol_ScrollbarGrabHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_SliderGrab	libs/imgui/imgui.h	/^    ImGuiCol_SliderGrab,$/;"	e	enum:ImGuiCol_
ImGuiCol_SliderGrabActive	libs/imgui/imgui.h	/^    ImGuiCol_SliderGrabActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_Text	libs/imgui/imgui.h	/^    ImGuiCol_Text,$/;"	e	enum:ImGuiCol_
ImGuiCol_TextDisabled	libs/imgui/imgui.h	/^    ImGuiCol_TextDisabled,$/;"	e	enum:ImGuiCol_
ImGuiCol_TextSelectedBg	libs/imgui/imgui.h	/^    ImGuiCol_TextSelectedBg,$/;"	e	enum:ImGuiCol_
ImGuiCol_TitleBg	libs/imgui/imgui.h	/^    ImGuiCol_TitleBg,$/;"	e	enum:ImGuiCol_
ImGuiCol_TitleBgActive	libs/imgui/imgui.h	/^    ImGuiCol_TitleBgActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_TitleBgCollapsed	libs/imgui/imgui.h	/^    ImGuiCol_TitleBgCollapsed,$/;"	e	enum:ImGuiCol_
ImGuiCol_TooltipBg	libs/imgui/imgui.h	/^    ImGuiCol_TooltipBg,$/;"	e	enum:ImGuiCol_
ImGuiCol_WindowBg	libs/imgui/imgui.h	/^    ImGuiCol_WindowBg,$/;"	e	enum:ImGuiCol_
ImGuiColorEditMode	libs/imgui/imgui.h	/^typedef int ImGuiColorEditMode;     \/\/ enum ImGuiColorEditMode_$/;"	t
ImGuiColorEditMode_	libs/imgui/imgui.h	/^enum ImGuiColorEditMode_$/;"	g
ImGuiColorEditMode_HEX	libs/imgui/imgui.h	/^    ImGuiColorEditMode_HEX = 2$/;"	e	enum:ImGuiColorEditMode_
ImGuiColorEditMode_HSV	libs/imgui/imgui.h	/^    ImGuiColorEditMode_HSV = 1,$/;"	e	enum:ImGuiColorEditMode_
ImGuiColorEditMode_RGB	libs/imgui/imgui.h	/^    ImGuiColorEditMode_RGB = 0,$/;"	e	enum:ImGuiColorEditMode_
ImGuiColorEditMode_UserSelect	libs/imgui/imgui.h	/^    ImGuiColorEditMode_UserSelect = -2,$/;"	e	enum:ImGuiColorEditMode_
ImGuiColorEditMode_UserSelectShowButton	libs/imgui/imgui.h	/^    ImGuiColorEditMode_UserSelectShowButton = -1,$/;"	e	enum:ImGuiColorEditMode_
ImGuiDrawContext	libs/imgui/imgui.cpp	/^    ImGuiDrawContext()$/;"	f	struct:ImGuiDrawContext	access:public	signature:()
ImGuiDrawContext	libs/imgui/imgui.cpp	/^struct ImGuiDrawContext$/;"	s	file:
ImGuiDrawContext::AllowKeyboardFocus	libs/imgui/imgui.cpp	/^    bool                    AllowKeyboardFocus;     \/\/ == AllowKeyboardFocusStack.back() [empty == true]$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::AllowKeyboardFocusStack	libs/imgui/imgui.cpp	/^    ImVector<bool>          AllowKeyboardFocusStack;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::ButtonRepeat	libs/imgui/imgui.cpp	/^    bool                    ButtonRepeat;           \/\/ == ButtonRepeatStack.back() [empty == false]$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::ButtonRepeatStack	libs/imgui/imgui.cpp	/^    ImVector<bool>          ButtonRepeatStack;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::ChildWindows	libs/imgui/imgui.cpp	/^    ImVector<ImGuiWindow*>  ChildWindows;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::ColorEditMode	libs/imgui/imgui.cpp	/^    ImGuiColorEditMode      ColorEditMode;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::ColumnsCellMaxY	libs/imgui/imgui.cpp	/^    float                   ColumnsCellMaxY;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::ColumnsCellMinY	libs/imgui/imgui.cpp	/^    float                   ColumnsCellMinY;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::ColumnsCount	libs/imgui/imgui.cpp	/^    int                     ColumnsCount;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::ColumnsCurrent	libs/imgui/imgui.cpp	/^    int                     ColumnsCurrent;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::ColumnsOffsetX	libs/imgui/imgui.cpp	/^    float                   ColumnsOffsetX;         \/\/ Offset to the current column (if ColumnsCurrent > 0). FIXME: This and the above should be a stack to allow use cases like Tree->Column->Tree. Need revamp columns API.$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::ColumnsOffsetsT	libs/imgui/imgui.cpp	/^    ImVector<float>         ColumnsOffsetsT;        \/\/ Columns offset normalized 0.0 (far left) -> 1.0 (far right)$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::ColumnsSetID	libs/imgui/imgui.cpp	/^    ImGuiID                 ColumnsSetID;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::ColumnsShowBorders	libs/imgui/imgui.cpp	/^    bool                    ColumnsShowBorders;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::ColumnsStartPos	libs/imgui/imgui.cpp	/^    ImVec2                  ColumnsStartPos;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::ColumnsStartX	libs/imgui/imgui.cpp	/^    float                   ColumnsStartX;          \/\/ Indentation \/ start position from left of window (increased by TreePush\/TreePop, etc.)$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::CurrentLineHeight	libs/imgui/imgui.cpp	/^    float                   CurrentLineHeight;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::CurrentLineTextBaseOffset	libs/imgui/imgui.cpp	/^    float                   CurrentLineTextBaseOffset;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::CursorMaxPos	libs/imgui/imgui.cpp	/^    ImVec2                  CursorMaxPos;           \/\/ Implicitly calculate the size of our contents, always extending. Saved into window->SizeContents at the end of the frame$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::CursorPos	libs/imgui/imgui.cpp	/^    ImVec2                  CursorPos;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::CursorPosPrevLine	libs/imgui/imgui.cpp	/^    ImVec2                  CursorPosPrevLine;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::CursorStartPos	libs/imgui/imgui.cpp	/^    ImVec2                  CursorStartPos;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::GroupStack	libs/imgui/imgui.cpp	/^    ImVector<ImGuiGroupData>GroupStack;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::ImGuiDrawContext	libs/imgui/imgui.cpp	/^    ImGuiDrawContext()$/;"	f	struct:ImGuiDrawContext	access:public	signature:()
ImGuiDrawContext::ItemWidth	libs/imgui/imgui.cpp	/^    float                   ItemWidth;              \/\/ == ItemWidthStack.back(). 0.0: default, >0.0: width in pixels, <0.0: align xx pixels to the right of window$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::ItemWidthStack	libs/imgui/imgui.cpp	/^    ImVector<float>         ItemWidthStack;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::LastItemHoveredAndUsable	libs/imgui/imgui.cpp	/^    bool                    LastItemHoveredAndUsable;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::LastItemHoveredRect	libs/imgui/imgui.cpp	/^    bool                    LastItemHoveredRect;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::LastItemID	libs/imgui/imgui.cpp	/^    ImGuiID                 LastItemID;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::LastItemRect	libs/imgui/imgui.cpp	/^    ImRect                  LastItemRect;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::LayoutType	libs/imgui/imgui.cpp	/^    ImGuiLayoutType         LayoutType;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::LogLinePosY	libs/imgui/imgui.cpp	/^    float                   LogLinePosY;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::MenuBarAppending	libs/imgui/imgui.cpp	/^    bool                    MenuBarAppending;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::MenuBarOffsetX	libs/imgui/imgui.cpp	/^    float                   MenuBarOffsetX;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::PrevLineHeight	libs/imgui/imgui.cpp	/^    float                   PrevLineHeight;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::PrevLineTextBaseOffset	libs/imgui/imgui.cpp	/^    float                   PrevLineTextBaseOffset;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::StackSizesBackup	libs/imgui/imgui.cpp	/^    int                     StackSizesBackup[6];    \/\/ Store size of various stacks for asserting$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::StateStorage	libs/imgui/imgui.cpp	/^    ImGuiStorage*           StateStorage;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::TextWrapPos	libs/imgui/imgui.cpp	/^    float                   TextWrapPos;            \/\/ == TextWrapPosStack.back() [empty == -1.0f]$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::TextWrapPosStack	libs/imgui/imgui.cpp	/^    ImVector<float>         TextWrapPosStack;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiDrawContext::TreeDepth	libs/imgui/imgui.cpp	/^    int                     TreeDepth;$/;"	m	struct:ImGuiDrawContext	file:	access:public
ImGuiGroupData	libs/imgui/imgui.cpp	/^struct ImGuiGroupData$/;"	s	file:
ImGuiGroupData::AdvanceCursor	libs/imgui/imgui.cpp	/^    bool   AdvanceCursor;$/;"	m	struct:ImGuiGroupData	file:	access:public
ImGuiGroupData::BackupColumnsStartX	libs/imgui/imgui.cpp	/^    float  BackupColumnsStartX;$/;"	m	struct:ImGuiGroupData	file:	access:public
ImGuiGroupData::BackupCurrentLineHeight	libs/imgui/imgui.cpp	/^    float  BackupCurrentLineHeight;$/;"	m	struct:ImGuiGroupData	file:	access:public
ImGuiGroupData::BackupCurrentLineTextBaseOffset	libs/imgui/imgui.cpp	/^    float  BackupCurrentLineTextBaseOffset;$/;"	m	struct:ImGuiGroupData	file:	access:public
ImGuiGroupData::BackupCursorMaxPos	libs/imgui/imgui.cpp	/^    ImVec2 BackupCursorMaxPos;$/;"	m	struct:ImGuiGroupData	file:	access:public
ImGuiGroupData::BackupCursorPos	libs/imgui/imgui.cpp	/^    ImVec2 BackupCursorPos;$/;"	m	struct:ImGuiGroupData	file:	access:public
ImGuiGroupData::BackupLogLinePosY	libs/imgui/imgui.cpp	/^    float  BackupLogLinePosY;$/;"	m	struct:ImGuiGroupData	file:	access:public
ImGuiID	libs/imgui/imgui.h	/^typedef ImU32 ImGuiID;              \/\/ unique ID used by widgets (typically hashed from a stack of string)$/;"	t
ImGuiIO	libs/imgui/imgui.cpp	/^ImGuiIO::ImGuiIO()$/;"	f	class:ImGuiIO	signature:()
ImGuiIO	libs/imgui/imgui.h	/^    IMGUI_API   ImGuiIO();$/;"	p	struct:ImGuiIO	access:public	signature:()
ImGuiIO	libs/imgui/imgui.h	/^struct ImGuiIO$/;"	s
ImGuiIO::AddInputCharacter	libs/imgui/imgui.cpp	/^void ImGuiIO::AddInputCharacter(ImWchar c)$/;"	f	class:ImGuiIO	signature:(ImWchar c)
ImGuiIO::AddInputCharacter	libs/imgui/imgui.h	/^    IMGUI_API void AddInputCharacter(ImWchar c);                    \/\/ Helper to add a new character into InputCharacters[]$/;"	p	struct:ImGuiIO	access:public	signature:(ImWchar c)
ImGuiIO::AddInputCharactersUTF8	libs/imgui/imgui.cpp	/^void ImGuiIO::AddInputCharactersUTF8(const char* utf8_chars)$/;"	f	class:ImGuiIO	signature:(const char* utf8_chars)
ImGuiIO::AddInputCharactersUTF8	libs/imgui/imgui.h	/^    IMGUI_API void AddInputCharactersUTF8(const char* utf8_chars);  \/\/ Helper to add new characters into InputCharacters[] from an UTF-8 string$/;"	p	struct:ImGuiIO	access:public	signature:(const char* utf8_chars)
ImGuiIO::DeltaTime	libs/imgui/imgui.h	/^    float         DeltaTime;                \/\/ = 1.0f\/60.0f         \/\/ Time elapsed since last frame, in seconds.$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::DisplaySize	libs/imgui/imgui.h	/^    ImVec2        DisplaySize;              \/\/ <unset>              \/\/ Display size, in pixels. For clamping windows positions.$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::DisplayVisibleMax	libs/imgui/imgui.h	/^    ImVec2        DisplayVisibleMax;        \/\/ <unset> (0.0f,0.0f)  \/\/ If the values are the same, we defaults to Min=(0.0f) and Max=DisplaySize$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::DisplayVisibleMin	libs/imgui/imgui.h	/^    ImVec2        DisplayVisibleMin;        \/\/ <unset> (0.0f,0.0f)  \/\/ If you use DisplaySize as a virtual space larger than your screen, set DisplayVisibleMin\/Max to the visible area.$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::FontAllowUserScaling	libs/imgui/imgui.h	/^    bool          FontAllowUserScaling;     \/\/ = false              \/\/ Allow user scaling text of individual window with CTRL+Wheel.$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::FontGlobalScale	libs/imgui/imgui.h	/^    float         FontGlobalScale;          \/\/ = 1.0f               \/\/ Global scale all fonts$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::Fonts	libs/imgui/imgui.h	/^    ImFontAtlas*  Fonts;                    \/\/ <auto>               \/\/ Load and assemble one or more fonts into a single tightly packed texture. Output to Fonts array.$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::Framerate	libs/imgui/imgui.h	/^    float       Framerate;                  \/\/ Framerate estimation, in frame per second. Rolling average estimation based on IO.DeltaTime over 120 frames$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::GetClipboardTextFn	libs/imgui/imgui.h	/^    const char* (*GetClipboardTextFn)();$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::ImGuiIO	libs/imgui/imgui.cpp	/^ImGuiIO::ImGuiIO()$/;"	f	class:ImGuiIO	signature:()
ImGuiIO::ImGuiIO	libs/imgui/imgui.h	/^    IMGUI_API   ImGuiIO();$/;"	p	struct:ImGuiIO	access:public	signature:()
ImGuiIO::ImeSetInputScreenPosFn	libs/imgui/imgui.h	/^    void        (*ImeSetInputScreenPosFn)(int x, int y);$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::ImeWindowHandle	libs/imgui/imgui.h	/^    void*       ImeWindowHandle;            \/\/ (Windows) Set this to your HWND to get automatic IME cursor positioning.$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::IniFilename	libs/imgui/imgui.h	/^    const char*   IniFilename;              \/\/ = "imgui.ini"        \/\/ Path to .ini file. NULL to disable .ini saving.$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::IniSavingRate	libs/imgui/imgui.h	/^    float         IniSavingRate;            \/\/ = 5.0f               \/\/ Maximum time between saving positions\/sizes to .ini file, in seconds.$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::InputCharacters	libs/imgui/imgui.h	/^    ImWchar     InputCharacters[16+1];      \/\/ List of characters input (translated by user from keypress+keyboard state). Fill using AddInputCharacter() helper.$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::KeyAlt	libs/imgui/imgui.h	/^    bool        KeyAlt;                     \/\/ Keyboard modifier pressed: Alt$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::KeyCtrl	libs/imgui/imgui.h	/^    bool        KeyCtrl;                    \/\/ Keyboard modifier pressed: Control$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::KeyMap	libs/imgui/imgui.h	/^    int           KeyMap[ImGuiKey_COUNT];   \/\/ <unset>              \/\/ Map of indices into the KeysDown[512] entries array$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::KeyRepeatDelay	libs/imgui/imgui.h	/^    float         KeyRepeatDelay;           \/\/ = 0.250f             \/\/ When holding a key\/button, time before it starts repeating, in seconds. (for actions where 'repeat' is active)$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::KeyRepeatRate	libs/imgui/imgui.h	/^    float         KeyRepeatRate;            \/\/ = 0.020f             \/\/ When holding a key\/button, rate at which it repeats, in seconds.$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::KeyShift	libs/imgui/imgui.h	/^    bool        KeyShift;                   \/\/ Keyboard modifier pressed: Shift$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::KeysDown	libs/imgui/imgui.h	/^    bool        KeysDown[512];              \/\/ Keyboard keys that are pressed (in whatever storage order you naturally have access to keyboard data)$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::KeysDownDuration	libs/imgui/imgui.h	/^    float       KeysDownDuration[512];      \/\/ Duration the keyboard key has been down (0.0f == just pressed)$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::KeysDownDurationPrev	libs/imgui/imgui.h	/^    float       KeysDownDurationPrev[512];  \/\/ Previous duration the key has been down$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::LogFilename	libs/imgui/imgui.h	/^    const char*   LogFilename;              \/\/ = "imgui_log.txt"    \/\/ Path to .log file (default parameter to ImGui::LogToFile when no file is specified).$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MemAllocFn	libs/imgui/imgui.h	/^    void*       (*MemAllocFn)(size_t sz);$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MemFreeFn	libs/imgui/imgui.h	/^    void        (*MemFreeFn)(void* ptr);$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MetricsActiveWindows	libs/imgui/imgui.h	/^    int         MetricsActiveWindows;       \/\/ Number of visible windows (exclude child windows)$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MetricsAllocs	libs/imgui/imgui.h	/^    int         MetricsAllocs;              \/\/ Number of active memory allocations$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MetricsRenderIndices	libs/imgui/imgui.h	/^    int         MetricsRenderIndices;       \/\/ $/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MetricsRenderVertices	libs/imgui/imgui.h	/^    int         MetricsRenderVertices;      \/\/ Vertices processed during last call to Render()$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MouseClicked	libs/imgui/imgui.h	/^    bool        MouseClicked[5];            \/\/ Mouse button went from !Down to Down$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MouseClickedPos	libs/imgui/imgui.h	/^    ImVec2      MouseClickedPos[5];         \/\/ Position at time of clicking$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MouseClickedTime	libs/imgui/imgui.h	/^    float       MouseClickedTime[5];        \/\/ Time of last click (used to figure out double-click)$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MouseDelta	libs/imgui/imgui.h	/^    ImVec2      MouseDelta;                 \/\/ Mouse delta. Note that this is zero if either current or previous position are negative to allow mouse enabling\/disabling.$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MouseDoubleClickMaxDist	libs/imgui/imgui.h	/^    float         MouseDoubleClickMaxDist;  \/\/ = 6.0f               \/\/ Distance threshold to stay in to validate a double-click, in pixels.$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MouseDoubleClickTime	libs/imgui/imgui.h	/^    float         MouseDoubleClickTime;     \/\/ = 0.30f              \/\/ Time for a double-click, in seconds.$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MouseDoubleClicked	libs/imgui/imgui.h	/^    bool        MouseDoubleClicked[5];      \/\/ Has mouse button been double-clicked?$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MouseDown	libs/imgui/imgui.h	/^    bool        MouseDown[5];               \/\/ Mouse buttons. ImGui itself only uses button 0 (left button). Others buttons allows to track if mouse is being used by your application + available to user as a convenience via IsMouse** API.$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MouseDownDuration	libs/imgui/imgui.h	/^    float       MouseDownDuration[5];       \/\/ Duration the mouse button has been down (0.0f == just clicked)$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MouseDownDurationPrev	libs/imgui/imgui.h	/^    float       MouseDownDurationPrev[5];   \/\/ Previous time the mouse button has been down$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MouseDownOwned	libs/imgui/imgui.h	/^    bool        MouseDownOwned[5];          \/\/ Track if button was clicked inside a window. We don't request mouse capture from the application if click started outside ImGui bounds.$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MouseDragMaxDistanceSqr	libs/imgui/imgui.h	/^    float       MouseDragMaxDistanceSqr[5]; \/\/ Squared maximum distance of how much mouse has traveled from the click point$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MouseDragThreshold	libs/imgui/imgui.h	/^    float         MouseDragThreshold;       \/\/ = 6.0f               \/\/ Distance threshold before considering we are dragging$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MouseDrawCursor	libs/imgui/imgui.h	/^    bool        MouseDrawCursor;            \/\/ Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor).$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MousePos	libs/imgui/imgui.h	/^    ImVec2      MousePos;                   \/\/ Mouse position, in pixels (set to -1,-1 if no mouse \/ on another screen, etc.)$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MousePosPrev	libs/imgui/imgui.h	/^    ImVec2      MousePosPrev;               \/\/ Previous mouse position$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MouseReleased	libs/imgui/imgui.h	/^    bool        MouseReleased[5];           \/\/ Mouse button went from Down to !Down$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MouseWheel	libs/imgui/imgui.h	/^    float       MouseWheel;                 \/\/ Mouse wheel: 1 unit scrolls about 5 lines text. $/;"	m	struct:ImGuiIO	access:public
ImGuiIO::RenderDrawListsFn	libs/imgui/imgui.h	/^    void        (*RenderDrawListsFn)(ImDrawData* data);      $/;"	m	struct:ImGuiIO	access:public
ImGuiIO::SetClipboardTextFn	libs/imgui/imgui.h	/^    void        (*SetClipboardTextFn)(const char* text);$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::UserData	libs/imgui/imgui.h	/^    void*         UserData;                 \/\/ = NULL               \/\/ Store your own data for retrieval by callbacks.$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::WantCaptureKeyboard	libs/imgui/imgui.h	/^    bool        WantCaptureKeyboard;        \/\/ Widget is active (= ImGui will use your keyboard input)$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::WantCaptureMouse	libs/imgui/imgui.h	/^    bool        WantCaptureMouse;           \/\/ Mouse is hovering a window or widget is active (= ImGui will use your mouse input)$/;"	m	struct:ImGuiIO	access:public
ImGuiIniData	libs/imgui/imgui.cpp	/^struct ImGuiIniData$/;"	s	file:
ImGuiIniData::Collapsed	libs/imgui/imgui.cpp	/^    bool    Collapsed;$/;"	m	struct:ImGuiIniData	file:	access:public
ImGuiIniData::ID	libs/imgui/imgui.cpp	/^    ImGuiID ID;$/;"	m	struct:ImGuiIniData	file:	access:public
ImGuiIniData::Name	libs/imgui/imgui.cpp	/^    char*   Name;$/;"	m	struct:ImGuiIniData	file:	access:public
ImGuiIniData::Pos	libs/imgui/imgui.cpp	/^    ImVec2  Pos;$/;"	m	struct:ImGuiIniData	file:	access:public
ImGuiIniData::Size	libs/imgui/imgui.cpp	/^    ImVec2  Size;$/;"	m	struct:ImGuiIniData	file:	access:public
ImGuiInputTextFlags	libs/imgui/imgui.h	/^typedef int ImGuiInputTextFlags;    \/\/ enum ImGuiInputTextFlags_$/;"	t
ImGuiInputTextFlags_	libs/imgui/imgui.h	/^enum ImGuiInputTextFlags_$/;"	g
ImGuiInputTextFlags_AllowTabInput	libs/imgui/imgui.h	/^    ImGuiInputTextFlags_AllowTabInput       = 1 << 10,  \/\/ Pressing TAB input a '\\t' character into the text field$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_AlwaysInsertMode	libs/imgui/imgui.h	/^    ImGuiInputTextFlags_AlwaysInsertMode    = 1 << 13,  \/\/ Insert mode$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_AutoSelectAll	libs/imgui/imgui.h	/^    ImGuiInputTextFlags_AutoSelectAll       = 1 << 4,   \/\/ Select entire text when first taking mouse focus$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CallbackAlways	libs/imgui/imgui.h	/^    ImGuiInputTextFlags_CallbackAlways      = 1 << 8,   \/\/ Call user function every time$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CallbackCharFilter	libs/imgui/imgui.h	/^    ImGuiInputTextFlags_CallbackCharFilter  = 1 << 9,   \/\/ Call user function to filter character. Modify data->EventChar to replace\/filter input, or return 1 to discard character.$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CallbackCompletion	libs/imgui/imgui.h	/^    ImGuiInputTextFlags_CallbackCompletion  = 1 << 6,   \/\/ Call user function on pressing TAB (for completion handling)$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CallbackHistory	libs/imgui/imgui.h	/^    ImGuiInputTextFlags_CallbackHistory     = 1 << 7,   \/\/ Call user function on pressing Up\/Down arrows (for history handling)$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CharsDecimal	libs/imgui/imgui.h	/^    ImGuiInputTextFlags_CharsDecimal        = 1 << 0,   \/\/ Allow 0123456789.+-*\/$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CharsHexadecimal	libs/imgui/imgui.h	/^    ImGuiInputTextFlags_CharsHexadecimal    = 1 << 1,   \/\/ Allow 0123456789ABCDEFabcdef$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CharsNoBlank	libs/imgui/imgui.h	/^    ImGuiInputTextFlags_CharsNoBlank        = 1 << 3,   \/\/ Filter out spaces, tabs$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CharsUppercase	libs/imgui/imgui.h	/^    ImGuiInputTextFlags_CharsUppercase      = 1 << 2,   \/\/ Turn a..z into A..Z$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CtrlEnterForNewLine	libs/imgui/imgui.h	/^    ImGuiInputTextFlags_CtrlEnterForNewLine = 1 << 11,  \/\/ In multi-line mode, allow exiting edition by pressing Enter. Ctrl+Enter to add new line (by default adds new lines with Enter).$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_EnterReturnsTrue	libs/imgui/imgui.h	/^    ImGuiInputTextFlags_EnterReturnsTrue    = 1 << 5,   \/\/ Return 'true' when Enter is pressed (as opposed to when the value was modified)$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_Multiline	libs/imgui/imgui.h	/^    ImGuiInputTextFlags_Multiline           = 1 << 20   \/\/ For internal use by InputTextMultiline()$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_NoHorizontalScroll	libs/imgui/imgui.h	/^    ImGuiInputTextFlags_NoHorizontalScroll  = 1 << 12,  \/\/ Disable following the cursor horizontally$/;"	e	enum:ImGuiInputTextFlags_
ImGuiKey	libs/imgui/imgui.h	/^typedef int ImGuiKey;               \/\/ enum ImGuiKey_$/;"	t
ImGuiKey_	libs/imgui/imgui.h	/^enum ImGuiKey_$/;"	g
ImGuiKey_A	libs/imgui/imgui.h	/^    ImGuiKey_A,         \/\/ for text edit CTRL+A: select all$/;"	e	enum:ImGuiKey_
ImGuiKey_Backspace	libs/imgui/imgui.h	/^    ImGuiKey_Backspace, \/\/ for text edit$/;"	e	enum:ImGuiKey_
ImGuiKey_C	libs/imgui/imgui.h	/^    ImGuiKey_C,         \/\/ for text edit CTRL+C: copy$/;"	e	enum:ImGuiKey_
ImGuiKey_COUNT	libs/imgui/imgui.h	/^    ImGuiKey_COUNT$/;"	e	enum:ImGuiKey_
ImGuiKey_Delete	libs/imgui/imgui.h	/^    ImGuiKey_Delete,    \/\/ for text edit$/;"	e	enum:ImGuiKey_
ImGuiKey_DownArrow	libs/imgui/imgui.h	/^    ImGuiKey_DownArrow, \/\/ for text edit$/;"	e	enum:ImGuiKey_
ImGuiKey_End	libs/imgui/imgui.h	/^    ImGuiKey_End,       \/\/ for text edit$/;"	e	enum:ImGuiKey_
ImGuiKey_Enter	libs/imgui/imgui.h	/^    ImGuiKey_Enter,     \/\/ for text edit$/;"	e	enum:ImGuiKey_
ImGuiKey_Escape	libs/imgui/imgui.h	/^    ImGuiKey_Escape,    \/\/ for text edit$/;"	e	enum:ImGuiKey_
ImGuiKey_Home	libs/imgui/imgui.h	/^    ImGuiKey_Home,      \/\/ for text edit$/;"	e	enum:ImGuiKey_
ImGuiKey_LeftArrow	libs/imgui/imgui.h	/^    ImGuiKey_LeftArrow, \/\/ for text edit$/;"	e	enum:ImGuiKey_
ImGuiKey_PageDown	libs/imgui/imgui.h	/^    ImGuiKey_PageDown,$/;"	e	enum:ImGuiKey_
ImGuiKey_PageUp	libs/imgui/imgui.h	/^    ImGuiKey_PageUp,$/;"	e	enum:ImGuiKey_
ImGuiKey_RightArrow	libs/imgui/imgui.h	/^    ImGuiKey_RightArrow,\/\/ for text edit$/;"	e	enum:ImGuiKey_
ImGuiKey_Tab	libs/imgui/imgui.h	/^    ImGuiKey_Tab,       \/\/ for tabbing through fields$/;"	e	enum:ImGuiKey_
ImGuiKey_UpArrow	libs/imgui/imgui.h	/^    ImGuiKey_UpArrow,   \/\/ for text edit$/;"	e	enum:ImGuiKey_
ImGuiKey_V	libs/imgui/imgui.h	/^    ImGuiKey_V,         \/\/ for text edit CTRL+V: paste$/;"	e	enum:ImGuiKey_
ImGuiKey_X	libs/imgui/imgui.h	/^    ImGuiKey_X,         \/\/ for text edit CTRL+X: cut$/;"	e	enum:ImGuiKey_
ImGuiKey_Y	libs/imgui/imgui.h	/^    ImGuiKey_Y,         \/\/ for text edit CTRL+Y: redo$/;"	e	enum:ImGuiKey_
ImGuiKey_Z	libs/imgui/imgui.h	/^    ImGuiKey_Z,         \/\/ for text edit CTRL+Z: undo$/;"	e	enum:ImGuiKey_
ImGuiLayoutType	libs/imgui/imgui.cpp	/^typedef int ImGuiLayoutType;      \/\/ enum ImGuiLayoutType_$/;"	t	file:
ImGuiLayoutType_	libs/imgui/imgui.cpp	/^enum ImGuiLayoutType_$/;"	g	file:
ImGuiLayoutType_Horizontal	libs/imgui/imgui.cpp	/^    ImGuiLayoutType_Horizontal          \/\/ FIXME: this is in development, not exposed\/functional as a generic feature yet.$/;"	e	enum:ImGuiLayoutType_	file:
ImGuiLayoutType_Vertical	libs/imgui/imgui.cpp	/^    ImGuiLayoutType_Vertical,$/;"	e	enum:ImGuiLayoutType_	file:
ImGuiListClipper	libs/imgui/imgui.h	/^    ImGuiListClipper()                         { ItemsHeight = 0.0f; ItemsCount = DisplayStart = DisplayEnd = -1; }$/;"	f	struct:ImGuiListClipper	access:public	signature:()
ImGuiListClipper	libs/imgui/imgui.h	/^    ImGuiListClipper(int count, float height)  { ItemsCount = -1; Begin(count, height); }$/;"	f	struct:ImGuiListClipper	access:public	signature:(int count, float height)
ImGuiListClipper	libs/imgui/imgui.h	/^struct ImGuiListClipper$/;"	s
ImGuiListClipper::Begin	libs/imgui/imgui.h	/^    void Begin(int count, float height)        \/\/ items_height: generally pass GetTextLineHeightWithSpacing() or GetItemsLineHeightWithSpacing()$/;"	f	struct:ImGuiListClipper	access:public	signature:(int count, float height)
ImGuiListClipper::DisplayEnd	libs/imgui/imgui.h	/^    int ItemsCount, DisplayStart, DisplayEnd;$/;"	m	struct:ImGuiListClipper	access:public
ImGuiListClipper::DisplayStart	libs/imgui/imgui.h	/^    int ItemsCount, DisplayStart, DisplayEnd;$/;"	m	struct:ImGuiListClipper	access:public
ImGuiListClipper::End	libs/imgui/imgui.h	/^    void End()$/;"	f	struct:ImGuiListClipper	access:public	signature:()
ImGuiListClipper::ImGuiListClipper	libs/imgui/imgui.h	/^    ImGuiListClipper()                         { ItemsHeight = 0.0f; ItemsCount = DisplayStart = DisplayEnd = -1; }$/;"	f	struct:ImGuiListClipper	access:public	signature:()
ImGuiListClipper::ImGuiListClipper	libs/imgui/imgui.h	/^    ImGuiListClipper(int count, float height)  { ItemsCount = -1; Begin(count, height); }$/;"	f	struct:ImGuiListClipper	access:public	signature:(int count, float height)
ImGuiListClipper::ItemsCount	libs/imgui/imgui.h	/^    int ItemsCount, DisplayStart, DisplayEnd;$/;"	m	struct:ImGuiListClipper	access:public
ImGuiListClipper::ItemsHeight	libs/imgui/imgui.h	/^    float ItemsHeight;$/;"	m	struct:ImGuiListClipper	access:public
ImGuiListClipper::~ImGuiListClipper	libs/imgui/imgui.h	/^    ~ImGuiListClipper()                        { IM_ASSERT(ItemsCount == -1); } \/\/ user forgot to call End()$/;"	f	struct:ImGuiListClipper	access:public	signature:()
ImGuiMouseCursor	libs/imgui/imgui.h	/^typedef int ImGuiMouseCursor;       \/\/ enum ImGuiMouseCursor_$/;"	t
ImGuiMouseCursorData	libs/imgui/imgui.cpp	/^struct ImGuiMouseCursorData$/;"	s	file:
ImGuiMouseCursorData::Offset	libs/imgui/imgui.cpp	/^    ImVec2              Offset;$/;"	m	struct:ImGuiMouseCursorData	file:	access:public
ImGuiMouseCursorData::Size	libs/imgui/imgui.cpp	/^    ImVec2              Size;$/;"	m	struct:ImGuiMouseCursorData	file:	access:public
ImGuiMouseCursorData::TexUvMax	libs/imgui/imgui.cpp	/^    ImVec2              TexUvMax[2];$/;"	m	struct:ImGuiMouseCursorData	file:	access:public
ImGuiMouseCursorData::TexUvMin	libs/imgui/imgui.cpp	/^    ImVec2              TexUvMin[2];$/;"	m	struct:ImGuiMouseCursorData	file:	access:public
ImGuiMouseCursorData::Type	libs/imgui/imgui.cpp	/^    ImGuiMouseCursor    Type;$/;"	m	struct:ImGuiMouseCursorData	file:	access:public
ImGuiMouseCursor_	libs/imgui/imgui.h	/^enum ImGuiMouseCursor_$/;"	g
ImGuiMouseCursor_Arrow	libs/imgui/imgui.h	/^    ImGuiMouseCursor_Arrow = 0,$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_Count_	libs/imgui/imgui.h	/^    ImGuiMouseCursor_Count_$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_Move	libs/imgui/imgui.h	/^    ImGuiMouseCursor_Move,              \/\/ Unused$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_ResizeEW	libs/imgui/imgui.h	/^    ImGuiMouseCursor_ResizeEW,          \/\/ When hovering over a column$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_ResizeNESW	libs/imgui/imgui.h	/^    ImGuiMouseCursor_ResizeNESW,        \/\/ Unused$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_ResizeNS	libs/imgui/imgui.h	/^    ImGuiMouseCursor_ResizeNS,          \/\/ Unused$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_ResizeNWSE	libs/imgui/imgui.h	/^    ImGuiMouseCursor_ResizeNWSE,        \/\/ When hovering over the bottom-right corner of a window$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_TextInput	libs/imgui/imgui.h	/^    ImGuiMouseCursor_TextInput,         \/\/ When hovering over InputText, etc.$/;"	e	enum:ImGuiMouseCursor_
ImGuiOnceUponAFrame	libs/imgui/imgui.h	/^    ImGuiOnceUponAFrame() { RefFrame = -1; }$/;"	f	struct:ImGuiOnceUponAFrame	access:public	signature:()
ImGuiOnceUponAFrame	libs/imgui/imgui.h	/^struct ImGuiOnceUponAFrame$/;"	s
ImGuiOnceUponAFrame::ImGuiOnceUponAFrame	libs/imgui/imgui.h	/^    ImGuiOnceUponAFrame() { RefFrame = -1; }$/;"	f	struct:ImGuiOnceUponAFrame	access:public	signature:()
ImGuiOnceUponAFrame::RefFrame	libs/imgui/imgui.h	/^    mutable int RefFrame;$/;"	m	struct:ImGuiOnceUponAFrame	access:public
ImGuiOnceUponAFrame::operator bool	libs/imgui/imgui.h	/^    operator bool() const { int current_frame = ImGui::GetFrameCount(); if (RefFrame == current_frame) return false; RefFrame = current_frame; return true; }$/;"	f	struct:ImGuiOnceUponAFrame	access:public	signature:() const
ImGuiPlotArrayGetterData	libs/imgui/imgui.cpp	/^    ImGuiPlotArrayGetterData(const float* values, int stride) { Values = values; Stride = stride; }$/;"	f	struct:ImGuiPlotArrayGetterData	access:public	signature:(const float* values, int stride)
ImGuiPlotArrayGetterData	libs/imgui/imgui.cpp	/^struct ImGuiPlotArrayGetterData$/;"	s	file:
ImGuiPlotArrayGetterData::ImGuiPlotArrayGetterData	libs/imgui/imgui.cpp	/^    ImGuiPlotArrayGetterData(const float* values, int stride) { Values = values; Stride = stride; }$/;"	f	struct:ImGuiPlotArrayGetterData	access:public	signature:(const float* values, int stride)
ImGuiPlotArrayGetterData::Stride	libs/imgui/imgui.cpp	/^    int Stride;$/;"	m	struct:ImGuiPlotArrayGetterData	file:	access:public
ImGuiPlotArrayGetterData::Values	libs/imgui/imgui.cpp	/^    const float* Values;$/;"	m	struct:ImGuiPlotArrayGetterData	file:	access:public
ImGuiPlotType	libs/imgui/imgui.cpp	/^enum ImGuiPlotType$/;"	g	file:
ImGuiPlotType_Histogram	libs/imgui/imgui.cpp	/^    ImGuiPlotType_Histogram$/;"	e	enum:ImGuiPlotType	file:
ImGuiPlotType_Lines	libs/imgui/imgui.cpp	/^    ImGuiPlotType_Lines,$/;"	e	enum:ImGuiPlotType	file:
ImGuiPopupRef	libs/imgui/imgui.cpp	/^    ImGuiPopupRef(ImGuiID id, ImGuiWindow* parent_window, ImGuiID parent_menu_set) { PopupID = id; Window = NULL; ParentWindow = parent_window; ParentMenuSet = parent_menu_set; }$/;"	f	struct:ImGuiPopupRef	access:public	signature:(ImGuiID id, ImGuiWindow* parent_window, ImGuiID parent_menu_set)
ImGuiPopupRef	libs/imgui/imgui.cpp	/^struct ImGuiPopupRef$/;"	s	file:
ImGuiPopupRef::ImGuiPopupRef	libs/imgui/imgui.cpp	/^    ImGuiPopupRef(ImGuiID id, ImGuiWindow* parent_window, ImGuiID parent_menu_set) { PopupID = id; Window = NULL; ParentWindow = parent_window; ParentMenuSet = parent_menu_set; }$/;"	f	struct:ImGuiPopupRef	access:public	signature:(ImGuiID id, ImGuiWindow* parent_window, ImGuiID parent_menu_set)
ImGuiPopupRef::ParentMenuSet	libs/imgui/imgui.cpp	/^    ImGuiID             ParentMenuSet;  \/\/ Set on OpenPopup()$/;"	m	struct:ImGuiPopupRef	file:	access:public
ImGuiPopupRef::ParentWindow	libs/imgui/imgui.cpp	/^    ImGuiWindow*        ParentWindow;   \/\/ Set on OpenPopup()$/;"	m	struct:ImGuiPopupRef	file:	access:public
ImGuiPopupRef::PopupID	libs/imgui/imgui.cpp	/^    ImGuiID             PopupID;        \/\/ Set on OpenPopup()$/;"	m	struct:ImGuiPopupRef	file:	access:public
ImGuiPopupRef::Window	libs/imgui/imgui.cpp	/^    ImGuiWindow*        Window;         \/\/ Resolved on BeginPopup() - may stay unresolved if user never calls OpenPopup()$/;"	m	struct:ImGuiPopupRef	file:	access:public
ImGuiSelectableFlags	libs/imgui/imgui.h	/^typedef int ImGuiSelectableFlags;   \/\/ enum ImGuiSelectableFlags_$/;"	t
ImGuiSelectableFlagsPrivate_	libs/imgui/imgui.cpp	/^enum ImGuiSelectableFlagsPrivate_$/;"	g	file:
ImGuiSelectableFlags_	libs/imgui/imgui.h	/^enum ImGuiSelectableFlags_$/;"	g
ImGuiSelectableFlags_Disabled	libs/imgui/imgui.cpp	/^    ImGuiSelectableFlags_Disabled           = 1 << 4,$/;"	e	enum:ImGuiSelectableFlagsPrivate_	file:
ImGuiSelectableFlags_DontClosePopups	libs/imgui/imgui.h	/^    ImGuiSelectableFlags_DontClosePopups    = 1 << 0,   \/\/ Clicking this don't close parent popup window$/;"	e	enum:ImGuiSelectableFlags_
ImGuiSelectableFlags_DrawFillAvailWidth	libs/imgui/imgui.cpp	/^    ImGuiSelectableFlags_DrawFillAvailWidth = 1 << 5$/;"	e	enum:ImGuiSelectableFlagsPrivate_	file:
ImGuiSelectableFlags_Menu	libs/imgui/imgui.cpp	/^    ImGuiSelectableFlags_Menu               = 1 << 2,$/;"	e	enum:ImGuiSelectableFlagsPrivate_	file:
ImGuiSelectableFlags_MenuItem	libs/imgui/imgui.cpp	/^    ImGuiSelectableFlags_MenuItem           = 1 << 3,$/;"	e	enum:ImGuiSelectableFlagsPrivate_	file:
ImGuiSelectableFlags_SpanAllColumns	libs/imgui/imgui.h	/^    ImGuiSelectableFlags_SpanAllColumns     = 1 << 1    \/\/ Selectable frame can span all columns (text will still fit in current column)$/;"	e	enum:ImGuiSelectableFlags_
ImGuiSetCond	libs/imgui/imgui.h	/^typedef int ImGuiSetCond;           \/\/ enum ImGuiSetCond_$/;"	t
ImGuiSetCond_	libs/imgui/imgui.h	/^enum ImGuiSetCond_$/;"	g
ImGuiSetCond_Always	libs/imgui/imgui.h	/^    ImGuiSetCond_Always        = 1 << 0, \/\/ Set the variable$/;"	e	enum:ImGuiSetCond_
ImGuiSetCond_Appearing	libs/imgui/imgui.h	/^    ImGuiSetCond_Appearing     = 1 << 3  \/\/ Only set the variable if the window is appearing after being inactive (or the first time)$/;"	e	enum:ImGuiSetCond_
ImGuiSetCond_FirstUseEver	libs/imgui/imgui.h	/^    ImGuiSetCond_FirstUseEver  = 1 << 2, \/\/ Only set the variable if the window doesn't exist in the .ini file$/;"	e	enum:ImGuiSetCond_
ImGuiSetCond_Once	libs/imgui/imgui.h	/^    ImGuiSetCond_Once          = 1 << 1, \/\/ Only set the variable on the first call per runtime session$/;"	e	enum:ImGuiSetCond_
ImGuiSimpleColumns	libs/imgui/imgui.cpp	/^    ImGuiSimpleColumns() { Count = 0; Spacing = 0.0f; Width = 0.0f; NextWidth = 0.0f; memset(Pos, 0, sizeof(Pos)); memset(NextWidths, 0, sizeof(NextWidths)); }$/;"	f	struct:ImGuiSimpleColumns	access:public	signature:()
ImGuiSimpleColumns	libs/imgui/imgui.cpp	/^struct ImGuiSimpleColumns$/;"	s	file:
ImGuiSimpleColumns::CalcExtraSpace	libs/imgui/imgui.cpp	/^    float CalcExtraSpace(float avail_w)$/;"	f	struct:ImGuiSimpleColumns	access:public	signature:(float avail_w)
ImGuiSimpleColumns::Count	libs/imgui/imgui.cpp	/^    int    Count;$/;"	m	struct:ImGuiSimpleColumns	file:	access:public
ImGuiSimpleColumns::DeclColumns	libs/imgui/imgui.cpp	/^    float DeclColumns(float w0, float w1, float w2) \/\/ not using va_arg because they promote float to double$/;"	f	struct:ImGuiSimpleColumns	access:public	signature:(float w0, float w1, float w2)
ImGuiSimpleColumns::ImGuiSimpleColumns	libs/imgui/imgui.cpp	/^    ImGuiSimpleColumns() { Count = 0; Spacing = 0.0f; Width = 0.0f; NextWidth = 0.0f; memset(Pos, 0, sizeof(Pos)); memset(NextWidths, 0, sizeof(NextWidths)); }$/;"	f	struct:ImGuiSimpleColumns	access:public	signature:()
ImGuiSimpleColumns::NextWidth	libs/imgui/imgui.cpp	/^    float  Width, NextWidth;$/;"	m	struct:ImGuiSimpleColumns	file:	access:public
ImGuiSimpleColumns::NextWidths	libs/imgui/imgui.cpp	/^    float  Pos[8], NextWidths[8];$/;"	m	struct:ImGuiSimpleColumns	file:	access:public
ImGuiSimpleColumns::Pos	libs/imgui/imgui.cpp	/^    float  Pos[8], NextWidths[8];$/;"	m	struct:ImGuiSimpleColumns	file:	access:public
ImGuiSimpleColumns::Spacing	libs/imgui/imgui.cpp	/^    float  Spacing;$/;"	m	struct:ImGuiSimpleColumns	file:	access:public
ImGuiSimpleColumns::Update	libs/imgui/imgui.cpp	/^    void Update(int count, float spacing, bool clear)$/;"	f	struct:ImGuiSimpleColumns	access:public	signature:(int count, float spacing, bool clear)
ImGuiSimpleColumns::Width	libs/imgui/imgui.cpp	/^    float  Width, NextWidth;$/;"	m	struct:ImGuiSimpleColumns	file:	access:public
ImGuiState	libs/imgui/imgui.cpp	/^    ImGuiState()$/;"	f	struct:ImGuiState	access:public	signature:()
ImGuiState	libs/imgui/imgui.cpp	/^struct ImGuiState$/;"	s	file:
ImGuiState::ActiveClickDeltaToCenter	libs/imgui/imgui.cpp	/^    ImVec2                  ActiveClickDeltaToCenter;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::ActiveId	libs/imgui/imgui.cpp	/^    ImGuiID                 ActiveId;                           \/\/ Active widget$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::ActiveIdIsAlive	libs/imgui/imgui.cpp	/^    bool                    ActiveIdIsAlive;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::ActiveIdIsFocusedOnly	libs/imgui/imgui.cpp	/^    bool                    ActiveIdIsFocusedOnly;              \/\/ Set only by active widget. Denote focus but no active interaction$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::ActiveIdIsJustActivated	libs/imgui/imgui.cpp	/^    bool                    ActiveIdIsJustActivated;            \/\/ Set at the time of activation for one frame$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::ActiveIdPreviousFrame	libs/imgui/imgui.cpp	/^    ImGuiID                 ActiveIdPreviousFrame;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::ActiveIdWindow	libs/imgui/imgui.cpp	/^    ImGuiWindow*            ActiveIdWindow;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::CaptureKeyboardNextFrame	libs/imgui/imgui.cpp	/^    bool                    CaptureKeyboardNextFrame;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::CaptureMouseNextFrame	libs/imgui/imgui.cpp	/^    bool                    CaptureMouseNextFrame;              \/\/ explicit capture via CaptureInputs() sets those flags$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::ColorEditModeStorage	libs/imgui/imgui.cpp	/^    ImGuiStorage            ColorEditModeStorage;               \/\/ Store user selection of color edit mode$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::ColorModifiers	libs/imgui/imgui.cpp	/^    ImVector<ImGuiColMod>   ColorModifiers;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::CurrentPopupStack	libs/imgui/imgui.cpp	/^    ImVector<ImGuiPopupRef> CurrentPopupStack;                  \/\/ Which level of BeginPopup() we are in (reset every frame)$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::CurrentWindow	libs/imgui/imgui.cpp	/^    ImGuiWindow*            CurrentWindow;                      \/\/ Being drawn into$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::CurrentWindowStack	libs/imgui/imgui.cpp	/^    ImVector<ImGuiWindow*>  CurrentWindowStack;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::DisableHideTextAfterDoubleHash	libs/imgui/imgui.cpp	/^    int                     DisableHideTextAfterDoubleHash;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::DragCurrentValue	libs/imgui/imgui.cpp	/^    float                   DragCurrentValue;                   \/\/ current dragged value, always float, not rounded by end-user precision settings$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::DragLastMouseDelta	libs/imgui/imgui.cpp	/^    ImVec2                  DragLastMouseDelta;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::DragSpeedDefaultRatio	libs/imgui/imgui.cpp	/^    float                   DragSpeedDefaultRatio;              \/\/ if speed == 0.0f, uses (max-min) * DragSpeedDefaultRatio$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::DragSpeedScaleFast	libs/imgui/imgui.cpp	/^    float                   DragSpeedScaleFast;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::DragSpeedScaleSlow	libs/imgui/imgui.cpp	/^    float                   DragSpeedScaleSlow;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::FocusedWindow	libs/imgui/imgui.cpp	/^    ImGuiWindow*            FocusedWindow;                      \/\/ Will catch keyboard inputs$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::Font	libs/imgui/imgui.cpp	/^    ImFont*                 Font;                               \/\/ (Shortcut) == FontStack.empty() ? IO.Font : FontStack.back()$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::FontBaseSize	libs/imgui/imgui.cpp	/^    float                   FontBaseSize;                       \/\/ (Shortcut) == IO.FontGlobalScale * Font->Scale * Font->FontSize. Size of characters.$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::FontSize	libs/imgui/imgui.cpp	/^    float                   FontSize;                           \/\/ (Shortcut) == FontBaseSize * g.CurrentWindow->FontWindowScale == window->FontSize()$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::FontStack	libs/imgui/imgui.cpp	/^    ImVector<ImFont*>       FontStack;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::FontTexUvWhitePixel	libs/imgui/imgui.cpp	/^    ImVec2                  FontTexUvWhitePixel;                \/\/ (Shortcut) == Font->TexUvForWhite$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::FrameCount	libs/imgui/imgui.cpp	/^    int                     FrameCount;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::FrameCountRendered	libs/imgui/imgui.cpp	/^    int                     FrameCountRendered;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::FramerateSecPerFrame	libs/imgui/imgui.cpp	/^    float                   FramerateSecPerFrame[120];          \/\/ calculate estimate of framerate for user$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::FramerateSecPerFrameAccum	libs/imgui/imgui.cpp	/^    float                   FramerateSecPerFrameAccum;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::FramerateSecPerFrameIdx	libs/imgui/imgui.cpp	/^    int                     FramerateSecPerFrameIdx;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::HoveredId	libs/imgui/imgui.cpp	/^    ImGuiID                 HoveredId;                          \/\/ Hovered widget$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::HoveredIdPreviousFrame	libs/imgui/imgui.cpp	/^    ImGuiID                 HoveredIdPreviousFrame;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::HoveredRootWindow	libs/imgui/imgui.cpp	/^    ImGuiWindow*            HoveredRootWindow;                  \/\/ Will catch mouse inputs (for focus\/move only)$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::HoveredWindow	libs/imgui/imgui.cpp	/^    ImGuiWindow*            HoveredWindow;                      \/\/ Will catch mouse inputs$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::IO	libs/imgui/imgui.cpp	/^    ImGuiIO                 IO;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::ImGuiState	libs/imgui/imgui.cpp	/^    ImGuiState()$/;"	f	struct:ImGuiState	access:public	signature:()
ImGuiState::Initialized	libs/imgui/imgui.cpp	/^    bool                    Initialized;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::InputTextState	libs/imgui/imgui.cpp	/^    ImGuiTextEditState      InputTextState;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::LogAutoExpandMaxDepth	libs/imgui/imgui.cpp	/^    int                     LogAutoExpandMaxDepth;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::LogClipboard	libs/imgui/imgui.cpp	/^    ImGuiTextBuffer*        LogClipboard;                       \/\/ pointer so our GImGui static constructor doesn't call heap allocators.$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::LogEnabled	libs/imgui/imgui.cpp	/^    bool                    LogEnabled;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::LogFile	libs/imgui/imgui.cpp	/^    FILE*                   LogFile;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::LogStartDepth	libs/imgui/imgui.cpp	/^    int                     LogStartDepth;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::ModalWindowDarkeningRatio	libs/imgui/imgui.cpp	/^    float                   ModalWindowDarkeningRatio;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::MouseCursor	libs/imgui/imgui.cpp	/^    ImGuiMouseCursor        MouseCursor;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::MouseCursorData	libs/imgui/imgui.cpp	/^    ImGuiMouseCursorData    MouseCursorData[ImGuiMouseCursor_Count_];$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::MovedWindow	libs/imgui/imgui.cpp	/^    ImGuiWindow*            MovedWindow;                        \/\/ Track the child window we clicked on to move a window. Pointer is only valid if ActiveID is the "#MOVE" identifier of a window.$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::OpenedPopupStack	libs/imgui/imgui.cpp	/^    ImVector<ImGuiPopupRef> OpenedPopupStack;                   \/\/ Which popups are open$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::OverlayDrawList	libs/imgui/imgui.cpp	/^    ImDrawList              OverlayDrawList;                    \/\/ Optional software render of mouse cursors, if io.MouseDrawCursor is set + a few debug overlays$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::PrivateClipboard	libs/imgui/imgui.cpp	/^    char*                   PrivateClipboard;                   \/\/ if no custom clipboard handler is defined$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::RenderDrawLists	libs/imgui/imgui.cpp	/^    ImVector<ImDrawList*>   RenderDrawLists[3];$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::ScalarAsInputTextId	libs/imgui/imgui.cpp	/^    ImGuiID                 ScalarAsInputTextId;                \/\/ Temporary text input when CTRL+clicking on a slider, etc.$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::ScrollbarClickDeltaToGrabCenter	libs/imgui/imgui.cpp	/^    float                   ScrollbarClickDeltaToGrabCenter;    \/\/ distance between mouse and center of grab box, normalized in parent space$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::SetNextTreeNodeOpenedCond	libs/imgui/imgui.cpp	/^    ImGuiSetCond            SetNextTreeNodeOpenedCond;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::SetNextTreeNodeOpenedVal	libs/imgui/imgui.cpp	/^    bool                    SetNextTreeNodeOpenedVal;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::SetNextWindowCollapsedCond	libs/imgui/imgui.cpp	/^    ImGuiSetCond            SetNextWindowCollapsedCond;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::SetNextWindowCollapsedVal	libs/imgui/imgui.cpp	/^    bool                    SetNextWindowCollapsedVal;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::SetNextWindowFocus	libs/imgui/imgui.cpp	/^    bool                    SetNextWindowFocus;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::SetNextWindowPosCond	libs/imgui/imgui.cpp	/^    ImGuiSetCond            SetNextWindowPosCond;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::SetNextWindowPosVal	libs/imgui/imgui.cpp	/^    ImVec2                  SetNextWindowPosVal;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::SetNextWindowSizeCond	libs/imgui/imgui.cpp	/^    ImGuiSetCond            SetNextWindowSizeCond;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::SetNextWindowSizeVal	libs/imgui/imgui.cpp	/^    ImVec2                  SetNextWindowSizeVal;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::Settings	libs/imgui/imgui.cpp	/^    ImVector<ImGuiIniData>  Settings;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::SettingsDirtyTimer	libs/imgui/imgui.cpp	/^    float                   SettingsDirtyTimer;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::Style	libs/imgui/imgui.cpp	/^    ImGuiStyle              Style;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::StyleModifiers	libs/imgui/imgui.cpp	/^    ImVector<ImGuiStyleMod> StyleModifiers;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::TempBuffer	libs/imgui/imgui.cpp	/^    char                    TempBuffer[1024*3+1];               \/\/ temporary text buffer$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::Time	libs/imgui/imgui.cpp	/^    float                   Time;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::Tooltip	libs/imgui/imgui.cpp	/^    char                    Tooltip[1024];$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::Windows	libs/imgui/imgui.cpp	/^    ImVector<ImGuiWindow*>  Windows;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiState::WindowsSortBuffer	libs/imgui/imgui.cpp	/^    ImVector<ImGuiWindow*>  WindowsSortBuffer;$/;"	m	struct:ImGuiState	file:	access:public
ImGuiStorage	libs/imgui/imgui.h	/^struct ImGuiStorage$/;"	s
ImGuiStorage::Clear	libs/imgui/imgui.cpp	/^void ImGuiStorage::Clear()$/;"	f	class:ImGuiStorage	signature:()
ImGuiStorage::Clear	libs/imgui/imgui.h	/^    IMGUI_API void    Clear();$/;"	p	struct:ImGuiStorage	access:public	signature:()
ImGuiStorage::Data	libs/imgui/imgui.h	/^    ImVector<Pair>    Data;$/;"	m	struct:ImGuiStorage	access:public
ImGuiStorage::GetFloat	libs/imgui/imgui.cpp	/^float ImGuiStorage::GetFloat(ImU32 key, float default_val) const$/;"	f	class:ImGuiStorage	signature:(ImU32 key, float default_val) const
ImGuiStorage::GetFloat	libs/imgui/imgui.h	/^    IMGUI_API float   GetFloat(ImGuiID key, float default_val = 0.0f) const;$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, float default_val = 0.0f) const
ImGuiStorage::GetFloatRef	libs/imgui/imgui.cpp	/^float* ImGuiStorage::GetFloatRef(ImGuiID key, float default_val)$/;"	f	class:ImGuiStorage	signature:(ImGuiID key, float default_val)
ImGuiStorage::GetFloatRef	libs/imgui/imgui.h	/^    IMGUI_API float*  GetFloatRef(ImGuiID key, float default_val = 0);$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, float default_val = 0)
ImGuiStorage::GetInt	libs/imgui/imgui.cpp	/^int ImGuiStorage::GetInt(ImU32 key, int default_val) const$/;"	f	class:ImGuiStorage	signature:(ImU32 key, int default_val) const
ImGuiStorage::GetInt	libs/imgui/imgui.h	/^    IMGUI_API int     GetInt(ImGuiID key, int default_val = 0) const;$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, int default_val = 0) const
ImGuiStorage::GetIntRef	libs/imgui/imgui.cpp	/^int* ImGuiStorage::GetIntRef(ImGuiID key, int default_val)$/;"	f	class:ImGuiStorage	signature:(ImGuiID key, int default_val)
ImGuiStorage::GetIntRef	libs/imgui/imgui.h	/^    IMGUI_API int*    GetIntRef(ImGuiID key, int default_val = 0);$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, int default_val = 0)
ImGuiStorage::GetVoidPtr	libs/imgui/imgui.cpp	/^void* ImGuiStorage::GetVoidPtr(ImGuiID key) const$/;"	f	class:ImGuiStorage	signature:(ImGuiID key) const
ImGuiStorage::GetVoidPtr	libs/imgui/imgui.h	/^    IMGUI_API void*   GetVoidPtr(ImGuiID key) const; \/\/ default_val is NULL$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key) const
ImGuiStorage::GetVoidPtrRef	libs/imgui/imgui.cpp	/^void** ImGuiStorage::GetVoidPtrRef(ImGuiID key, void* default_val)$/;"	f	class:ImGuiStorage	signature:(ImGuiID key, void* default_val)
ImGuiStorage::GetVoidPtrRef	libs/imgui/imgui.h	/^    IMGUI_API void**  GetVoidPtrRef(ImGuiID key, void* default_val = NULL);$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, void* default_val = NULL)
ImGuiStorage::Pair	libs/imgui/imgui.h	/^    struct Pair $/;"	s	struct:ImGuiStorage	access:public
ImGuiStorage::Pair::Pair	libs/imgui/imgui.h	/^        Pair(ImGuiID _key, float _val_f) { key = _key; val_f = _val_f; } $/;"	f	struct:ImGuiStorage::Pair	access:public	signature:(ImGuiID _key, float _val_f)
ImGuiStorage::Pair::Pair	libs/imgui/imgui.h	/^        Pair(ImGuiID _key, int _val_i) { key = _key; val_i = _val_i; } $/;"	f	struct:ImGuiStorage::Pair	access:public	signature:(ImGuiID _key, int _val_i)
ImGuiStorage::Pair::Pair	libs/imgui/imgui.h	/^        Pair(ImGuiID _key, void* _val_p) { key = _key; val_p = _val_p; } $/;"	f	struct:ImGuiStorage::Pair	access:public	signature:(ImGuiID _key, void* _val_p)
ImGuiStorage::Pair::__anon1::val_f	libs/imgui/imgui.h	/^        union { int val_i; float val_f; void* val_p; };        $/;"	m	union:ImGuiStorage::Pair::__anon1	access:public
ImGuiStorage::Pair::__anon1::val_i	libs/imgui/imgui.h	/^        union { int val_i; float val_f; void* val_p; };        $/;"	m	union:ImGuiStorage::Pair::__anon1	access:public
ImGuiStorage::Pair::__anon1::val_p	libs/imgui/imgui.h	/^        union { int val_i; float val_f; void* val_p; };        $/;"	m	union:ImGuiStorage::Pair::__anon1	access:public
ImGuiStorage::Pair::key	libs/imgui/imgui.h	/^        ImGuiID key; $/;"	m	struct:ImGuiStorage::Pair	access:public
ImGuiStorage::SetAllInt	libs/imgui/imgui.cpp	/^void ImGuiStorage::SetAllInt(int v)$/;"	f	class:ImGuiStorage	signature:(int v)
ImGuiStorage::SetAllInt	libs/imgui/imgui.h	/^    IMGUI_API void    SetAllInt(int val);$/;"	p	struct:ImGuiStorage	access:public	signature:(int val)
ImGuiStorage::SetFloat	libs/imgui/imgui.cpp	/^void ImGuiStorage::SetFloat(ImU32 key, float val)$/;"	f	class:ImGuiStorage	signature:(ImU32 key, float val)
ImGuiStorage::SetFloat	libs/imgui/imgui.h	/^    IMGUI_API void    SetFloat(ImGuiID key, float val);$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, float val)
ImGuiStorage::SetInt	libs/imgui/imgui.cpp	/^void ImGuiStorage::SetInt(ImU32 key, int val)$/;"	f	class:ImGuiStorage	signature:(ImU32 key, int val)
ImGuiStorage::SetInt	libs/imgui/imgui.h	/^    IMGUI_API void    SetInt(ImGuiID key, int val);$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, int val)
ImGuiStorage::SetVoidPtr	libs/imgui/imgui.cpp	/^void ImGuiStorage::SetVoidPtr(ImU32 key, void* val)$/;"	f	class:ImGuiStorage	signature:(ImU32 key, void* val)
ImGuiStorage::SetVoidPtr	libs/imgui/imgui.h	/^    IMGUI_API void    SetVoidPtr(ImGuiID key, void* val);$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, void* val)
ImGuiStyle	libs/imgui/imgui.cpp	/^ImGuiStyle::ImGuiStyle()$/;"	f	class:ImGuiStyle	signature:()
ImGuiStyle	libs/imgui/imgui.h	/^    IMGUI_API ImGuiStyle();$/;"	p	struct:ImGuiStyle	access:public	signature:()
ImGuiStyle	libs/imgui/imgui.h	/^struct ImGuiStyle$/;"	s
ImGuiStyle::Alpha	libs/imgui/imgui.h	/^    float       Alpha;                      \/\/ Global alpha applies to everything in ImGui$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::AntiAliasedLines	libs/imgui/imgui.h	/^    bool        AntiAliasedLines;           \/\/ Enable anti-aliasing on lines\/borders. Disable if you are really tight on CPU\/GPU.$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::AntiAliasedShapes	libs/imgui/imgui.h	/^    bool        AntiAliasedShapes;          \/\/ Enable anti-aliasing on filled shapes (rounded rectangles, circles, etc.)$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::ChildWindowRounding	libs/imgui/imgui.h	/^    float       ChildWindowRounding;        \/\/ Radius of child window corners rounding. Set to 0.0f to have rectangular windows$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::Colors	libs/imgui/imgui.h	/^    ImVec4      Colors[ImGuiCol_COUNT];$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::ColumnsMinSpacing	libs/imgui/imgui.h	/^    float       ColumnsMinSpacing;          \/\/ Minimum horizontal spacing between two columns$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::DisplaySafeAreaPadding	libs/imgui/imgui.h	/^    ImVec2      DisplaySafeAreaPadding;     \/\/ If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups\/tooltips as well regular windows.$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::DisplayWindowPadding	libs/imgui/imgui.h	/^    ImVec2      DisplayWindowPadding;       \/\/ Window positions are clamped to be visible within the display area by at least this amount. Only covers regular windows.$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::FramePadding	libs/imgui/imgui.h	/^    ImVec2      FramePadding;               \/\/ Padding within a framed rectangle (used by most widgets)$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::FrameRounding	libs/imgui/imgui.h	/^    float       FrameRounding;              \/\/ Radius of frame corners rounding. Set to 0.0f to have rectangular frame (used by most widgets).$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::GrabMinSize	libs/imgui/imgui.h	/^    float       GrabMinSize;                \/\/ Minimum width\/height of a grab box for slider\/scrollbar$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::GrabRounding	libs/imgui/imgui.h	/^    float       GrabRounding;               \/\/ Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::ImGuiStyle	libs/imgui/imgui.cpp	/^ImGuiStyle::ImGuiStyle()$/;"	f	class:ImGuiStyle	signature:()
ImGuiStyle::ImGuiStyle	libs/imgui/imgui.h	/^    IMGUI_API ImGuiStyle();$/;"	p	struct:ImGuiStyle	access:public	signature:()
ImGuiStyle::IndentSpacing	libs/imgui/imgui.h	/^    float       IndentSpacing;              \/\/ Horizontal indentation when e.g. entering a tree node$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::ItemInnerSpacing	libs/imgui/imgui.h	/^    ImVec2      ItemInnerSpacing;           \/\/ Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::ItemSpacing	libs/imgui/imgui.h	/^    ImVec2      ItemSpacing;                \/\/ Horizontal and vertical spacing between widgets\/lines$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::ScrollbarRounding	libs/imgui/imgui.h	/^    float       ScrollbarRounding;          \/\/ Radius of grab corners for scrollbar$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::ScrollbarWidth	libs/imgui/imgui.h	/^    float       ScrollbarWidth;             \/\/ Width of the vertical scrollbar$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::TouchExtraPadding	libs/imgui/imgui.h	/^    ImVec2      TouchExtraPadding;          \/\/ Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::WindowFillAlphaDefault	libs/imgui/imgui.h	/^    float       WindowFillAlphaDefault;     \/\/ Default alpha of window background, if not specified in ImGui::Begin()$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::WindowMinSize	libs/imgui/imgui.h	/^    ImVec2      WindowMinSize;              \/\/ Minimum window size$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::WindowPadding	libs/imgui/imgui.h	/^    ImVec2      WindowPadding;              \/\/ Padding within a window$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::WindowRounding	libs/imgui/imgui.h	/^    float       WindowRounding;             \/\/ Radius of window corners rounding. Set to 0.0f to have rectangular windows$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::WindowTitleAlign	libs/imgui/imgui.h	/^    ImGuiAlign  WindowTitleAlign;           \/\/ Alignment for title bar text$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyleMod	libs/imgui/imgui.cpp	/^struct ImGuiStyleMod    \/\/ Style modifier, backup of modified data so we can restore it$/;"	s	file:
ImGuiStyleMod::PreviousValue	libs/imgui/imgui.cpp	/^    ImVec2      PreviousValue;$/;"	m	struct:ImGuiStyleMod	file:	access:public
ImGuiStyleMod::Var	libs/imgui/imgui.cpp	/^    ImGuiStyleVar Var;$/;"	m	struct:ImGuiStyleMod	file:	access:public
ImGuiStyleVar	libs/imgui/imgui.h	/^typedef int ImGuiStyleVar;          \/\/ enum ImGuiStyleVar_$/;"	t
ImGuiStyleVar_	libs/imgui/imgui.h	/^enum ImGuiStyleVar_$/;"	g
ImGuiStyleVar_Alpha	libs/imgui/imgui.h	/^    ImGuiStyleVar_Alpha,               \/\/ float$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_ChildWindowRounding	libs/imgui/imgui.h	/^    ImGuiStyleVar_ChildWindowRounding, \/\/ float$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_FramePadding	libs/imgui/imgui.h	/^    ImGuiStyleVar_FramePadding,        \/\/ ImVec2$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_FrameRounding	libs/imgui/imgui.h	/^    ImGuiStyleVar_FrameRounding,       \/\/ float$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_GrabMinSize	libs/imgui/imgui.h	/^    ImGuiStyleVar_GrabMinSize          \/\/ float$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_IndentSpacing	libs/imgui/imgui.h	/^    ImGuiStyleVar_IndentSpacing,       \/\/ float$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_ItemInnerSpacing	libs/imgui/imgui.h	/^    ImGuiStyleVar_ItemInnerSpacing,    \/\/ ImVec2$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_ItemSpacing	libs/imgui/imgui.h	/^    ImGuiStyleVar_ItemSpacing,         \/\/ ImVec2$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_WindowMinSize	libs/imgui/imgui.h	/^    ImGuiStyleVar_WindowMinSize,       \/\/ ImVec2$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_WindowPadding	libs/imgui/imgui.h	/^    ImGuiStyleVar_WindowPadding,       \/\/ ImVec2$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_WindowRounding	libs/imgui/imgui.h	/^    ImGuiStyleVar_WindowRounding,      \/\/ float$/;"	e	enum:ImGuiStyleVar_
ImGuiTextBuffer	libs/imgui/imgui.h	/^    ImGuiTextBuffer()   { Buf.push_back(0); }$/;"	f	struct:ImGuiTextBuffer	access:public	signature:()
ImGuiTextBuffer	libs/imgui/imgui.h	/^struct ImGuiTextBuffer$/;"	s
ImGuiTextBuffer::Buf	libs/imgui/imgui.h	/^    ImVector<char>      Buf;$/;"	m	struct:ImGuiTextBuffer	access:public
ImGuiTextBuffer::ImGuiTextBuffer	libs/imgui/imgui.h	/^    ImGuiTextBuffer()   { Buf.push_back(0); }$/;"	f	struct:ImGuiTextBuffer	access:public	signature:()
ImGuiTextBuffer::append	libs/imgui/imgui.cpp	/^void ImGuiTextBuffer::append(const char* fmt, ...)$/;"	f	class:ImGuiTextBuffer	signature:(const char* fmt, ...)
ImGuiTextBuffer::append	libs/imgui/imgui.h	/^    IMGUI_API void      append(const char* fmt, ...);$/;"	p	struct:ImGuiTextBuffer	access:public	signature:(const char* fmt, ...)
ImGuiTextBuffer::appendv	libs/imgui/imgui.cpp	/^void ImGuiTextBuffer::appendv(const char* fmt, va_list args)$/;"	f	class:ImGuiTextBuffer	signature:(const char* fmt, va_list args)
ImGuiTextBuffer::appendv	libs/imgui/imgui.h	/^    IMGUI_API void      appendv(const char* fmt, va_list args);$/;"	p	struct:ImGuiTextBuffer	access:public	signature:(const char* fmt, va_list args)
ImGuiTextBuffer::begin	libs/imgui/imgui.h	/^    const char*         begin() const { return &Buf.front(); }$/;"	f	struct:ImGuiTextBuffer	access:public	signature:() const
ImGuiTextBuffer::clear	libs/imgui/imgui.h	/^    void                clear() { Buf.clear(); Buf.push_back(0); }$/;"	f	struct:ImGuiTextBuffer	access:public	signature:()
ImGuiTextBuffer::empty	libs/imgui/imgui.h	/^    bool                empty() { return size() >= 1; }$/;"	f	struct:ImGuiTextBuffer	access:public	signature:()
ImGuiTextBuffer::end	libs/imgui/imgui.h	/^    const char*         end() const { return &Buf.back(); }      \/\/ Buf is zero-terminated, so end() will point on the zero-terminator$/;"	f	struct:ImGuiTextBuffer	access:public	signature:() const
ImGuiTextBuffer::size	libs/imgui/imgui.h	/^    int                 size() const { return Buf.Size-1; }$/;"	f	struct:ImGuiTextBuffer	access:public	signature:() const
ImGuiTextEditCallback	libs/imgui/imgui.h	/^typedef int (*ImGuiTextEditCallback)(ImGuiTextEditCallbackData *data);$/;"	t
ImGuiTextEditCallbackData	libs/imgui/imgui.h	/^struct ImGuiTextEditCallbackData$/;"	s
ImGuiTextEditCallbackData::Buf	libs/imgui/imgui.h	/^    char*               Buf;            \/\/ Current text                         \/\/ Read-write (pointed data only)$/;"	m	struct:ImGuiTextEditCallbackData	access:public
ImGuiTextEditCallbackData::BufDirty	libs/imgui/imgui.h	/^    bool                BufDirty;       \/\/ Set if you modify Buf directly       \/\/ Write$/;"	m	struct:ImGuiTextEditCallbackData	access:public
ImGuiTextEditCallbackData::BufSize	libs/imgui/imgui.h	/^    int                 BufSize;        \/\/                                      \/\/ Read-only$/;"	m	struct:ImGuiTextEditCallbackData	access:public
ImGuiTextEditCallbackData::CursorPos	libs/imgui/imgui.h	/^    int                 CursorPos;      \/\/                                      \/\/ Read-write$/;"	m	struct:ImGuiTextEditCallbackData	access:public
ImGuiTextEditCallbackData::DeleteChars	libs/imgui/imgui.cpp	/^void ImGuiTextEditCallbackData::DeleteChars(int pos, int bytes_count)$/;"	f	class:ImGuiTextEditCallbackData	signature:(int pos, int bytes_count)
ImGuiTextEditCallbackData::DeleteChars	libs/imgui/imgui.h	/^    void DeleteChars(int pos, int bytes_count);$/;"	p	struct:ImGuiTextEditCallbackData	access:public	signature:(int pos, int bytes_count)
ImGuiTextEditCallbackData::EventChar	libs/imgui/imgui.h	/^    ImWchar             EventChar;      \/\/ Character input                      \/\/ Read-write (replace character or set to zero)$/;"	m	struct:ImGuiTextEditCallbackData	access:public
ImGuiTextEditCallbackData::EventFlag	libs/imgui/imgui.h	/^    ImGuiInputTextFlags EventFlag;      \/\/ One of ImGuiInputTextFlags_Callback* \/\/ Read-only$/;"	m	struct:ImGuiTextEditCallbackData	access:public
ImGuiTextEditCallbackData::EventKey	libs/imgui/imgui.h	/^    ImGuiKey            EventKey;       \/\/ Key pressed (Up\/Down\/TAB)            \/\/ Read-only$/;"	m	struct:ImGuiTextEditCallbackData	access:public
ImGuiTextEditCallbackData::Flags	libs/imgui/imgui.h	/^    ImGuiInputTextFlags Flags;          \/\/ What user passed to InputText()      \/\/ Read-only$/;"	m	struct:ImGuiTextEditCallbackData	access:public
ImGuiTextEditCallbackData::HasSelection	libs/imgui/imgui.h	/^    bool HasSelection() const { return SelectionStart != SelectionEnd; }$/;"	f	struct:ImGuiTextEditCallbackData	access:public	signature:() const
ImGuiTextEditCallbackData::InsertChars	libs/imgui/imgui.cpp	/^void ImGuiTextEditCallbackData::InsertChars(int pos, const char* new_text, const char* new_text_end)$/;"	f	class:ImGuiTextEditCallbackData	signature:(int pos, const char* new_text, const char* new_text_end)
ImGuiTextEditCallbackData::InsertChars	libs/imgui/imgui.h	/^    void InsertChars(int pos, const char* text, const char* text_end = NULL);$/;"	p	struct:ImGuiTextEditCallbackData	access:public	signature:(int pos, const char* text, const char* text_end = NULL)
ImGuiTextEditCallbackData::SelectionEnd	libs/imgui/imgui.h	/^    int                 SelectionEnd;   \/\/                                      \/\/ Read-write$/;"	m	struct:ImGuiTextEditCallbackData	access:public
ImGuiTextEditCallbackData::SelectionStart	libs/imgui/imgui.h	/^    int                 SelectionStart; \/\/                                      \/\/ Read-write (== to SelectionEnd when no selection)$/;"	m	struct:ImGuiTextEditCallbackData	access:public
ImGuiTextEditCallbackData::UserData	libs/imgui/imgui.h	/^    void*               UserData;       \/\/ What user passed to InputText()      \/\/ Read-only$/;"	m	struct:ImGuiTextEditCallbackData	access:public
ImGuiTextEditState	libs/imgui/imgui.cpp	/^    ImGuiTextEditState()                                { memset(this, 0, sizeof(*this)); }$/;"	f	struct:ImGuiTextEditState	access:public	signature:()
ImGuiTextEditState	libs/imgui/imgui.cpp	/^struct ImGuiTextEditState$/;"	s	file:
ImGuiTextEditState::BufSizeA	libs/imgui/imgui.cpp	/^    int                 BufSizeA;                       \/\/ end-user buffer size$/;"	m	struct:ImGuiTextEditState	file:	access:public
ImGuiTextEditState::ClearSelection	libs/imgui/imgui.cpp	/^    void                ClearSelection()                { StbState.select_start = StbState.select_end = StbState.cursor; }$/;"	f	struct:ImGuiTextEditState	access:public	signature:()
ImGuiTextEditState::CurLenA	libs/imgui/imgui.cpp	/^    int                 CurLenA, CurLenW;               \/\/ we need to maintain our buffer length in both UTF-8 and wchar format.$/;"	m	struct:ImGuiTextEditState	file:	access:public
ImGuiTextEditState::CurLenW	libs/imgui/imgui.cpp	/^    int                 CurLenA, CurLenW;               \/\/ we need to maintain our buffer length in both UTF-8 and wchar format.$/;"	m	struct:ImGuiTextEditState	file:	access:public
ImGuiTextEditState::CursorAnim	libs/imgui/imgui.cpp	/^    float               CursorAnim;$/;"	m	struct:ImGuiTextEditState	file:	access:public
ImGuiTextEditState::CursorAnimReset	libs/imgui/imgui.cpp	/^    void                CursorAnimReset()               { CursorAnim = -0.30f; }                                                \/\/ After a user-input the cursor stays on for a while without blinking$/;"	f	struct:ImGuiTextEditState	access:public	signature:()
ImGuiTextEditState::CursorFollow	libs/imgui/imgui.cpp	/^    bool                CursorFollow;$/;"	m	struct:ImGuiTextEditState	file:	access:public
ImGuiTextEditState::CursorIsVisible	libs/imgui/imgui.cpp	/^    bool                CursorIsVisible() const         { return CursorAnim <= 0.0f || fmodf(CursorAnim, 1.20f) <= 0.80f; }     \/\/ Blinking$/;"	f	struct:ImGuiTextEditState	access:public	signature:() const
ImGuiTextEditState::HasSelection	libs/imgui/imgui.cpp	/^    bool                HasSelection() const            { return StbState.select_start != StbState.select_end; }$/;"	f	struct:ImGuiTextEditState	access:public	signature:() const
ImGuiTextEditState::Id	libs/imgui/imgui.cpp	/^    ImGuiID             Id;                             \/\/ widget id owning the text state$/;"	m	struct:ImGuiTextEditState	file:	access:public
ImGuiTextEditState::ImGuiTextEditState	libs/imgui/imgui.cpp	/^    ImGuiTextEditState()                                { memset(this, 0, sizeof(*this)); }$/;"	f	struct:ImGuiTextEditState	access:public	signature:()
ImGuiTextEditState::InitialText	libs/imgui/imgui.cpp	/^    ImVector<char>      InitialText;                    \/\/ backup of end-user buffer at the time of focus (in UTF-8, unaltered)$/;"	m	struct:ImGuiTextEditState	file:	access:public
ImGuiTextEditState::InputCursorScreenPos	libs/imgui/imgui.cpp	/^    ImVec2              InputCursorScreenPos;           \/\/ Cursor position in screen space to be used by IME callback.$/;"	m	struct:ImGuiTextEditState	file:	access:public
ImGuiTextEditState::OnKeyPressed	libs/imgui/imgui.cpp	/^    void                OnKeyPressed(int key);$/;"	p	struct:ImGuiTextEditState	file:	access:public	signature:(int key)
ImGuiTextEditState::OnKeyPressed	libs/imgui/imgui.cpp	/^void ImGuiTextEditState::OnKeyPressed(int key)$/;"	f	class:ImGuiTextEditState	signature:(int key)
ImGuiTextEditState::ScrollX	libs/imgui/imgui.cpp	/^    float               ScrollX;$/;"	m	struct:ImGuiTextEditState	file:	access:public
ImGuiTextEditState::SelectAll	libs/imgui/imgui.cpp	/^    void                SelectAll()                     { StbState.select_start = 0; StbState.select_end = CurLenW; StbState.cursor = StbState.select_end; StbState.has_preferred_x = false; }$/;"	f	struct:ImGuiTextEditState	access:public	signature:()
ImGuiTextEditState::SelectedAllMouseLock	libs/imgui/imgui.cpp	/^    bool                SelectedAllMouseLock;$/;"	m	struct:ImGuiTextEditState	file:	access:public
ImGuiTextEditState::StbState	libs/imgui/imgui.cpp	/^    STB_TexteditState   StbState;$/;"	m	struct:ImGuiTextEditState	file:	access:public
ImGuiTextEditState::TempTextBuffer	libs/imgui/imgui.cpp	/^    ImVector<char>      TempTextBuffer;$/;"	m	struct:ImGuiTextEditState	file:	access:public
ImGuiTextEditState::Text	libs/imgui/imgui.cpp	/^    ImVector<ImWchar>   Text;                           \/\/ edit buffer, we need to persist but can't guarantee the persistence of the user-provided buffer. so we copy into own buffer.$/;"	m	struct:ImGuiTextEditState	file:	access:public
ImGuiTextFilter	libs/imgui/imgui.cpp	/^ImGuiTextFilter::ImGuiTextFilter(const char* default_filter)$/;"	f	class:ImGuiTextFilter	signature:(const char* default_filter)
ImGuiTextFilter	libs/imgui/imgui.h	/^    ImGuiTextFilter(const char* default_filter = "");$/;"	p	struct:ImGuiTextFilter	access:public	signature:(const char* default_filter = Ó)
ImGuiTextFilter	libs/imgui/imgui.h	/^struct ImGuiTextFilter$/;"	s
ImGuiTextFilter::Build	libs/imgui/imgui.cpp	/^void ImGuiTextFilter::Build()$/;"	f	class:ImGuiTextFilter	signature:()
ImGuiTextFilter::Build	libs/imgui/imgui.h	/^    IMGUI_API void Build();$/;"	p	struct:ImGuiTextFilter	access:public	signature:()
ImGuiTextFilter::Clear	libs/imgui/imgui.h	/^    void Clear() { InputBuf[0] = 0; Build(); }$/;"	f	struct:ImGuiTextFilter	access:public	signature:()
ImGuiTextFilter::CountGrep	libs/imgui/imgui.h	/^    int                 CountGrep;$/;"	m	struct:ImGuiTextFilter	access:public
ImGuiTextFilter::Draw	libs/imgui/imgui.cpp	/^void ImGuiTextFilter::Draw(const char* label, float width)$/;"	f	class:ImGuiTextFilter	signature:(const char* label, float width)
ImGuiTextFilter::Draw	libs/imgui/imgui.h	/^    void Draw(const char* label = "Filter (inc,-exc)", float width = -1.0f);    \/\/ Helper calling InputText+Build$/;"	p	struct:ImGuiTextFilter	access:public	signature:(const char* label = Ó, float width = -1.0f)
ImGuiTextFilter::Filters	libs/imgui/imgui.h	/^    ImVector<TextRange> Filters;$/;"	m	struct:ImGuiTextFilter	access:public
ImGuiTextFilter::ImGuiTextFilter	libs/imgui/imgui.cpp	/^ImGuiTextFilter::ImGuiTextFilter(const char* default_filter)$/;"	f	class:ImGuiTextFilter	signature:(const char* default_filter)
ImGuiTextFilter::ImGuiTextFilter	libs/imgui/imgui.h	/^    ImGuiTextFilter(const char* default_filter = "");$/;"	p	struct:ImGuiTextFilter	access:public	signature:(const char* default_filter = Ó)
ImGuiTextFilter::InputBuf	libs/imgui/imgui.h	/^    char                InputBuf[256];$/;"	m	struct:ImGuiTextFilter	access:public
ImGuiTextFilter::IsActive	libs/imgui/imgui.h	/^    bool IsActive() const { return !Filters.empty(); }$/;"	f	struct:ImGuiTextFilter	access:public	signature:() const
ImGuiTextFilter::PassFilter	libs/imgui/imgui.cpp	/^bool ImGuiTextFilter::PassFilter(const char* val) const$/;"	f	class:ImGuiTextFilter	signature:(const char* val) const
ImGuiTextFilter::PassFilter	libs/imgui/imgui.h	/^    bool PassFilter(const char* val) const;$/;"	p	struct:ImGuiTextFilter	access:public	signature:(const char* val) const
ImGuiTextFilter::TextRange	libs/imgui/imgui.h	/^    struct TextRange$/;"	s	struct:ImGuiTextFilter	access:public
ImGuiTextFilter::TextRange::TextRange	libs/imgui/imgui.h	/^        TextRange() { b = e = NULL; }$/;"	f	struct:ImGuiTextFilter::TextRange	access:public	signature:()
ImGuiTextFilter::TextRange::TextRange	libs/imgui/imgui.h	/^        TextRange(const char* _b, const char* _e) { b = _b; e = _e; }$/;"	f	struct:ImGuiTextFilter::TextRange	access:public	signature:(const char* _b, const char* _e)
ImGuiTextFilter::TextRange::b	libs/imgui/imgui.h	/^        const char* b;$/;"	m	struct:ImGuiTextFilter::TextRange	access:public
ImGuiTextFilter::TextRange::begin	libs/imgui/imgui.h	/^        const char* begin() const { return b; }$/;"	f	struct:ImGuiTextFilter::TextRange	access:public	signature:() const
ImGuiTextFilter::TextRange::e	libs/imgui/imgui.h	/^        const char* e;$/;"	m	struct:ImGuiTextFilter::TextRange	access:public
ImGuiTextFilter::TextRange::empty	libs/imgui/imgui.h	/^        bool empty() const { return b == e; }$/;"	f	struct:ImGuiTextFilter::TextRange	access:public	signature:() const
ImGuiTextFilter::TextRange::end	libs/imgui/imgui.h	/^        const char* end() const { return e; }$/;"	f	struct:ImGuiTextFilter::TextRange	access:public	signature:() const
ImGuiTextFilter::TextRange::front	libs/imgui/imgui.h	/^        char front() const { return *b; }$/;"	f	struct:ImGuiTextFilter::TextRange	access:public	signature:() const
ImGuiTextFilter::TextRange::isblank	libs/imgui/imgui.h	/^        static bool isblank(char c) { return c == ' ' || c == '\\t'; }$/;"	f	struct:ImGuiTextFilter::TextRange	access:public	signature:(char c)
ImGuiTextFilter::TextRange::split	libs/imgui/imgui.cpp	/^void ImGuiTextFilter::TextRange::split(char separator, ImVector<TextRange>& out)$/;"	f	class:ImGuiTextFilter::TextRange	signature:(char separator, ImVector<TextRange>& out)
ImGuiTextFilter::TextRange::split	libs/imgui/imgui.h	/^        IMGUI_API void split(char separator, ImVector<TextRange>& out);$/;"	p	struct:ImGuiTextFilter::TextRange	access:public	signature:(char separator, ImVector<TextRange>& out)
ImGuiTextFilter::TextRange::trim_blanks	libs/imgui/imgui.h	/^        void trim_blanks() { while (b < e && isblank(*b)) b++; while (e > b && isblank(*(e-1))) e--; }$/;"	f	struct:ImGuiTextFilter::TextRange	access:public	signature:()
ImGuiWindow	libs/imgui/imgui.cpp	/^    ImGuiWindow(const char* name);$/;"	p	struct:ImGuiWindow	file:	access:public	signature:(const char* name)
ImGuiWindow	libs/imgui/imgui.cpp	/^ImGuiWindow::ImGuiWindow(const char* name)$/;"	f	class:ImGuiWindow	signature:(const char* name)
ImGuiWindow	libs/imgui/imgui.cpp	/^struct ImGuiWindow$/;"	s	file:
ImGuiWindow::Accessed	libs/imgui/imgui.cpp	/^    bool                    Accessed;                           \/\/ Set to true when any widget access the current window$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::Active	libs/imgui/imgui.cpp	/^    bool                    Active;                             \/\/ Set to true on Begin()$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::AutoFitFramesX	libs/imgui/imgui.cpp	/^    int                     AutoFitFramesX, AutoFitFramesY;$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::AutoFitFramesY	libs/imgui/imgui.cpp	/^    int                     AutoFitFramesX, AutoFitFramesY;$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::AutoFitOnlyGrows	libs/imgui/imgui.cpp	/^    bool                    AutoFitOnlyGrows;$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::AutoPosLastDirection	libs/imgui/imgui.cpp	/^    int                     AutoPosLastDirection;$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::BeginCount	libs/imgui/imgui.cpp	/^    int                     BeginCount;                         \/\/ Number of Begin() during the current frame (generally 0 or 1, 1+ if appending via multiple Begin\/End pairs)$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::CalcFontSize	libs/imgui/imgui.cpp	/^    float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }$/;"	f	struct:ImGuiWindow	access:public	signature:() const
ImGuiWindow::ClipRect	libs/imgui/imgui.cpp	/^    ImVec4                  ClipRect;                           \/\/ = DrawList->clip_rect_stack.back(). Scissoring \/ clipping rectangle. x1, y1, x2, y2.$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::ClippedWindowRect	libs/imgui/imgui.cpp	/^    ImRect                  ClippedWindowRect;                  \/\/ = ClipRect just after setup in Begin()$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::Collapsed	libs/imgui/imgui.cpp	/^    bool                    Collapsed;                          \/\/ Set when collapsing window to become only title-bar$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::Color	libs/imgui/imgui.cpp	/^    ImU32       Color(ImGuiCol idx, float a=1.f) const  { ImVec4 c = GImGui->Style.Colors[idx]; c.w *= GImGui->Style.Alpha * a; return ImGui::ColorConvertFloat4ToU32(c); }$/;"	f	struct:ImGuiWindow	access:public	signature:(ImGuiCol idx, float a=1.f) const
ImGuiWindow::Color	libs/imgui/imgui.cpp	/^    ImU32       Color(const ImVec4& col) const          { ImVec4 c = col; c.w *= GImGui->Style.Alpha; return ImGui::ColorConvertFloat4ToU32(c); }$/;"	f	struct:ImGuiWindow	access:public	signature:(const ImVec4& col) const
ImGuiWindow::DC	libs/imgui/imgui.cpp	/^    ImGuiDrawContext        DC;                                 \/\/ Temporary per-window data, reset at the beginning of the frame$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::DrawList	libs/imgui/imgui.cpp	/^    ImDrawList*             DrawList;$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::Flags	libs/imgui/imgui.cpp	/^    ImGuiWindowFlags        Flags;$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::FocusIdxAllCounter	libs/imgui/imgui.cpp	/^    int                     FocusIdxAllCounter;                 \/\/ Start at -1 and increase as assigned via FocusItemRegister()$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::FocusIdxAllRequestCurrent	libs/imgui/imgui.cpp	/^    int                     FocusIdxAllRequestCurrent;          \/\/ Item being requested for focus$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::FocusIdxAllRequestNext	libs/imgui/imgui.cpp	/^    int                     FocusIdxAllRequestNext;             \/\/ Item being requested for focus, for next update (relies on layout to be stable between the frame pressing TAB and the next frame)$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::FocusIdxTabCounter	libs/imgui/imgui.cpp	/^    int                     FocusIdxTabCounter;                 \/\/ (same, but only count widgets which you can Tab through)$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::FocusIdxTabRequestCurrent	libs/imgui/imgui.cpp	/^    int                     FocusIdxTabRequestCurrent;          \/\/ Tab-able item being requested for focus$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::FocusIdxTabRequestNext	libs/imgui/imgui.cpp	/^    int                     FocusIdxTabRequestNext;             \/\/ "$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::FocusItemRegister	libs/imgui/imgui.cpp	/^    bool        FocusItemRegister(bool is_active, bool tab_stop = true);      \/\/ Return true if focus is requested$/;"	p	struct:ImGuiWindow	file:	access:public	signature:(bool is_active, bool tab_stop = true)
ImGuiWindow::FocusItemRegister	libs/imgui/imgui.cpp	/^bool ImGuiWindow::FocusItemRegister(bool is_active, bool tab_stop)$/;"	f	class:ImGuiWindow	signature:(bool is_active, bool tab_stop)
ImGuiWindow::FocusItemUnregister	libs/imgui/imgui.cpp	/^    void        FocusItemUnregister();$/;"	p	struct:ImGuiWindow	file:	access:public	signature:()
ImGuiWindow::FocusItemUnregister	libs/imgui/imgui.cpp	/^void ImGuiWindow::FocusItemUnregister()$/;"	f	class:ImGuiWindow	signature:()
ImGuiWindow::FontWindowScale	libs/imgui/imgui.cpp	/^    float                   FontWindowScale;                    \/\/ Scale multiplier per-window$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::GetID	libs/imgui/imgui.cpp	/^    ImGuiID     GetID(const char* str, const char* str_end = NULL);$/;"	p	struct:ImGuiWindow	file:	access:public	signature:(const char* str, const char* str_end = NULL)
ImGuiWindow::GetID	libs/imgui/imgui.cpp	/^    ImGuiID     GetID(const void* ptr);$/;"	p	struct:ImGuiWindow	file:	access:public	signature:(const void* ptr)
ImGuiWindow::GetID	libs/imgui/imgui.cpp	/^ImGuiID ImGuiWindow::GetID(const char* str, const char* str_end)$/;"	f	class:ImGuiWindow	signature:(const char* str, const char* str_end)
ImGuiWindow::GetID	libs/imgui/imgui.cpp	/^ImGuiID ImGuiWindow::GetID(const void* ptr)$/;"	f	class:ImGuiWindow	signature:(const void* ptr)
ImGuiWindow::HiddenFrames	libs/imgui/imgui.cpp	/^    int                     HiddenFrames;$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::ID	libs/imgui/imgui.cpp	/^    ImGuiID                 ID;$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::IDStack	libs/imgui/imgui.cpp	/^    ImVector<ImGuiID>       IDStack;                            \/\/ ID stack. ID are hashes seeded with the value at the top of the stack$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::ImGuiWindow	libs/imgui/imgui.cpp	/^    ImGuiWindow(const char* name);$/;"	p	struct:ImGuiWindow	file:	access:public	signature:(const char* name)
ImGuiWindow::ImGuiWindow	libs/imgui/imgui.cpp	/^ImGuiWindow::ImGuiWindow(const char* name)$/;"	f	class:ImGuiWindow	signature:(const char* name)
ImGuiWindow::ItemWidthDefault	libs/imgui/imgui.cpp	/^    float                   ItemWidthDefault;$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::LastFrameDrawn	libs/imgui/imgui.cpp	/^    int                     LastFrameDrawn;$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::MenuBarHeight	libs/imgui/imgui.cpp	/^    float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }$/;"	f	struct:ImGuiWindow	access:public	signature:() const
ImGuiWindow::MenuBarRect	libs/imgui/imgui.cpp	/^    ImRect      MenuBarRect() const                     { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }$/;"	f	struct:ImGuiWindow	access:public	signature:() const
ImGuiWindow::MenuColumns	libs/imgui/imgui.cpp	/^    ImGuiSimpleColumns      MenuColumns;                        \/\/ Simplified columns storage for menu items$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::MoveID	libs/imgui/imgui.cpp	/^    ImGuiID                 MoveID;                             \/\/ == window->GetID("#MOVE")$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::Name	libs/imgui/imgui.cpp	/^    char*                   Name;$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::PopupID	libs/imgui/imgui.cpp	/^    ImGuiID                 PopupID;                            \/\/ ID in the popup stack when this window is used as a popup\/menu (because we use generic Name\/ID for recycling) $/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::Pos	libs/imgui/imgui.cpp	/^    ImVec2                  Pos;                                \/\/ Position rounded-up to nearest pixel$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::PosFloat	libs/imgui/imgui.cpp	/^    ImVec2                  PosFloat;$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::Rect	libs/imgui/imgui.cpp	/^    ImRect      Rect() const                            { return ImRect(Pos, Pos+Size); }$/;"	f	struct:ImGuiWindow	access:public	signature:() const
ImGuiWindow::RootNonPopupWindow	libs/imgui/imgui.cpp	/^    ImGuiWindow*            RootNonPopupWindow;$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::RootWindow	libs/imgui/imgui.cpp	/^    ImGuiWindow*            RootWindow;$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::ScrollTargetCenterRatioY	libs/imgui/imgui.cpp	/^    float                   ScrollTargetCenterRatioY;           \/\/ 0.0f = scroll so that target position is at top, 0.5f = scroll so that target position is centered$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::ScrollTargetRelY	libs/imgui/imgui.cpp	/^    float                   ScrollTargetRelY;                   \/\/ target scroll position. stored as cursor position with scrolling canceled out, so the highest point is always 0.0f. (FLT_MAX for no change)$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::ScrollY	libs/imgui/imgui.cpp	/^    float                   ScrollY;$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::ScrollbarWidth	libs/imgui/imgui.cpp	/^    float       ScrollbarWidth() const                  { return ScrollbarY ? GImGui->Style.ScrollbarWidth : 0.0f; }$/;"	f	struct:ImGuiWindow	access:public	signature:() const
ImGuiWindow::ScrollbarY	libs/imgui/imgui.cpp	/^    bool                    ScrollbarY;$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::SetWindowCollapsedAllowFlags	libs/imgui/imgui.cpp	/^    int                     SetWindowCollapsedAllowFlags;       \/\/ bit ImGuiSetCond_*** specify if SetWindowCollapsed() call will succeed with this particular flag. $/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::SetWindowPosAllowFlags	libs/imgui/imgui.cpp	/^    int                     SetWindowPosAllowFlags;             \/\/ bit ImGuiSetCond_*** specify if SetWindowPos() call will succeed with this particular flag. $/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::SetWindowPosCenterWanted	libs/imgui/imgui.cpp	/^    bool                    SetWindowPosCenterWanted;$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::SetWindowSizeAllowFlags	libs/imgui/imgui.cpp	/^    int                     SetWindowSizeAllowFlags;            \/\/ bit ImGuiSetCond_*** specify if SetWindowSize() call will succeed with this particular flag. $/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::Size	libs/imgui/imgui.cpp	/^    ImVec2                  Size;                               \/\/ Current size (==SizeFull or collapsed title bar size)$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::SizeContents	libs/imgui/imgui.cpp	/^    ImVec2                  SizeContents;                       \/\/ Size of contents (== extents reach of the drawing cursor) from previous frame$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::SizeFull	libs/imgui/imgui.cpp	/^    ImVec2                  SizeFull;                           \/\/ Size when non collapsed$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::SkipItems	libs/imgui/imgui.cpp	/^    bool                    SkipItems;                          \/\/ == Visible && !Collapsed$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::StateStorage	libs/imgui/imgui.cpp	/^    ImGuiStorage            StateStorage;$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::TitleBarHeight	libs/imgui/imgui.cpp	/^    float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }$/;"	f	struct:ImGuiWindow	access:public	signature:() const
ImGuiWindow::TitleBarRect	libs/imgui/imgui.cpp	/^    ImRect      TitleBarRect() const                    { return ImRect(Pos, Pos + ImVec2(SizeFull.x, TitleBarHeight())); }$/;"	f	struct:ImGuiWindow	access:public	signature:() const
ImGuiWindow::WasActive	libs/imgui/imgui.cpp	/^    bool                    WasActive;$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::WindowPadding	libs/imgui/imgui.cpp	/^    ImVec2                  WindowPadding;                      \/\/ Window padding at the time of begin. We need to lock it, in particular manipulation of the ShowBorder would have an effect$/;"	m	struct:ImGuiWindow	file:	access:public
ImGuiWindow::~ImGuiWindow	libs/imgui/imgui.cpp	/^    ~ImGuiWindow();$/;"	p	struct:ImGuiWindow	file:	access:public	signature:()
ImGuiWindow::~ImGuiWindow	libs/imgui/imgui.cpp	/^ImGuiWindow::~ImGuiWindow()$/;"	f	class:ImGuiWindow	signature:()
ImGuiWindowFlags	libs/imgui/imgui.h	/^typedef int ImGuiWindowFlags;       \/\/ enum ImGuiWindowFlags_$/;"	t
ImGuiWindowFlags_	libs/imgui/imgui.h	/^enum ImGuiWindowFlags_$/;"	g
ImGuiWindowFlags_AlwaysAutoResize	libs/imgui/imgui.h	/^    ImGuiWindowFlags_AlwaysAutoResize       = 1 << 6,   \/\/ Resize every window to its content every frame$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_ChildMenu	libs/imgui/imgui.h	/^    ImGuiWindowFlags_ChildMenu              = 1 << 27   \/\/ Don't use! For internal use by BeginMenu()$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_ChildWindow	libs/imgui/imgui.h	/^    ImGuiWindowFlags_ChildWindow            = 1 << 20,  \/\/ Don't use! For internal use by BeginChild()$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_ChildWindowAutoFitX	libs/imgui/imgui.h	/^    ImGuiWindowFlags_ChildWindowAutoFitX    = 1 << 21,  \/\/ Don't use! For internal use by BeginChild()$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_ChildWindowAutoFitY	libs/imgui/imgui.h	/^    ImGuiWindowFlags_ChildWindowAutoFitY    = 1 << 22,  \/\/ Don't use! For internal use by BeginChild()$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_ComboBox	libs/imgui/imgui.h	/^    ImGuiWindowFlags_ComboBox               = 1 << 23,  \/\/ Don't use! For internal use by ComboBox()$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_MenuBar	libs/imgui/imgui.h	/^    ImGuiWindowFlags_MenuBar                = 1 << 10,  \/\/ Has a menu-bar$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_Modal	libs/imgui/imgui.h	/^    ImGuiWindowFlags_Modal                  = 1 << 26,  \/\/ Don't use! For internal use by BeginPopupModal()$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoCollapse	libs/imgui/imgui.h	/^    ImGuiWindowFlags_NoCollapse             = 1 << 5,   \/\/ Disable user collapsing window by double-clicking on it$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoInputs	libs/imgui/imgui.h	/^    ImGuiWindowFlags_NoInputs               = 1 << 9,   \/\/ Disable catching mouse or keyboard inputs$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoMove	libs/imgui/imgui.h	/^    ImGuiWindowFlags_NoMove                 = 1 << 2,   \/\/ Disable user moving the window$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoResize	libs/imgui/imgui.h	/^    ImGuiWindowFlags_NoResize               = 1 << 1,   \/\/ Disable user resizing with the lower-right grip$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoSavedSettings	libs/imgui/imgui.h	/^    ImGuiWindowFlags_NoSavedSettings        = 1 << 8,   \/\/ Never load\/save settings in .ini file$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoScrollWithMouse	libs/imgui/imgui.h	/^    ImGuiWindowFlags_NoScrollWithMouse      = 1 << 4,   \/\/ Disable user scrolling with mouse wheel$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoScrollbar	libs/imgui/imgui.h	/^    ImGuiWindowFlags_NoScrollbar            = 1 << 3,   \/\/ Disable scrollbar (window can still scroll with mouse or programatically)$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoTitleBar	libs/imgui/imgui.h	/^    ImGuiWindowFlags_NoTitleBar             = 1 << 0,   \/\/ Disable title-bar$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_Popup	libs/imgui/imgui.h	/^    ImGuiWindowFlags_Popup                  = 1 << 25,  \/\/ Don't use! For internal use by BeginPopup()$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_ShowBorders	libs/imgui/imgui.h	/^    ImGuiWindowFlags_ShowBorders            = 1 << 7,   \/\/ Show borders around windows and items$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_Tooltip	libs/imgui/imgui.h	/^    ImGuiWindowFlags_Tooltip                = 1 << 24,  \/\/ Don't use! For internal use by BeginTooltip()$/;"	e	enum:ImGuiWindowFlags_
ImGui_ImplGlfwGL3_CharCallback	libs/imgui/imgui_impl_glfw_gl3.cpp	/^void ImGui_ImplGlfwGL3_CharCallback(GLFWwindow*, unsigned int c)$/;"	f	signature:(GLFWwindow*, unsigned int c)
ImGui_ImplGlfwGL3_CharCallback	libs/imgui/imgui_impl_glfw_gl3.h	/^void        ImGui_ImplGlfwGL3_CharCallback(GLFWwindow* window, unsigned int c);$/;"	p	signature:(GLFWwindow* window, unsigned int c)
ImGui_ImplGlfwGL3_CreateDeviceObjects	libs/imgui/imgui_impl_glfw_gl3.cpp	/^bool ImGui_ImplGlfwGL3_CreateDeviceObjects()$/;"	f	signature:()
ImGui_ImplGlfwGL3_CreateDeviceObjects	libs/imgui/imgui_impl_glfw_gl3.h	/^bool        ImGui_ImplGlfwGL3_CreateDeviceObjects();$/;"	p	signature:()
ImGui_ImplGlfwGL3_CreateFontsTexture	libs/imgui/imgui_impl_glfw_gl3.cpp	/^void ImGui_ImplGlfwGL3_CreateFontsTexture()$/;"	f	signature:()
ImGui_ImplGlfwGL3_GetClipboardText	libs/imgui/imgui_impl_glfw_gl3.cpp	/^static const char* ImGui_ImplGlfwGL3_GetClipboardText()$/;"	f	file:	signature:()
ImGui_ImplGlfwGL3_Init	libs/imgui/imgui_impl_glfw_gl3.cpp	/^bool    ImGui_ImplGlfwGL3_Init(GLFWwindow* window, bool install_callbacks)$/;"	f	signature:(GLFWwindow* window, bool install_callbacks)
ImGui_ImplGlfwGL3_Init	libs/imgui/imgui_impl_glfw_gl3.h	/^bool        ImGui_ImplGlfwGL3_Init(GLFWwindow* window, bool install_callbacks);$/;"	p	signature:(GLFWwindow* window, bool install_callbacks)
ImGui_ImplGlfwGL3_InvalidateDeviceObjects	libs/imgui/imgui_impl_glfw_gl3.h	/^void        ImGui_ImplGlfwGL3_InvalidateDeviceObjects();$/;"	p	signature:()
ImGui_ImplGlfwGL3_KeyCallback	libs/imgui/imgui_impl_glfw_gl3.cpp	/^void ImGui_ImplGlfwGL3_KeyCallback(GLFWwindow*, int key, int, int action, int mods)$/;"	f	signature:(GLFWwindow*, int key, int, int action, int mods)
ImGui_ImplGlfwGL3_KeyCallback	libs/imgui/imgui_impl_glfw_gl3.h	/^void        ImGui_ImplGlfwGL3_KeyCallback(GLFWwindow* window, int key, int scancode, int action, int mods);$/;"	p	signature:(GLFWwindow* window, int key, int scancode, int action, int mods)
ImGui_ImplGlfwGL3_MouseButtonCallback	libs/imgui/imgui_impl_glfw_gl3.cpp	/^void ImGui_ImplGlfwGL3_MouseButtonCallback(GLFWwindow*, int button, int action, int \/*mods*\/)$/;"	f	signature:(GLFWwindow*, int button, int action, int )
ImGui_ImplGlfwGL3_MouseButtonCallback	libs/imgui/imgui_impl_glfw_gl3.h	/^void        ImGui_ImplGlfwGL3_MouseButtonCallback(GLFWwindow* window, int button, int action, int mods);$/;"	p	signature:(GLFWwindow* window, int button, int action, int mods)
ImGui_ImplGlfwGL3_NewFrame	libs/imgui/imgui_impl_glfw_gl3.cpp	/^void ImGui_ImplGlfwGL3_NewFrame()$/;"	f	signature:()
ImGui_ImplGlfwGL3_NewFrame	libs/imgui/imgui_impl_glfw_gl3.h	/^void        ImGui_ImplGlfwGL3_NewFrame();$/;"	p	signature:()
ImGui_ImplGlfwGL3_RenderDrawLists	libs/imgui/imgui_impl_glfw_gl3.cpp	/^static void ImGui_ImplGlfwGL3_RenderDrawLists(ImDrawData* draw_data)$/;"	f	file:	signature:(ImDrawData* draw_data)
ImGui_ImplGlfwGL3_ScrollCallback	libs/imgui/imgui_impl_glfw_gl3.cpp	/^void ImGui_ImplGlfwGL3_ScrollCallback(GLFWwindow*, double \/*xoffset*\/, double yoffset)$/;"	f	signature:(GLFWwindow*, double , double yoffset)
ImGui_ImplGlfwGL3_ScrollCallback	libs/imgui/imgui_impl_glfw_gl3.h	/^void        ImGui_ImplGlfwGL3_ScrollCallback(GLFWwindow* window, double xoffset, double yoffset);$/;"	p	signature:(GLFWwindow* window, double xoffset, double yoffset)
ImGui_ImplGlfwGL3_SetClipboardText	libs/imgui/imgui_impl_glfw_gl3.cpp	/^static void ImGui_ImplGlfwGL3_SetClipboardText(const char* text)$/;"	f	file:	signature:(const char* text)
ImGui_ImplGlfwGL3_Shutdown	libs/imgui/imgui_impl_glfw_gl3.cpp	/^void ImGui_ImplGlfwGL3_Shutdown()$/;"	f	signature:()
ImGui_ImplGlfwGL3_Shutdown	libs/imgui/imgui_impl_glfw_gl3.h	/^void        ImGui_ImplGlfwGL3_Shutdown();$/;"	p	signature:()
ImHash	libs/imgui/imgui.cpp	/^static ImU32        ImHash(const void* data, int data_size, ImU32 seed);$/;"	p	file:	signature:(const void* data, int data_size, ImU32 seed)
ImHash	libs/imgui/imgui.cpp	/^static ImU32 ImHash(const void* data, int data_size, ImU32 seed = 0) $/;"	f	file:	signature:(const void* data, int data_size, ImU32 seed = 0)
ImInvLength	libs/imgui/imgui.cpp	/^static inline float  ImInvLength(const ImVec2& lhs, float fail_value)           { float d = lhs.x*lhs.x + lhs.y*lhs.y; if (d > 0.0f) return 1.0f \/ sqrtf(d); return fail_value; }$/;"	f	file:	signature:(const ImVec2& lhs, float fail_value)
ImIsPointInTriangle	libs/imgui/imgui.cpp	/^static bool ImIsPointInTriangle(const ImVec2& p, const ImVec2& a, const ImVec2& b, const ImVec2& c)$/;"	f	file:	signature:(const ImVec2& p, const ImVec2& a, const ImVec2& b, const ImVec2& c)
ImLengthSqr	libs/imgui/imgui.cpp	/^static inline float  ImLengthSqr(const ImVec2& lhs)                             { return lhs.x*lhs.x + lhs.y*lhs.y; }$/;"	f	file:	signature:(const ImVec2& lhs)
ImLengthSqr	libs/imgui/imgui.cpp	/^static inline float  ImLengthSqr(const ImVec4& lhs)                             { return lhs.x*lhs.x + lhs.y*lhs.y + lhs.z*lhs.z + lhs.w*lhs.w; }$/;"	f	file:	signature:(const ImVec4& lhs)
ImLerp	libs/imgui/imgui.cpp	/^static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }$/;"	f	file:	signature:(const ImVec2& a, const ImVec2& b, const ImVec2& t)
ImLerp	libs/imgui/imgui.cpp	/^static inline float  ImLerp(float a, float b, float t)                          { return a + (b - a) * t; }$/;"	f	file:	signature:(float a, float b, float t)
ImLoadFileToMemory	libs/imgui/imgui.cpp	/^static bool         ImLoadFileToMemory(const char* filename, const char* file_open_mode, void** out_file_data, int* out_file_size, int padding_bytes = 0);$/;"	p	file:	signature:(const char* filename, const char* file_open_mode, void** out_file_data, int* out_file_size, int padding_bytes = 0)
ImLoadFileToMemory	libs/imgui/imgui.cpp	/^static bool ImLoadFileToMemory(const char* filename, const char* file_open_mode, void** out_file_data, int* out_file_size, int padding_bytes)$/;"	f	file:	signature:(const char* filename, const char* file_open_mode, void** out_file_data, int* out_file_size, int padding_bytes)
ImMax	libs/imgui/imgui.cpp	/^static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(ImMax(lhs.x,rhs.x), ImMax(lhs.y,rhs.y)); }$/;"	f	file:	signature:(const ImVec2& lhs, const ImVec2& rhs)
ImMax	libs/imgui/imgui.cpp	/^static inline float  ImMax(float lhs, float rhs)                                { return lhs >= rhs ? lhs : rhs; }$/;"	f	file:	signature:(float lhs, float rhs)
ImMax	libs/imgui/imgui.cpp	/^static inline int    ImMax(int lhs, int rhs)                                    { return lhs >= rhs ? lhs : rhs; }$/;"	f	file:	signature:(int lhs, int rhs)
ImMin	libs/imgui/imgui.cpp	/^static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(ImMin(lhs.x,rhs.x), ImMin(lhs.y,rhs.y)); }$/;"	f	file:	signature:(const ImVec2& lhs, const ImVec2& rhs)
ImMin	libs/imgui/imgui.cpp	/^static inline float  ImMin(float lhs, float rhs)                                { return lhs < rhs ? lhs : rhs; }$/;"	f	file:	signature:(float lhs, float rhs)
ImMin	libs/imgui/imgui.cpp	/^static inline int    ImMin(int lhs, int rhs)                                    { return lhs < rhs ? lhs : rhs; }$/;"	f	file:	signature:(int lhs, int rhs)
ImRect	libs/imgui/imgui.cpp	/^    ImRect()                                        : Min(FLT_MAX,FLT_MAX), Max(-FLT_MAX,-FLT_MAX)  {}$/;"	f	struct:ImRect	access:public	signature:()
ImRect	libs/imgui/imgui.cpp	/^    ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}$/;"	f	struct:ImRect	access:public	signature:(const ImVec2& min, const ImVec2& max)
ImRect	libs/imgui/imgui.cpp	/^    ImRect(const ImVec4& v)                         : Min(v.x, v.y), Max(v.z, v.w)                  {}$/;"	f	struct:ImRect	access:public	signature:(const ImVec4& v)
ImRect	libs/imgui/imgui.cpp	/^    ImRect(float x1, float y1, float x2, float y2)  : Min(x1, y1), Max(x2, y2)                      {}$/;"	f	struct:ImRect	access:public	signature:(float x1, float y1, float x2, float y2)
ImRect	libs/imgui/imgui.cpp	/^struct ImRect           \/\/ 2D axis aligned bounding-box$/;"	s	file:
ImRect::Add	libs/imgui/imgui.cpp	/^    void        Add(const ImRect& rhs)              { Min.x = ImMin(Min.x, rhs.Min.x); Min.y = ImMin(Min.y, rhs.Min.y); Max.x = ImMax(Max.x, rhs.Max.x); Max.y = ImMax(Max.y, rhs.Max.y); }$/;"	f	struct:ImRect	access:public	signature:(const ImRect& rhs)
ImRect::Add	libs/imgui/imgui.cpp	/^    void        Add(const ImVec2& rhs)              { Min.x = ImMin(Min.x, rhs.x); Min.y = ImMin(Min.y, rhs.y); Max.x = ImMax(Max.x, rhs.x); Max.y = ImMax(Max.y, rhs.y); }$/;"	f	struct:ImRect	access:public	signature:(const ImVec2& rhs)
ImRect::Clip	libs/imgui/imgui.cpp	/^    void        Clip(const ImRect& clip)            { Min.x = ImMax(Min.x, clip.Min.x); Min.y = ImMax(Min.y, clip.Min.y); Max.x = ImMin(Max.x, clip.Max.x); Max.y = ImMin(Max.y, clip.Max.y); }$/;"	f	struct:ImRect	access:public	signature:(const ImRect& clip)
ImRect::Contains	libs/imgui/imgui.cpp	/^    bool        Contains(const ImRect& r) const     { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x < Max.x && r.Max.y < Max.y; }$/;"	f	struct:ImRect	access:public	signature:(const ImRect& r) const
ImRect::Contains	libs/imgui/imgui.cpp	/^    bool        Contains(const ImVec2& p) const     { return p.x >= Min.x && p.y >= Min.y && p.x < Max.x && p.y < Max.y; }$/;"	f	struct:ImRect	access:public	signature:(const ImVec2& p) const
ImRect::Expand	libs/imgui/imgui.cpp	/^    void        Expand(const ImVec2& amount)        { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }$/;"	f	struct:ImRect	access:public	signature:(const ImVec2& amount)
ImRect::Expand	libs/imgui/imgui.cpp	/^    void        Expand(const float amount)          { Min.x -= amount; Min.y -= amount; Max.x += amount; Max.y += amount; }$/;"	f	struct:ImRect	access:public	signature:(const float amount)
ImRect::GetBL	libs/imgui/imgui.cpp	/^    ImVec2      GetBL() const                       { return ImVec2(Min.x,Max.y); }$/;"	f	struct:ImRect	access:public	signature:() const
ImRect::GetBR	libs/imgui/imgui.cpp	/^    ImVec2      GetBR() const                       { return Max; }$/;"	f	struct:ImRect	access:public	signature:() const
ImRect::GetCenter	libs/imgui/imgui.cpp	/^    ImVec2      GetCenter() const                   { return ImVec2((Min.x+Max.x)*0.5f, (Min.y+Max.y)*0.5f); }$/;"	f	struct:ImRect	access:public	signature:() const
ImRect::GetClosestPoint	libs/imgui/imgui.cpp	/^    ImVec2      GetClosestPoint(ImVec2 p, bool on_edge) const$/;"	f	struct:ImRect	access:public	signature:(ImVec2 p, bool on_edge) const
ImRect::GetHeight	libs/imgui/imgui.cpp	/^    float       GetHeight() const                   { return Max.y-Min.y; }$/;"	f	struct:ImRect	access:public	signature:() const
ImRect::GetSize	libs/imgui/imgui.cpp	/^    ImVec2      GetSize() const                     { return ImVec2(Max.x-Min.x,Max.y-Min.y); }$/;"	f	struct:ImRect	access:public	signature:() const
ImRect::GetTL	libs/imgui/imgui.cpp	/^    ImVec2      GetTL() const                       { return Min; }$/;"	f	struct:ImRect	access:public	signature:() const
ImRect::GetTR	libs/imgui/imgui.cpp	/^    ImVec2      GetTR() const                       { return ImVec2(Max.x,Min.y); }$/;"	f	struct:ImRect	access:public	signature:() const
ImRect::GetWidth	libs/imgui/imgui.cpp	/^    float       GetWidth() const                    { return Max.x-Min.x; }$/;"	f	struct:ImRect	access:public	signature:() const
ImRect::ImRect	libs/imgui/imgui.cpp	/^    ImRect()                                        : Min(FLT_MAX,FLT_MAX), Max(-FLT_MAX,-FLT_MAX)  {}$/;"	f	struct:ImRect	access:public	signature:()
ImRect::ImRect	libs/imgui/imgui.cpp	/^    ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}$/;"	f	struct:ImRect	access:public	signature:(const ImVec2& min, const ImVec2& max)
ImRect::ImRect	libs/imgui/imgui.cpp	/^    ImRect(const ImVec4& v)                         : Min(v.x, v.y), Max(v.z, v.w)                  {}$/;"	f	struct:ImRect	access:public	signature:(const ImVec4& v)
ImRect::ImRect	libs/imgui/imgui.cpp	/^    ImRect(float x1, float y1, float x2, float y2)  : Min(x1, y1), Max(x2, y2)                      {}$/;"	f	struct:ImRect	access:public	signature:(float x1, float y1, float x2, float y2)
ImRect::Max	libs/imgui/imgui.cpp	/^    ImVec2      Max;$/;"	m	struct:ImRect	file:	access:public
ImRect::Min	libs/imgui/imgui.cpp	/^    ImVec2      Min;$/;"	m	struct:ImRect	file:	access:public
ImRect::Overlaps	libs/imgui/imgui.cpp	/^    bool        Overlaps(const ImRect& r) const     { return r.Min.y < Max.y && r.Max.y > Min.y && r.Min.x < Max.x && r.Max.x > Min.x; }$/;"	f	struct:ImRect	access:public	signature:(const ImRect& r) const
ImRect::Reduce	libs/imgui/imgui.cpp	/^    void        Reduce(const ImVec2& amount)        { Min.x += amount.x; Min.y += amount.y; Max.x -= amount.x; Max.y -= amount.y; }$/;"	f	struct:ImRect	access:public	signature:(const ImVec2& amount)
ImRect::Round	libs/imgui/imgui.cpp	/^    void        Round()                             { Min.x = (float)(int)Min.x; Min.y = (float)(int)Min.y; Max.x = (float)(int)Max.x; Max.y = (float)(int)Max.y; } $/;"	f	struct:ImRect	access:public	signature:()
ImSaturate	libs/imgui/imgui.cpp	/^static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }$/;"	f	file:	signature:(float f)
ImStrbolW	libs/imgui/imgui.cpp	/^static const ImWchar* ImStrbolW(const ImWchar* buf_mid_line, const ImWchar* buf_begin) \/\/ find beginning-of-line$/;"	f	file:	signature:(const ImWchar* buf_mid_line, const ImWchar* buf_begin)
ImStrbolW	libs/imgui/imgui.cpp	/^static const ImWchar* ImStrbolW(const ImWchar* buf_mid_line, const ImWchar* buf_begin); \/\/ Find beginning-of-line$/;"	p	file:	signature:(const ImWchar* buf_mid_line, const ImWchar* buf_begin)
ImStrdup	libs/imgui/imgui.cpp	/^static char*        ImStrdup(const char* str);$/;"	p	file:	signature:(const char* str)
ImStrdup	libs/imgui/imgui.cpp	/^static char* ImStrdup(const char *str)$/;"	f	file:	signature:(const char *str)
ImStricmp	libs/imgui/imgui.cpp	/^static int          ImStricmp(const char* str1, const char* str2);$/;"	p	file:	signature:(const char* str1, const char* str2)
ImStricmp	libs/imgui/imgui.cpp	/^static int ImStricmp(const char* str1, const char* str2)$/;"	f	file:	signature:(const char* str1, const char* str2)
ImStricmp	src/util/Console.cpp	/^    static int ImStricmp(const char* str1, const char* str2)$/;"	f	namespace:Console	signature:(const char* str1, const char* str2)
ImStricmp	src/util/Console.cpp	/^    static int ImStricmp(const char* str1, const char* str2);$/;"	p	namespace:Console	file:	signature:(const char* str1, const char* str2)
ImStristr	libs/imgui/imgui.cpp	/^static const char*  ImStristr(const char* haystack, const char* needle, const char* needle_end);$/;"	p	file:	signature:(const char* haystack, const char* needle, const char* needle_end)
ImStristr	libs/imgui/imgui.cpp	/^static const char* ImStristr(const char* haystack, const char* needle, const char* needle_end)$/;"	f	file:	signature:(const char* haystack, const char* needle, const char* needle_end)
ImStrlenW	libs/imgui/imgui.cpp	/^static int          ImStrlenW(const ImWchar* str);$/;"	p	file:	signature:(const ImWchar* str)
ImStrlenW	libs/imgui/imgui.cpp	/^static int ImStrlenW(const ImWchar* str)$/;"	f	file:	signature:(const ImWchar* str)
ImStrnicmp	libs/imgui/imgui.cpp	/^static int          ImStrnicmp(const char* str1, const char* str2, int count);$/;"	p	file:	signature:(const char* str1, const char* str2, int count)
ImStrnicmp	libs/imgui/imgui.cpp	/^static int ImStrnicmp(const char* str1, const char* str2, int count)$/;"	f	file:	signature:(const char* str1, const char* str2, int count)
ImStrnicmp	src/util/Console.cpp	/^    static int ImStrnicmp(const char* str1, const char* str2, int count)$/;"	f	namespace:Console	signature:(const char* str1, const char* str2, int count)
ImStrnicmp	src/util/Console.cpp	/^    static int ImStrnicmp(const char* str1, const char* str2, int count);$/;"	p	namespace:Console	file:	signature:(const char* str1, const char* str2, int count)
ImTextCharFromUtf8	libs/imgui/imgui.cpp	/^static int          ImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end);          \/\/ return input UTF-8 bytes count$/;"	p	file:	signature:(unsigned int* out_char, const char* in_text, const char* in_text_end)
ImTextCharFromUtf8	libs/imgui/imgui.cpp	/^static int ImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end)$/;"	f	file:	signature:(unsigned int* out_char, const char* in_text, const char* in_text_end)
ImTextCharToUtf8	libs/imgui/imgui.cpp	/^static inline int   ImTextCharToUtf8(char* buf, int buf_size, unsigned int in_char);                                   \/\/ return output UTF-8 bytes count$/;"	p	file:	signature:(char* buf, int buf_size, unsigned int in_char)
ImTextCharToUtf8	libs/imgui/imgui.cpp	/^static inline int ImTextCharToUtf8(char* buf, int buf_size, unsigned int c)$/;"	f	file:	signature:(char* buf, int buf_size, unsigned int c)
ImTextCountCharsFromUtf8	libs/imgui/imgui.cpp	/^static int          ImTextCountCharsFromUtf8(const char* in_text, const char* in_text_end);                            \/\/ return number of UTF-8 code-points (NOT bytes count)$/;"	p	file:	signature:(const char* in_text, const char* in_text_end)
ImTextCountCharsFromUtf8	libs/imgui/imgui.cpp	/^static int ImTextCountCharsFromUtf8(const char* in_text, const char* in_text_end)$/;"	f	file:	signature:(const char* in_text, const char* in_text_end)
ImTextCountUtf8BytesFromChar	libs/imgui/imgui.cpp	/^static inline int   ImTextCountUtf8BytesFromChar(unsigned int in_char);                                                \/\/ return output UTF-8 bytes count$/;"	p	file:	signature:(unsigned int in_char)
ImTextCountUtf8BytesFromChar	libs/imgui/imgui.cpp	/^static inline int ImTextCountUtf8BytesFromChar(unsigned int c)$/;"	f	file:	signature:(unsigned int c)
ImTextCountUtf8BytesFromStr	libs/imgui/imgui.cpp	/^static int          ImTextCountUtf8BytesFromStr(const ImWchar* in_text, const ImWchar* in_text_end);                   \/\/ return number of bytes to express string as UTF-8 code-points$/;"	p	file:	signature:(const ImWchar* in_text, const ImWchar* in_text_end)
ImTextCountUtf8BytesFromStr	libs/imgui/imgui.cpp	/^static int ImTextCountUtf8BytesFromStr(const ImWchar* in_text, const ImWchar* in_text_end)$/;"	f	file:	signature:(const ImWchar* in_text, const ImWchar* in_text_end)
ImTextStrFromUtf8	libs/imgui/imgui.cpp	/^static int          ImTextStrFromUtf8(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_remaining = NULL);   \/\/ return input UTF-8 bytes count$/;"	p	file:	signature:(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_remaining = NULL)
ImTextStrFromUtf8	libs/imgui/imgui.cpp	/^static int ImTextStrFromUtf8(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_text_remaining)$/;"	f	file:	signature:(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_text_remaining)
ImTextStrToUtf8	libs/imgui/imgui.cpp	/^static int          ImTextStrToUtf8(char* buf, int buf_size, const ImWchar* in_text, const ImWchar* in_text_end);      \/\/ return output UTF-8 bytes count$/;"	p	file:	signature:(char* buf, int buf_size, const ImWchar* in_text, const ImWchar* in_text_end)
ImTextStrToUtf8	libs/imgui/imgui.cpp	/^static int ImTextStrToUtf8(char* buf, int buf_size, const ImWchar* in_text, const ImWchar* in_text_end)$/;"	f	file:	signature:(char* buf, int buf_size, const ImWchar* in_text, const ImWchar* in_text_end)
ImTextureID	libs/imgui/imgui.h	/^typedef void* ImTextureID;          \/\/ user data to refer to a texture (e.g. store your texture handle\/id)$/;"	t
ImU32	libs/imgui/imgui.h	/^typedef unsigned int ImU32;$/;"	t
ImUpperPowerOfTwo	libs/imgui/imgui.cpp	/^static inline int   ImUpperPowerOfTwo(int v) { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return v; }$/;"	f	file:	signature:(int v)
ImVec2	libs/imgui/imgui.h	/^    ImVec2() { x = y = 0.0f; }$/;"	f	struct:ImVec2	access:public	signature:()
ImVec2	libs/imgui/imgui.h	/^    ImVec2(float _x, float _y) { x = _x; y = _y; }$/;"	f	struct:ImVec2	access:public	signature:(float _x, float _y)
ImVec2	libs/imgui/imgui.h	/^struct ImVec2$/;"	s
ImVec2::ImVec2	libs/imgui/imgui.h	/^    ImVec2() { x = y = 0.0f; }$/;"	f	struct:ImVec2	access:public	signature:()
ImVec2::ImVec2	libs/imgui/imgui.h	/^    ImVec2(float _x, float _y) { x = _x; y = _y; }$/;"	f	struct:ImVec2	access:public	signature:(float _x, float _y)
ImVec2::x	libs/imgui/imgui.h	/^    float x, y;$/;"	m	struct:ImVec2	access:public
ImVec2::y	libs/imgui/imgui.h	/^    float x, y;$/;"	m	struct:ImVec2	access:public
ImVec4	libs/imgui/imgui.h	/^    ImVec4() { x = y = z = w = 0.0f; }$/;"	f	struct:ImVec4	access:public	signature:()
ImVec4	libs/imgui/imgui.h	/^    ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }$/;"	f	struct:ImVec4	access:public	signature:(float _x, float _y, float _z, float _w)
ImVec4	libs/imgui/imgui.h	/^struct ImVec4$/;"	s
ImVec4::ImVec4	libs/imgui/imgui.h	/^    ImVec4() { x = y = z = w = 0.0f; }$/;"	f	struct:ImVec4	access:public	signature:()
ImVec4::ImVec4	libs/imgui/imgui.h	/^    ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }$/;"	f	struct:ImVec4	access:public	signature:(float _x, float _y, float _z, float _w)
ImVec4::w	libs/imgui/imgui.h	/^    float x, y, z, w;$/;"	m	struct:ImVec4	access:public
ImVec4::x	libs/imgui/imgui.h	/^    float x, y, z, w;$/;"	m	struct:ImVec4	access:public
ImVec4::y	libs/imgui/imgui.h	/^    float x, y, z, w;$/;"	m	struct:ImVec4	access:public
ImVec4::z	libs/imgui/imgui.h	/^    float x, y, z, w;$/;"	m	struct:ImVec4	access:public
ImVector	libs/imgui/imgui.h	/^    ImVector()                  { Size = Capacity = 0; Data = NULL; }$/;"	f	class:ImVector	access:public	signature:()
ImVector	libs/imgui/imgui.h	/^class ImVector$/;"	c
ImVector::Capacity	libs/imgui/imgui.h	/^    int                         Capacity;$/;"	m	class:ImVector	access:public
ImVector::Data	libs/imgui/imgui.h	/^    T*                          Data;$/;"	m	class:ImVector	access:public
ImVector::ImVector	libs/imgui/imgui.h	/^    ImVector()                  { Size = Capacity = 0; Data = NULL; }$/;"	f	class:ImVector	access:public	signature:()
ImVector::Size	libs/imgui/imgui.h	/^    int                         Size;$/;"	m	class:ImVector	access:public
ImVector::_grow_capacity	libs/imgui/imgui.h	/^    inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity\/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }$/;"	f	class:ImVector	access:public	signature:(int new_size)
ImVector::back	libs/imgui/imgui.h	/^    inline const value_type&    back() const                    { IM_ASSERT(Size > 0); return Data[Size-1]; }$/;"	f	class:ImVector	access:public	signature:() const
ImVector::back	libs/imgui/imgui.h	/^    inline value_type&          back()                          { IM_ASSERT(Size > 0); return Data[Size-1]; }$/;"	f	class:ImVector	access:public	signature:()
ImVector::begin	libs/imgui/imgui.h	/^    inline const_iterator       begin() const                   { return Data; }$/;"	f	class:ImVector	access:public	signature:() const
ImVector::begin	libs/imgui/imgui.h	/^    inline iterator             begin()                         { return Data; }$/;"	f	class:ImVector	access:public	signature:()
ImVector::capacity	libs/imgui/imgui.h	/^    inline int                  capacity() const                { return Capacity; }$/;"	f	class:ImVector	access:public	signature:() const
ImVector::clear	libs/imgui/imgui.h	/^    inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }$/;"	f	class:ImVector	access:public	signature:()
ImVector::const_iterator	libs/imgui/imgui.h	/^    typedef const value_type*   const_iterator;$/;"	t	class:ImVector	access:public
ImVector::empty	libs/imgui/imgui.h	/^    inline bool                 empty() const                   { return Size == 0; }$/;"	f	class:ImVector	access:public	signature:() const
ImVector::end	libs/imgui/imgui.h	/^    inline const_iterator       end() const                     { return Data + Size; }$/;"	f	class:ImVector	access:public	signature:() const
ImVector::end	libs/imgui/imgui.h	/^    inline iterator             end()                           { return Data + Size; }$/;"	f	class:ImVector	access:public	signature:()
ImVector::erase	libs/imgui/imgui.h	/^    inline iterator             erase(const_iterator it)        { IM_ASSERT(it >= begin() && it < end()); const ptrdiff_t off = it - begin(); memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(value_type)); Size--; return Data + off; }$/;"	f	class:ImVector	access:public	signature:(const_iterator it)
ImVector::front	libs/imgui/imgui.h	/^    inline const value_type&    front() const                   { IM_ASSERT(Size > 0); return Data[0]; }$/;"	f	class:ImVector	access:public	signature:() const
ImVector::front	libs/imgui/imgui.h	/^    inline value_type&          front()                         { IM_ASSERT(Size > 0); return Data[0]; }$/;"	f	class:ImVector	access:public	signature:()
ImVector::insert	libs/imgui/imgui.h	/^    inline iterator             insert(const_iterator it, const value_type& v)  { IM_ASSERT(it >= begin() && it <= end()); const ptrdiff_t off = it - begin(); if (Size == Capacity) reserve(Capacity ? Capacity * 2 : 4); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(value_type)); Data[off] = v; Size++; return Data + off; }$/;"	f	class:ImVector	access:public	signature:(const_iterator it, const value_type& v)
ImVector::iterator	libs/imgui/imgui.h	/^    typedef value_type*         iterator;$/;"	t	class:ImVector	access:public
ImVector::operator []	libs/imgui/imgui.h	/^    inline const value_type&    operator[](int i) const         { IM_ASSERT(i < Size); return Data[i]; }$/;"	f	class:ImVector	access:public	signature:(int i) const
ImVector::operator []	libs/imgui/imgui.h	/^    inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }$/;"	f	class:ImVector	access:public	signature:(int i)
ImVector::pop_back	libs/imgui/imgui.h	/^    inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }$/;"	f	class:ImVector	access:public	signature:()
ImVector::push_back	libs/imgui/imgui.h	/^    inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }$/;"	f	class:ImVector	access:public	signature:(const value_type& v)
ImVector::reserve	libs/imgui/imgui.h	/^    inline void                 reserve(int new_capacity)    $/;"	f	class:ImVector	access:public	signature:(int new_capacity)
ImVector::resize	libs/imgui/imgui.h	/^    inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }$/;"	f	class:ImVector	access:public	signature:(int new_size)
ImVector::size	libs/imgui/imgui.h	/^    inline int                  size() const                    { return Size; }$/;"	f	class:ImVector	access:public	signature:() const
ImVector::swap	libs/imgui/imgui.h	/^    inline void                 swap(ImVector<T>& rhs)          { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; value_type* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }$/;"	f	class:ImVector	access:public	signature:(ImVector<T>& rhs)
ImVector::value_type	libs/imgui/imgui.h	/^    typedef T                   value_type;$/;"	t	class:ImVector	access:public
ImVector::~ImVector	libs/imgui/imgui.h	/^    ~ImVector()                 { if (Data) ImGui::MemFree(Data); }$/;"	f	class:ImVector	access:public	signature:()
ImWchar	libs/imgui/imgui.h	/^typedef unsigned short ImWchar;     \/\/ character for keyboard input\/display$/;"	t
Image	libs/imgui/imgui.cpp	/^void ImGui::Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, const ImVec4& tint_col, const ImVec4& border_col)$/;"	f	class:ImGui	signature:(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, const ImVec4& tint_col, const ImVec4& border_col)
Image	libs/imgui/imgui.h	/^    IMGUI_API void          Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0), const ImVec2& uv1 = ImVec2(1,1), const ImVec4& tint_col = ImVec4(1,1,1,1), const ImVec4& border_col = ImVec4(0,0,0,0));$/;"	p	namespace:ImGui	signature:(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0), const ImVec2& uv1 = ImVec2(1,1), const ImVec4& tint_col = ImVec4(1,1,1,1), const ImVec4& border_col = ImVec4(0,0,0,0))
ImageButton	libs/imgui/imgui.cpp	/^bool ImGui::ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, int frame_padding, const ImVec4& bg_col, const ImVec4& tint_col)$/;"	f	class:ImGui	signature:(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, int frame_padding, const ImVec4& bg_col, const ImVec4& tint_col)
ImageButton	libs/imgui/imgui.h	/^    IMGUI_API bool          ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0),  const ImVec2& uv1 = ImVec2(1,1), int frame_padding = -1, const ImVec4& bg_col = ImVec4(0,0,0,0), const ImVec4& tint_col = ImVec4(1,1,1,1));    \/\/ <0 frame_padding uses default frame padding settings. 0 for no padding$/;"	p	namespace:ImGui	signature:(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0), const ImVec2& uv1 = ImVec2(1,1), int frame_padding = -1, const ImVec4& bg_col = ImVec4(0,0,0,0), const ImVec4& tint_col = ImVec4(1,1,1,1))
ImeSetInputScreenPosFn	libs/imgui/imgui.h	/^    void        (*ImeSetInputScreenPosFn)(int x, int y);$/;"	m	struct:ImGuiIO	access:public
ImeSetInputScreenPosFn_DefaultImpl	libs/imgui/imgui.cpp	/^static void         ImeSetInputScreenPosFn_DefaultImpl(int x, int y);$/;"	p	file:	signature:(int x, int y)
ImeSetInputScreenPosFn_DefaultImpl	libs/imgui/imgui.cpp	/^static void ImeSetInputScreenPosFn_DefaultImpl(int x, int y)$/;"	f	file:	signature:(int x, int y)
ImeSetInputScreenPosFn_DefaultImpl	libs/imgui/imgui.cpp	/^static void ImeSetInputScreenPosFn_DefaultImpl(int, int)$/;"	f	file:	signature:(int, int)
ImeWindowHandle	libs/imgui/imgui.h	/^    void*       ImeWindowHandle;            \/\/ (Windows) Set this to your HWND to get automatic IME cursor positioning.$/;"	m	struct:ImGuiIO	access:public
Indent	libs/imgui/imgui.cpp	/^void ImGui::Indent()$/;"	f	class:ImGui	signature:()
Indent	libs/imgui/imgui.h	/^    IMGUI_API void          Indent();                                                           \/\/ move content position toward the right by style.IndentSpacing pixels$/;"	p	namespace:ImGui	signature:()
IndentSpacing	libs/imgui/imgui.h	/^    float       IndentSpacing;              \/\/ Horizontal indentation when e.g. entering a tree node$/;"	m	struct:ImGuiStyle	access:public
IndexLookup	libs/imgui/imgui.h	/^    ImVector<int>               IndexLookup;        \/\/ Sparse. Index glyphs by Unicode code-point$/;"	m	struct:ImFont	access:public
IndexXAdvance	libs/imgui/imgui.h	/^    ImVector<float>             IndexXAdvance;      \/\/ Sparse. Glyphs->XAdvance directly indexable (for CalcTextSize functions which are often bottleneck in large UI)$/;"	m	struct:ImFont	access:public
IniFilename	libs/imgui/imgui.h	/^    const char*   IniFilename;              \/\/ = "imgui.ini"        \/\/ Path to .ini file. NULL to disable .ini saving.$/;"	m	struct:ImGuiIO	access:public
IniSavingRate	libs/imgui/imgui.h	/^    float         IniSavingRate;            \/\/ = 5.0f               \/\/ Maximum time between saving positions\/sizes to .ini file, in seconds.$/;"	m	struct:ImGuiIO	access:public
InitialText	libs/imgui/imgui.cpp	/^    ImVector<char>      InitialText;                    \/\/ backup of end-user buffer at the time of focus (in UTF-8, unaltered)$/;"	m	struct:ImGuiTextEditState	file:	access:public
Initialized	libs/imgui/imgui.cpp	/^    bool                    Initialized;$/;"	m	struct:ImGuiState	file:	access:public
Input	include/Input.h	/^namespace Input {$/;"	n
Input	src/Input.cpp	/^namespace Input {$/;"	n	file:
Input::isPressed	include/Input.h	/^    bool isPressed(int key);$/;"	p	namespace:Input	signature:(int key)
Input::isPressed	src/Input.cpp	/^    bool isPressed(int key) {$/;"	f	namespace:Input	signature:(int key)
Input::keyCallback	include/Input.h	/^    void keyCallback(GLFWwindow* window, int key, int scancode, int action, int mods);$/;"	p	namespace:Input	signature:(GLFWwindow* window, int key, int scancode, int action, int mods)
Input::keyCallback	src/Input.cpp	/^    void keyCallback(GLFWwindow* window, int key, int scancode, int action, int mods) {$/;"	f	namespace:Input	signature:(GLFWwindow* window, int key, int scancode, int action, int mods)
Input::keys	src/Input.cpp	/^    bool keys[1000] = {0};$/;"	m	namespace:Input	file:
Input::setState	include/Input.h	/^    void setState(int key, bool state);$/;"	p	namespace:Input	signature:(int key, bool state)
Input::setState	src/Input.cpp	/^    void setState(int key, bool state) {$/;"	f	namespace:Input	signature:(int key, bool state)
InputBuf	libs/imgui/imgui.cpp	/^    char                  InputBuf[256];$/;"	m	struct:ExampleAppConsole	file:	access:public
InputBuf	libs/imgui/imgui.h	/^    char                InputBuf[256];$/;"	m	struct:ImGuiTextFilter	access:public
InputBuf	src/util/Console.cpp	/^	char                  InputBuf[256];$/;"	m	struct:Console::Console	file:	access:public
InputCharacters	libs/imgui/imgui.h	/^    ImWchar     InputCharacters[16+1];      \/\/ List of characters input (translated by user from keypress+keyboard state). Fill using AddInputCharacter() helper.$/;"	m	struct:ImGuiIO	access:public
InputCursorScreenPos	libs/imgui/imgui.cpp	/^    ImVec2              InputCursorScreenPos;           \/\/ Cursor position in screen space to be used by IME callback.$/;"	m	struct:ImGuiTextEditState	file:	access:public
InputFloat	libs/imgui/imgui.cpp	/^bool ImGui::InputFloat(const char* label, float *v, float step, float step_fast, int decimal_precision, ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, float *v, float step, float step_fast, int decimal_precision, ImGuiInputTextFlags extra_flags)
InputFloat	libs/imgui/imgui.h	/^    IMGUI_API bool          InputFloat(const char* label, float* v, float step = 0.0f, float step_fast = 0.0f, int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, float* v, float step = 0.0f, float step_fast = 0.0f, int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0)
InputFloat2	libs/imgui/imgui.cpp	/^bool ImGui::InputFloat2(const char* label, float v[2], int decimal_precision, ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, float v[2], int decimal_precision, ImGuiInputTextFlags extra_flags)
InputFloat2	libs/imgui/imgui.h	/^    IMGUI_API bool          InputFloat2(const char* label, float v[2], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, float v[2], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0)
InputFloat3	libs/imgui/imgui.cpp	/^bool ImGui::InputFloat3(const char* label, float v[3], int decimal_precision, ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, float v[3], int decimal_precision, ImGuiInputTextFlags extra_flags)
InputFloat3	libs/imgui/imgui.h	/^    IMGUI_API bool          InputFloat3(const char* label, float v[3], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, float v[3], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0)
InputFloat4	libs/imgui/imgui.cpp	/^bool ImGui::InputFloat4(const char* label, float v[4], int decimal_precision, ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, float v[4], int decimal_precision, ImGuiInputTextFlags extra_flags)
InputFloat4	libs/imgui/imgui.h	/^    IMGUI_API bool          InputFloat4(const char* label, float v[4], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, float v[4], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0)
InputFloatN	libs/imgui/imgui.cpp	/^static bool InputFloatN(const char* label, float* v, int components, int decimal_precision, ImGuiInputTextFlags extra_flags)$/;"	f	file:	signature:(const char* label, float* v, int components, int decimal_precision, ImGuiInputTextFlags extra_flags)
InputFloatReplaceWidget	libs/imgui/imgui.cpp	/^static bool InputFloatReplaceWidget(const ImRect& aabb, const char* label, float* v, ImGuiID id, int decimal_precision)$/;"	f	file:	signature:(const ImRect& aabb, const char* label, float* v, ImGuiID id, int decimal_precision)
InputInt	libs/imgui/imgui.cpp	/^bool ImGui::InputInt(const char* label, int *v, int step, int step_fast, ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, int *v, int step, int step_fast, ImGuiInputTextFlags extra_flags)
InputInt	libs/imgui/imgui.h	/^    IMGUI_API bool          InputInt(const char* label, int* v, int step = 1, int step_fast = 100, ImGuiInputTextFlags extra_flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, int* v, int step = 1, int step_fast = 100, ImGuiInputTextFlags extra_flags = 0)
InputInt2	libs/imgui/imgui.cpp	/^bool ImGui::InputInt2(const char* label, int v[2], ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, int v[2], ImGuiInputTextFlags extra_flags)
InputInt2	libs/imgui/imgui.h	/^    IMGUI_API bool          InputInt2(const char* label, int v[2], ImGuiInputTextFlags extra_flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, int v[2], ImGuiInputTextFlags extra_flags = 0)
InputInt3	libs/imgui/imgui.cpp	/^bool ImGui::InputInt3(const char* label, int v[3], ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, int v[3], ImGuiInputTextFlags extra_flags)
InputInt3	libs/imgui/imgui.h	/^    IMGUI_API bool          InputInt3(const char* label, int v[3], ImGuiInputTextFlags extra_flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, int v[3], ImGuiInputTextFlags extra_flags = 0)
InputInt4	libs/imgui/imgui.cpp	/^bool ImGui::InputInt4(const char* label, int v[4], ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, int v[4], ImGuiInputTextFlags extra_flags)
InputInt4	libs/imgui/imgui.h	/^    IMGUI_API bool          InputInt4(const char* label, int v[4], ImGuiInputTextFlags extra_flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, int v[4], ImGuiInputTextFlags extra_flags = 0)
InputIntN	libs/imgui/imgui.cpp	/^static bool InputIntN(const char* label, int* v, int components, ImGuiInputTextFlags extra_flags)$/;"	f	file:	signature:(const char* label, int* v, int components, ImGuiInputTextFlags extra_flags)
InputText	libs/imgui/imgui.cpp	/^bool ImGui::InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)$/;"	f	class:ImGui	signature:(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)
InputText	libs/imgui/imgui.h	/^    IMGUI_API bool          InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiTextEditCallback callback = NULL, void* user_data = NULL);$/;"	p	namespace:ImGui	signature:(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiTextEditCallback callback = NULL, void* user_data = NULL)
InputTextApplyArithmeticOp	libs/imgui/imgui.cpp	/^static void InputTextApplyArithmeticOp(const char* buf, float *v)$/;"	f	file:	signature:(const char* buf, float *v)
InputTextCalcTextLenAndLineCount	libs/imgui/imgui.cpp	/^static int InputTextCalcTextLenAndLineCount(const char* text_begin, const char** out_text_end)$/;"	f	file:	signature:(const char* text_begin, const char** out_text_end)
InputTextCalcTextSizeW	libs/imgui/imgui.cpp	/^static ImVec2 InputTextCalcTextSizeW(const ImWchar* text_begin, const ImWchar* text_end, const ImWchar** remaining = NULL, ImVec2* out_offset = NULL, bool stop_on_new_line = false)$/;"	f	file:	signature:(const ImWchar* text_begin, const ImWchar* text_end, const ImWchar** remaining = NULL, ImVec2* out_offset = NULL, bool stop_on_new_line = false)
InputTextEx	libs/imgui/imgui.cpp	/^static bool         InputTextEx(const char* label, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback = NULL, void* user_data = NULL);$/;"	p	file:	signature:(const char* label, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback = NULL, void* user_data = NULL)
InputTextEx	libs/imgui/imgui.cpp	/^static bool InputTextEx(const char* label, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)$/;"	f	file:	signature:(const char* label, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)
InputTextFilterCharacter	libs/imgui/imgui.cpp	/^static bool InputTextFilterCharacter(unsigned int* p_char, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)$/;"	f	file:	signature:(unsigned int* p_char, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)
InputTextMultiline	libs/imgui/imgui.cpp	/^bool ImGui::InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)$/;"	f	class:ImGui	signature:(const char* label, char* buf, size_t buf_size, const ImVec2& size, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)
InputTextMultiline	libs/imgui/imgui.h	/^    IMGUI_API bool          InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size = ImVec2(0,0), ImGuiInputTextFlags flags = 0, ImGuiTextEditCallback callback = NULL, void* user_data = NULL);$/;"	p	namespace:ImGui	signature:(const char* label, char* buf, size_t buf_size, const ImVec2& size = ImVec2(0,0), ImGuiInputTextFlags flags = 0, ImGuiTextEditCallback callback = NULL, void* user_data = NULL)
InputTextState	libs/imgui/imgui.cpp	/^    ImGuiTextEditState      InputTextState;$/;"	m	struct:ImGuiState	file:	access:public
InsertChars	libs/imgui/imgui.cpp	/^void ImGuiTextEditCallbackData::InsertChars(int pos, const char* new_text, const char* new_text_end)$/;"	f	class:ImGuiTextEditCallbackData	signature:(int pos, const char* new_text, const char* new_text_end)
InsertChars	libs/imgui/imgui.h	/^    void InsertChars(int pos, const char* text, const char* text_end = NULL);$/;"	p	struct:ImGuiTextEditCallbackData	access:public	signature:(int pos, const char* text, const char* text_end = NULL)
InvisibleButton	libs/imgui/imgui.cpp	/^bool ImGui::InvisibleButton(const char* str_id, const ImVec2& size)$/;"	f	class:ImGui	signature:(const char* str_id, const ImVec2& size)
InvisibleButton	libs/imgui/imgui.h	/^    IMGUI_API bool          InvisibleButton(const char* str_id, const ImVec2& size);$/;"	p	namespace:ImGui	signature:(const char* str_id, const ImVec2& size)
IsActive	libs/imgui/imgui.h	/^    bool IsActive() const { return !Filters.empty(); }$/;"	f	struct:ImGuiTextFilter	access:public	signature:() const
IsAnyItemActive	libs/imgui/imgui.cpp	/^bool ImGui::IsAnyItemActive()$/;"	f	class:ImGui	signature:()
IsAnyItemActive	libs/imgui/imgui.h	/^    IMGUI_API bool          IsAnyItemActive();$/;"	p	namespace:ImGui	signature:()
IsAnyItemHovered	libs/imgui/imgui.cpp	/^bool ImGui::IsAnyItemHovered()$/;"	f	class:ImGui	signature:()
IsAnyItemHovered	libs/imgui/imgui.h	/^    IMGUI_API bool          IsAnyItemHovered();$/;"	p	namespace:ImGui	signature:()
IsClipped	libs/imgui/imgui.h	/^    static inline bool      IsClipped(const ImVec2& size) { return !IsRectVisible(size); }     \/\/ OBSOLETE 1.38+$/;"	f	namespace:ImGui	signature:(const ImVec2& size)
IsClippedEx	libs/imgui/imgui.cpp	/^static bool         IsClippedEx(const ImRect& bb, const ImGuiID* id, bool clip_even_when_logged);$/;"	p	file:	signature:(const ImRect& bb, const ImGuiID* id, bool clip_even_when_logged)
IsClippedEx	libs/imgui/imgui.cpp	/^static bool IsClippedEx(const ImRect& bb, const ImGuiID* id, bool clip_even_when_logged)$/;"	f	file:	signature:(const ImRect& bb, const ImGuiID* id, bool clip_even_when_logged)
IsHovered	libs/imgui/imgui.cpp	/^static bool IsHovered(const ImRect& bb, ImGuiID id, bool flatten_childs = false)$/;"	f	file:	signature:(const ImRect& bb, ImGuiID id, bool flatten_childs = false)
IsItemActive	libs/imgui/imgui.cpp	/^bool ImGui::IsItemActive()$/;"	f	class:ImGui	signature:()
IsItemActive	libs/imgui/imgui.h	/^    IMGUI_API bool          IsItemActive();                                                     \/\/ was the last item active? (e.g. button being held, text field being edited- items that don't interact will always return false)$/;"	p	namespace:ImGui	signature:()
IsItemHovered	libs/imgui/imgui.cpp	/^bool ImGui::IsItemHovered()$/;"	f	class:ImGui	signature:()
IsItemHovered	libs/imgui/imgui.h	/^    IMGUI_API bool          IsItemHovered();                                                    \/\/ was the last item hovered by mouse?$/;"	p	namespace:ImGui	signature:()
IsItemHoveredRect	libs/imgui/imgui.cpp	/^bool ImGui::IsItemHoveredRect()$/;"	f	class:ImGui	signature:()
IsItemHoveredRect	libs/imgui/imgui.h	/^    IMGUI_API bool          IsItemHoveredRect();                                                \/\/ was the last item hovered by mouse? even if another item is active while we are hovering this$/;"	p	namespace:ImGui	signature:()
IsItemVisible	libs/imgui/imgui.cpp	/^bool ImGui::IsItemVisible()$/;"	f	class:ImGui	signature:()
IsItemVisible	libs/imgui/imgui.h	/^    IMGUI_API bool          IsItemVisible();$/;"	p	namespace:ImGui	signature:()
IsKeyDown	libs/imgui/imgui.cpp	/^bool ImGui::IsKeyDown(int key_index)$/;"	f	class:ImGui	signature:(int key_index)
IsKeyDown	libs/imgui/imgui.h	/^    IMGUI_API bool          IsKeyDown(int key_index);                                           \/\/ key_index into the keys_down[] array, imgui doesn't know the semantic of each entry, uses your own indices!$/;"	p	namespace:ImGui	signature:(int key_index)
IsKeyPressed	libs/imgui/imgui.cpp	/^bool ImGui::IsKeyPressed(int key_index, bool repeat)$/;"	f	class:ImGui	signature:(int key_index, bool repeat)
IsKeyPressed	libs/imgui/imgui.h	/^    IMGUI_API bool          IsKeyPressed(int key_index, bool repeat = true);                    \/\/ uses user's key indices as stored in the keys_down[] array. if repeat=true. uses io.KeyRepeatDelay \/ KeyRepeatRate$/;"	p	namespace:ImGui	signature:(int key_index, bool repeat = true)
IsKeyPressedMap	libs/imgui/imgui.cpp	/^static bool         IsKeyPressedMap(ImGuiKey key, bool repeat = true);$/;"	p	file:	signature:(ImGuiKey key, bool repeat = true)
IsKeyPressedMap	libs/imgui/imgui.cpp	/^static bool IsKeyPressedMap(ImGuiKey key, bool repeat)$/;"	f	file:	signature:(ImGuiKey key, bool repeat)
IsKeyReleased	libs/imgui/imgui.cpp	/^bool ImGui::IsKeyReleased(int key_index)$/;"	f	class:ImGui	signature:(int key_index)
IsKeyReleased	libs/imgui/imgui.h	/^    IMGUI_API bool          IsKeyReleased(int key_index);                                       \/\/ "$/;"	p	namespace:ImGui	signature:(int key_index)
IsLoaded	libs/imgui/imgui.h	/^    IMGUI_API bool              IsLoaded() const                        { return ContainerAtlas != NULL; }$/;"	f	struct:ImFont	access:public	signature:() const
IsMouseClicked	libs/imgui/imgui.cpp	/^bool ImGui::IsMouseClicked(int button, bool repeat)$/;"	f	class:ImGui	signature:(int button, bool repeat)
IsMouseClicked	libs/imgui/imgui.h	/^    IMGUI_API bool          IsMouseClicked(int button, bool repeat = false);                    \/\/ did mouse button clicked (went from !Down to Down)$/;"	p	namespace:ImGui	signature:(int button, bool repeat = false)
IsMouseDoubleClicked	libs/imgui/imgui.cpp	/^bool ImGui::IsMouseDoubleClicked(int button)$/;"	f	class:ImGui	signature:(int button)
IsMouseDoubleClicked	libs/imgui/imgui.h	/^    IMGUI_API bool          IsMouseDoubleClicked(int button);                                   \/\/ did mouse button double-clicked. a double-click returns false in IsMouseClicked(). uses io.MouseDoubleClickTime.$/;"	p	namespace:ImGui	signature:(int button)
IsMouseDown	libs/imgui/imgui.cpp	/^bool ImGui::IsMouseDown(int button)$/;"	f	class:ImGui	signature:(int button)
IsMouseDown	libs/imgui/imgui.h	/^    IMGUI_API bool          IsMouseDown(int button);                                            \/\/ is mouse button held $/;"	p	namespace:ImGui	signature:(int button)
IsMouseDragging	libs/imgui/imgui.cpp	/^bool ImGui::IsMouseDragging(int button, float lock_threshold)$/;"	f	class:ImGui	signature:(int button, float lock_threshold)
IsMouseDragging	libs/imgui/imgui.h	/^    IMGUI_API bool          IsMouseDragging(int button = 0, float lock_threshold = -1.0f);      \/\/ is mouse dragging. if lock_threshold < -1.0f uses io.MouseDraggingThreshold$/;"	p	namespace:ImGui	signature:(int button = 0, float lock_threshold = -1.0f)
IsMouseHoveringAnyWindow	libs/imgui/imgui.cpp	/^bool ImGui::IsMouseHoveringAnyWindow()$/;"	f	class:ImGui	signature:()
IsMouseHoveringAnyWindow	libs/imgui/imgui.h	/^    IMGUI_API bool          IsMouseHoveringAnyWindow();                                         \/\/ is mouse hovering any active imgui window$/;"	p	namespace:ImGui	signature:()
IsMouseHoveringBox	libs/imgui/imgui.h	/^    static inline bool      IsMouseHoveringBox(const ImVec2& rect_min, const ImVec2& rect_max) { return IsMouseHoveringRect(rect_min, rect_max); }  \/\/ OBSOLETE 1.36+$/;"	f	namespace:ImGui	signature:(const ImVec2& rect_min, const ImVec2& rect_max)
IsMouseHoveringRect	libs/imgui/imgui.cpp	/^bool ImGui::IsMouseHoveringRect(const ImVec2& rect_min, const ImVec2& rect_max)$/;"	f	class:ImGui	signature:(const ImVec2& rect_min, const ImVec2& rect_max)
IsMouseHoveringRect	libs/imgui/imgui.cpp	/^static bool         IsMouseHoveringRect(const ImRect& bb);$/;"	p	file:	signature:(const ImRect& bb)
IsMouseHoveringRect	libs/imgui/imgui.cpp	/^static bool IsMouseHoveringRect(const ImRect& rect)$/;"	f	file:	signature:(const ImRect& rect)
IsMouseHoveringRect	libs/imgui/imgui.h	/^    IMGUI_API bool          IsMouseHoveringRect(const ImVec2& rect_min, const ImVec2& rect_max);\/\/ is mouse hovering given bounding rect$/;"	p	namespace:ImGui	signature:(const ImVec2& rect_min, const ImVec2& rect_max)
IsMouseHoveringWindow	libs/imgui/imgui.cpp	/^bool ImGui::IsMouseHoveringWindow()$/;"	f	class:ImGui	signature:()
IsMouseHoveringWindow	libs/imgui/imgui.h	/^    IMGUI_API bool          IsMouseHoveringWindow();                                            \/\/ is mouse hovering current window ("window" in API names always refer to current window)$/;"	p	namespace:ImGui	signature:()
IsMouseReleased	libs/imgui/imgui.cpp	/^bool ImGui::IsMouseReleased(int button)$/;"	f	class:ImGui	signature:(int button)
IsMouseReleased	libs/imgui/imgui.h	/^    IMGUI_API bool          IsMouseReleased(int button);                                        \/\/ did mouse button released (went from Down to !Down)$/;"	p	namespace:ImGui	signature:(int button)
IsPopupOpen	libs/imgui/imgui.cpp	/^static bool IsPopupOpen(ImGuiID id)$/;"	f	file:	signature:(ImGuiID id)
IsPosHoveringAnyWindow	libs/imgui/imgui.cpp	/^bool ImGui::IsPosHoveringAnyWindow(const ImVec2& pos)$/;"	f	class:ImGui	signature:(const ImVec2& pos)
IsPosHoveringAnyWindow	libs/imgui/imgui.h	/^    IMGUI_API bool          IsPosHoveringAnyWindow(const ImVec2& pos);                          \/\/ is given position hovering any active imgui window$/;"	p	namespace:ImGui	signature:(const ImVec2& pos)
IsRectClipped	libs/imgui/imgui.h	/^    static inline bool      IsRectClipped(const ImVec2& size) { return !IsRectVisible(size); } \/\/ OBSOLETE 1.39+$/;"	f	namespace:ImGui	signature:(const ImVec2& size)
IsRectVisible	libs/imgui/imgui.cpp	/^bool ImGui::IsRectVisible(const ImVec2& size)$/;"	f	class:ImGui	signature:(const ImVec2& size)
IsRectVisible	libs/imgui/imgui.h	/^    IMGUI_API bool          IsRectVisible(const ImVec2& size);                                  \/\/ test if rectangle of given size starting from cursor pos is visible (not clipped). to perform coarse clipping on user's side (as an optimization)$/;"	p	namespace:ImGui	signature:(const ImVec2& size)
IsRootWindowFocused	libs/imgui/imgui.cpp	/^bool ImGui::IsRootWindowFocused()$/;"	f	class:ImGui	signature:()
IsRootWindowFocused	libs/imgui/imgui.h	/^    IMGUI_API bool          IsRootWindowFocused();                                              \/\/ is current root window focused (top parent window in case of child windows)$/;"	p	namespace:ImGui	signature:()
IsRootWindowOrAnyChildFocused	libs/imgui/imgui.cpp	/^bool ImGui::IsRootWindowOrAnyChildFocused()$/;"	f	class:ImGui	signature:()
IsRootWindowOrAnyChildFocused	libs/imgui/imgui.h	/^    IMGUI_API bool          IsRootWindowOrAnyChildFocused();                                    \/\/ is current root window or any of its child (including current window) focused$/;"	p	namespace:ImGui	signature:()
IsWindowCollapsed	libs/imgui/imgui.cpp	/^bool ImGui::IsWindowCollapsed()$/;"	f	class:ImGui	signature:()
IsWindowCollapsed	libs/imgui/imgui.h	/^    IMGUI_API bool          IsWindowCollapsed();$/;"	p	namespace:ImGui	signature:()
IsWindowContentHoverable	libs/imgui/imgui.cpp	/^static inline bool IsWindowContentHoverable(ImGuiWindow* window)$/;"	f	file:	signature:(ImGuiWindow* window)
IsWindowFocused	libs/imgui/imgui.cpp	/^bool ImGui::IsWindowFocused()$/;"	f	class:ImGui	signature:()
IsWindowFocused	libs/imgui/imgui.h	/^    IMGUI_API bool          IsWindowFocused();                                                  \/\/ is current window focused (differentiate child windows from each others)$/;"	p	namespace:ImGui	signature:()
IsWindowHovered	libs/imgui/imgui.cpp	/^bool ImGui::IsWindowHovered()$/;"	f	class:ImGui	signature:()
IsWindowHovered	libs/imgui/imgui.h	/^    IMGUI_API bool          IsWindowHovered();$/;"	p	namespace:ImGui	signature:()
ItemAdd	libs/imgui/imgui.cpp	/^static bool         ItemAdd(const ImRect& bb, const ImGuiID* id);$/;"	p	file:	signature:(const ImRect& bb, const ImGuiID* id)
ItemAdd	libs/imgui/imgui.cpp	/^static bool ItemAdd(const ImRect& bb, const ImGuiID* id)$/;"	f	file:	signature:(const ImRect& bb, const ImGuiID* id)
ItemInnerSpacing	libs/imgui/imgui.h	/^    ImVec2      ItemInnerSpacing;           \/\/ Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)$/;"	m	struct:ImGuiStyle	access:public
ItemSize	libs/imgui/imgui.cpp	/^static inline void ItemSize(const ImRect& bb, float text_offset_y)$/;"	f	file:	signature:(const ImRect& bb, float text_offset_y)
ItemSize	libs/imgui/imgui.cpp	/^static void         ItemSize(ImVec2 size, float text_offset_y = 0.0f);$/;"	p	file:	signature:(ImVec2 size, float text_offset_y = 0.0f)
ItemSize	libs/imgui/imgui.cpp	/^static void         ItemSize(const ImRect& bb, float text_offset_y = 0.0f);$/;"	p	file:	signature:(const ImRect& bb, float text_offset_y = 0.0f)
ItemSize	libs/imgui/imgui.cpp	/^static void ItemSize(ImVec2 size, float text_offset_y)$/;"	f	file:	signature:(ImVec2 size, float text_offset_y)
ItemSpacing	libs/imgui/imgui.h	/^    ImVec2      ItemSpacing;                \/\/ Horizontal and vertical spacing between widgets\/lines$/;"	m	struct:ImGuiStyle	access:public
ItemWidth	libs/imgui/imgui.cpp	/^    float                   ItemWidth;              \/\/ == ItemWidthStack.back(). 0.0: default, >0.0: width in pixels, <0.0: align xx pixels to the right of window$/;"	m	struct:ImGuiDrawContext	file:	access:public
ItemWidthDefault	libs/imgui/imgui.cpp	/^    float                   ItemWidthDefault;$/;"	m	struct:ImGuiWindow	file:	access:public
ItemWidthStack	libs/imgui/imgui.cpp	/^    ImVector<float>         ItemWidthStack;$/;"	m	struct:ImGuiDrawContext	file:	access:public
Items	libs/imgui/imgui.cpp	/^    ImVector<char*>       Items;$/;"	m	struct:ExampleAppConsole	file:	access:public
Items	src/util/Console.cpp	/^	ImVector<char*>       Items;$/;"	m	struct:Console::Console	file:	access:public
ItemsCount	libs/imgui/imgui.h	/^    int ItemsCount, DisplayStart, DisplayEnd;$/;"	m	struct:ImGuiListClipper	access:public
ItemsHeight	libs/imgui/imgui.h	/^    float ItemsHeight;$/;"	m	struct:ImGuiListClipper	access:public
Items_ArrayGetter	libs/imgui/imgui.cpp	/^static bool Items_ArrayGetter(void* data, int idx, const char** out_text)$/;"	f	file:	signature:(void* data, int idx, const char** out_text)
Items_SingleStringGetter	libs/imgui/imgui.cpp	/^static bool Items_SingleStringGetter(void* data, int idx, const char** out_text)$/;"	f	file:	signature:(void* data, int idx, const char** out_text)
JUMP	include/Input.h	/^    const int JUMP = GLFW_KEY_SPACE;$/;"	m	namespace:Key
Key	include/Input.h	/^namespace Key {$/;"	n
Key::CONSOLE	include/Input.h	/^    const int CONSOLE = GLFW_KEY_F4;$/;"	m	namespace:Key
Key::DEBUG	include/Input.h	/^    const int DEBUG = GLFW_KEY_F3;$/;"	m	namespace:Key
Key::DOWN	include/Input.h	/^    const int DOWN = GLFW_KEY_S;$/;"	m	namespace:Key
Key::JUMP	include/Input.h	/^    const int JUMP = GLFW_KEY_SPACE;$/;"	m	namespace:Key
Key::LEFT	include/Input.h	/^    const int LEFT = GLFW_KEY_A;$/;"	m	namespace:Key
Key::PAUSE	include/Input.h	/^    const int PAUSE = GLFW_KEY_ESCAPE;$/;"	m	namespace:Key
Key::RIGHT	include/Input.h	/^    const int RIGHT = GLFW_KEY_D;$/;"	m	namespace:Key
Key::UP	include/Input.h	/^    const int UP = GLFW_KEY_W;$/;"	m	namespace:Key
KeyAlt	libs/imgui/imgui.h	/^    bool        KeyAlt;                     \/\/ Keyboard modifier pressed: Alt$/;"	m	struct:ImGuiIO	access:public
KeyCtrl	libs/imgui/imgui.h	/^    bool        KeyCtrl;                    \/\/ Keyboard modifier pressed: Control$/;"	m	struct:ImGuiIO	access:public
KeyMap	libs/imgui/imgui.h	/^    int           KeyMap[ImGuiKey_COUNT];   \/\/ <unset>              \/\/ Map of indices into the KeysDown[512] entries array$/;"	m	struct:ImGuiIO	access:public
KeyRepeatDelay	libs/imgui/imgui.h	/^    float         KeyRepeatDelay;           \/\/ = 0.250f             \/\/ When holding a key\/button, time before it starts repeating, in seconds. (for actions where 'repeat' is active)$/;"	m	struct:ImGuiIO	access:public
KeyRepeatRate	libs/imgui/imgui.h	/^    float         KeyRepeatRate;            \/\/ = 0.020f             \/\/ When holding a key\/button, rate at which it repeats, in seconds.$/;"	m	struct:ImGuiIO	access:public
KeyShift	libs/imgui/imgui.h	/^    bool        KeyShift;                   \/\/ Keyboard modifier pressed: Shift$/;"	m	struct:ImGuiIO	access:public
KeysDown	libs/imgui/imgui.h	/^    bool        KeysDown[512];              \/\/ Keyboard keys that are pressed (in whatever storage order you naturally have access to keyboard data)$/;"	m	struct:ImGuiIO	access:public
KeysDownDuration	libs/imgui/imgui.h	/^    float       KeysDownDuration[512];      \/\/ Duration the keyboard key has been down (0.0f == just pressed)$/;"	m	struct:ImGuiIO	access:public
KeysDownDurationPrev	libs/imgui/imgui.h	/^    float       KeysDownDurationPrev[512];  \/\/ Previous duration the key has been down$/;"	m	struct:ImGuiIO	access:public
LEFT	include/Input.h	/^    const int LEFT = GLFW_KEY_A;$/;"	m	namespace:Key
LEGACY	include/Standard.h	20;"	d
LEVEL_H	include/level/Level.h	2;"	d
LIBS	GaffMaker/Makefile	/^LIBS = libpng16$/;"	m
LIBS	Makefile	/^LIBS = libprocps glew glfw3 $(shell pkg-config --print-requires --print-requires-private glfw3)$/;"	m
LIBS2	Makefile	/^LIBS2 = libs\/imgui\/imgui.o libs\/imgui\/imgui_impl_glfw_gl3.o$/;"	m
LIBSwin	Makefile	/^LIBSwin = -lglew32 -lglfw3 -lopengl32$/;"	m
LOAD_PNG_H	GaffMaker/include/LoadPNG.h	2;"	d
LOG_H	include/util/Log.h	2;"	d
LabelText	libs/imgui/imgui.cpp	/^void ImGui::LabelText(const char* label, const char* fmt, ...)$/;"	f	class:ImGui	signature:(const char* label, const char* fmt, ...)
LabelText	libs/imgui/imgui.h	/^    IMGUI_API void          LabelText(const char* label, const char* fmt, ...);                 \/\/ display text+label aligned the same way as value+label widgets $/;"	p	namespace:ImGui	signature:(const char* label, const char* fmt, ...)
LabelTextV	libs/imgui/imgui.cpp	/^void ImGui::LabelTextV(const char* label, const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const char* label, const char* fmt, va_list args)
LabelTextV	libs/imgui/imgui.h	/^    IMGUI_API void          LabelTextV(const char* label, const char* fmt, va_list args);$/;"	p	namespace:ImGui	signature:(const char* label, const char* fmt, va_list args)
LastFrameDrawn	libs/imgui/imgui.cpp	/^    int                     LastFrameDrawn;$/;"	m	struct:ImGuiWindow	file:	access:public
LastItemHoveredAndUsable	libs/imgui/imgui.cpp	/^    bool                    LastItemHoveredAndUsable;$/;"	m	struct:ImGuiDrawContext	file:	access:public
LastItemHoveredRect	libs/imgui/imgui.cpp	/^    bool                    LastItemHoveredRect;$/;"	m	struct:ImGuiDrawContext	file:	access:public
LastItemID	libs/imgui/imgui.cpp	/^    ImGuiID                 LastItemID;$/;"	m	struct:ImGuiDrawContext	file:	access:public
LastItemRect	libs/imgui/imgui.cpp	/^    ImRect                  LastItemRect;$/;"	m	struct:ImGuiDrawContext	file:	access:public
LayoutType	libs/imgui/imgui.cpp	/^    ImGuiLayoutType         LayoutType;$/;"	m	struct:ImGuiDrawContext	file:	access:public
Level	include/level/Level.h	/^namespace Level {$/;"	n
Level	src/level/Level.cpp	/^namespace Level {$/;"	n	file:
Level::end	include/level/Level.h	/^    void end();$/;"	p	namespace:Level	signature:()
Level::end	src/level/Level.cpp	/^    void end() {$/;"	f	namespace:Level	signature:()
Level::entity	src/level/Level.cpp	/^    Entity entity;$/;"	m	namespace:Level	file:
Level::getPlayer	include/level/Level.h	/^    Entity* getPlayer();$/;"	p	namespace:Level	signature:()
Level::getPlayer	src/level/Level.cpp	/^    Entity* getPlayer() {$/;"	f	namespace:Level	signature:()
Level::height	include/level/Level.h	/^    const int height = 48;$/;"	m	namespace:Level
Level::init	include/level/Level.h	/^    void init();$/;"	p	namespace:Level	signature:()
Level::init	src/level/Level.cpp	/^    void init() {$/;"	f	namespace:Level	signature:()
Level::layout	src/level/Level.cpp	/^    byte layout[Level::height][Level::width];$/;"	m	namespace:Level	file:
Level::layout0	src/level/Level.cpp	/^    byte layout0[Level::height][Level::width];$/;"	m	namespace:Level	file:
Level::render	include/level/Level.h	/^    void render();$/;"	p	namespace:Level	signature:()
Level::render	src/level/Level.cpp	/^    void render() {$/;"	f	namespace:Level	signature:()
Level::tick	include/level/Level.h	/^    void tick();$/;"	p	namespace:Level	signature:()
Level::tick	src/level/Level.cpp	/^    void tick() {$/;"	f	namespace:Level	signature:()
Level::tileOffset	src/level/Level.cpp	/^    const mat4 tileOffset = translate(IDENTITY, vec3(8, 8, 0));$/;"	m	namespace:Level	file:
Level::tileScale	src/level/Level.cpp	/^    const mat4 tileScale = scale(IDENTITY, vec3(Level::tileScaleInt));$/;"	m	namespace:Level	file:
Level::tileScaleInt	include/level/Level.h	/^    const int tileScaleInt = 16;$/;"	m	namespace:Level
Level::width	include/level/Level.h	/^    const int width = 64;$/;"	m	namespace:Level
ListBox	libs/imgui/imgui.cpp	/^bool ImGui::ListBox(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int height_in_items)$/;"	f	class:ImGui	signature:(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int height_in_items)
ListBox	libs/imgui/imgui.cpp	/^bool ImGui::ListBox(const char* label, int* current_item, const char** items, int items_count, int height_items)$/;"	f	class:ImGui	signature:(const char* label, int* current_item, const char** items, int items_count, int height_items)
ListBox	libs/imgui/imgui.h	/^    IMGUI_API bool          ListBox(const char* label, int* current_item, bool (*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int height_in_items = -1);$/;"	p	namespace:ImGui	signature:(const char* label, int* current_item, bool (*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int height_in_items = -1)
ListBox	libs/imgui/imgui.h	/^    IMGUI_API bool          ListBox(const char* label, int* current_item, const char** items, int items_count, int height_in_items = -1);$/;"	p	namespace:ImGui	signature:(const char* label, int* current_item, const char** items, int items_count, int height_in_items = -1)
ListBoxFooter	libs/imgui/imgui.cpp	/^void ImGui::ListBoxFooter()$/;"	f	class:ImGui	signature:()
ListBoxFooter	libs/imgui/imgui.h	/^    IMGUI_API void          ListBoxFooter();                                                    \/\/ terminate the scrolling region$/;"	p	namespace:ImGui	signature:()
ListBoxHeader	libs/imgui/imgui.cpp	/^bool ImGui::ListBoxHeader(const char* label, const ImVec2& size_arg)$/;"	f	class:ImGui	signature:(const char* label, const ImVec2& size_arg)
ListBoxHeader	libs/imgui/imgui.cpp	/^bool ImGui::ListBoxHeader(const char* label, int items_count, int height_in_items)$/;"	f	class:ImGui	signature:(const char* label, int items_count, int height_in_items)
ListBoxHeader	libs/imgui/imgui.h	/^    IMGUI_API bool          ListBoxHeader(const char* label, const ImVec2& size = ImVec2(0,0)); \/\/ use if you want to reimplement ListBox() will custom data or interactions. make sure to call ListBoxFooter() afterwards.$/;"	p	namespace:ImGui	signature:(const char* label, const ImVec2& size = ImVec2(0,0))
ListBoxHeader	libs/imgui/imgui.h	/^    IMGUI_API bool          ListBoxHeader(const char* label, int items_count, int height_in_items = -1); \/\/ "$/;"	p	namespace:ImGui	signature:(const char* label, int items_count, int height_in_items = -1)
LoadSettings	libs/imgui/imgui.cpp	/^static void LoadSettings()$/;"	f	file:	signature:()
Log	include/util/Log.h	/^namespace Log {$/;"	n
Log	src/util/Log.cpp	/^namespace Log {$/;"	n	file:
Log::print	include/util/Log.h	/^    void print(std::string msg, int type);$/;"	p	namespace:Log	signature:(std::string msg, int type)
Log::print	src/util/Log.cpp	/^    void print(std::string msg, int type) {$/;"	f	namespace:Log	signature:(std::string msg, int type)
LogAutoExpandMaxDepth	libs/imgui/imgui.cpp	/^    int                     LogAutoExpandMaxDepth;$/;"	m	struct:ImGuiState	file:	access:public
LogButtons	libs/imgui/imgui.cpp	/^void ImGui::LogButtons()$/;"	f	class:ImGui	signature:()
LogButtons	libs/imgui/imgui.h	/^    IMGUI_API void          LogButtons();                                                       \/\/ helper to display buttons for logging to tty\/file\/clipboard$/;"	p	namespace:ImGui	signature:()
LogClipboard	libs/imgui/imgui.cpp	/^    ImGuiTextBuffer*        LogClipboard;                       \/\/ pointer so our GImGui static constructor doesn't call heap allocators.$/;"	m	struct:ImGuiState	file:	access:public
LogEnabled	libs/imgui/imgui.cpp	/^    bool                    LogEnabled;$/;"	m	struct:ImGuiState	file:	access:public
LogFile	libs/imgui/imgui.cpp	/^    FILE*                   LogFile;$/;"	m	struct:ImGuiState	file:	access:public
LogFilename	libs/imgui/imgui.h	/^    const char*   LogFilename;              \/\/ = "imgui_log.txt"    \/\/ Path to .log file (default parameter to ImGui::LogToFile when no file is specified).$/;"	m	struct:ImGuiIO	access:public
LogFinish	libs/imgui/imgui.cpp	/^void ImGui::LogFinish()$/;"	f	class:ImGui	signature:()
LogFinish	libs/imgui/imgui.h	/^    IMGUI_API void          LogFinish();                                                        \/\/ stop logging (close file, etc.)$/;"	p	namespace:ImGui	signature:()
LogLinePosY	libs/imgui/imgui.cpp	/^    float                   LogLinePosY;$/;"	m	struct:ImGuiDrawContext	file:	access:public
LogStartDepth	libs/imgui/imgui.cpp	/^    int                     LogStartDepth;$/;"	m	struct:ImGuiState	file:	access:public
LogText	libs/imgui/imgui.cpp	/^static void         LogText(const ImVec2& ref_pos, const char* text, const char* text_end = NULL);$/;"	p	file:	signature:(const ImVec2& ref_pos, const char* text, const char* text_end = NULL)
LogText	libs/imgui/imgui.cpp	/^static void LogText(const ImVec2& ref_pos, const char* text, const char* text_end)$/;"	f	file:	signature:(const ImVec2& ref_pos, const char* text, const char* text_end)
LogText	libs/imgui/imgui.cpp	/^void ImGui::LogText(const char* fmt, ...)$/;"	f	class:ImGui	signature:(const char* fmt, ...)
LogText	libs/imgui/imgui.h	/^    IMGUI_API void          LogText(const char* fmt, ...);                                      \/\/ pass text data straight to log (without being displayed)$/;"	p	namespace:ImGui	signature:(const char* fmt, ...)
LogToClipboard	libs/imgui/imgui.cpp	/^void ImGui::LogToClipboard(int max_depth)$/;"	f	class:ImGui	signature:(int max_depth)
LogToClipboard	libs/imgui/imgui.h	/^    IMGUI_API void          LogToClipboard(int max_depth = -1);                                 \/\/ start logging to OS clipboard$/;"	p	namespace:ImGui	signature:(int max_depth = -1)
LogToFile	libs/imgui/imgui.cpp	/^void ImGui::LogToFile(int max_depth, const char* filename)$/;"	f	class:ImGui	signature:(int max_depth, const char* filename)
LogToFile	libs/imgui/imgui.h	/^    IMGUI_API void          LogToFile(int max_depth = -1, const char* filename = NULL);         \/\/ start logging to file$/;"	p	namespace:ImGui	signature:(int max_depth = -1, const char* filename = NULL)
LogToTTY	libs/imgui/imgui.cpp	/^void ImGui::LogToTTY(int max_depth)$/;"	f	class:ImGui	signature:(int max_depth)
LogToTTY	libs/imgui/imgui.h	/^    IMGUI_API void          LogToTTY(int max_depth = -1);                                       \/\/ start logging to tty$/;"	p	namespace:ImGui	signature:(int max_depth = -1)
LowerBound	libs/imgui/imgui.cpp	/^static ImVector<ImGuiStorage::Pair>::iterator LowerBound(ImVector<ImGuiStorage::Pair>& data, ImU32 key)$/;"	f	file:	signature:(ImVector<ImGuiStorage::Pair>& data, ImU32 key)
MAGIC	GaffMaker/include/Definitions.h	/^	static constexpr byte MAGIC[5] = {"GAFF"};$/;"	m	class:Gaff	access:public
MAGIC	include/Definitions.h	/^	static constexpr byte MAGIC[5] = {"GAFF"};$/;"	m	class:Gaff	access:public
MarkSettingsDirty	libs/imgui/imgui.cpp	/^static void MarkSettingsDirty()$/;"	f	file:	signature:()
Max	libs/imgui/imgui.cpp	/^    ImVec2      Max;$/;"	m	struct:ImRect	file:	access:public
MemAlloc	libs/imgui/imgui.cpp	/^void* ImGui::MemAlloc(size_t sz)$/;"	f	class:ImGui	signature:(size_t sz)
MemAlloc	libs/imgui/imgui.h	/^    IMGUI_API void*         MemAlloc(size_t sz);$/;"	p	namespace:ImGui	signature:(size_t sz)
MemAllocFn	libs/imgui/imgui.h	/^    void*       (*MemAllocFn)(size_t sz);$/;"	m	struct:ImGuiIO	access:public
MemFree	libs/imgui/imgui.cpp	/^void ImGui::MemFree(void* ptr)$/;"	f	class:ImGui	signature:(void* ptr)
MemFree	libs/imgui/imgui.h	/^    IMGUI_API void          MemFree(void* ptr);$/;"	p	namespace:ImGui	signature:(void* ptr)
MemFreeFn	libs/imgui/imgui.h	/^    void        (*MemFreeFn)(void* ptr);$/;"	m	struct:ImGuiIO	access:public
MenuBarAppending	libs/imgui/imgui.cpp	/^    bool                    MenuBarAppending;$/;"	m	struct:ImGuiDrawContext	file:	access:public
MenuBarHeight	libs/imgui/imgui.cpp	/^    float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }$/;"	f	struct:ImGuiWindow	access:public	signature:() const
MenuBarOffsetX	libs/imgui/imgui.cpp	/^    float                   MenuBarOffsetX;$/;"	m	struct:ImGuiDrawContext	file:	access:public
MenuBarRect	libs/imgui/imgui.cpp	/^    ImRect      MenuBarRect() const                     { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }$/;"	f	struct:ImGuiWindow	access:public	signature:() const
MenuColumns	libs/imgui/imgui.cpp	/^    ImGuiSimpleColumns      MenuColumns;                        \/\/ Simplified columns storage for menu items$/;"	m	struct:ImGuiWindow	file:	access:public
MenuItem	libs/imgui/imgui.cpp	/^bool ImGui::MenuItem(const char* label, const char* shortcut, bool selected, bool enabled)$/;"	f	class:ImGui	signature:(const char* label, const char* shortcut, bool selected, bool enabled)
MenuItem	libs/imgui/imgui.cpp	/^bool ImGui::MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled)$/;"	f	class:ImGui	signature:(const char* label, const char* shortcut, bool* p_selected, bool enabled)
MenuItem	libs/imgui/imgui.h	/^    IMGUI_API bool          MenuItem(const char* label, const char* shortcut = NULL, bool selected = false, bool enabled = true);  \/\/ return true when activated. shortcuts are displayed for convenience but not processed by ImGui at the moment$/;"	p	namespace:ImGui	signature:(const char* label, const char* shortcut = NULL, bool selected = false, bool enabled = true)
MenuItem	libs/imgui/imgui.h	/^    IMGUI_API bool          MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled = true);              \/\/ return true when activated + toggle (*p_selected) if p_selected != NULL$/;"	p	namespace:ImGui	signature:(const char* label, const char* shortcut, bool* p_selected, bool enabled = true)
MergeGlyphCenterV	libs/imgui/imgui.h	/^    bool            MergeGlyphCenterV;          \/\/ false    \/\/ When merging (multiple ImFontInput for one ImFont), vertically center new glyphs instead of aligning their baseline$/;"	m	struct:ImFontConfig	access:public
MergeMode	libs/imgui/imgui.h	/^    bool            MergeMode;                  \/\/ false    \/\/ Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs).$/;"	m	struct:ImFontConfig	access:public
MetricsActiveWindows	libs/imgui/imgui.h	/^    int         MetricsActiveWindows;       \/\/ Number of visible windows (exclude child windows)$/;"	m	struct:ImGuiIO	access:public
MetricsAllocs	libs/imgui/imgui.h	/^    int         MetricsAllocs;              \/\/ Number of active memory allocations$/;"	m	struct:ImGuiIO	access:public
MetricsRenderIndices	libs/imgui/imgui.h	/^    int         MetricsRenderIndices;       \/\/ $/;"	m	struct:ImGuiIO	access:public
MetricsRenderVertices	libs/imgui/imgui.h	/^    int         MetricsRenderVertices;      \/\/ Vertices processed during last call to Render()$/;"	m	struct:ImGuiIO	access:public
Min	libs/imgui/imgui.cpp	/^    ImVec2      Min;$/;"	m	struct:ImRect	file:	access:public
ModalWindowDarkeningRatio	libs/imgui/imgui.cpp	/^    float                   ModalWindowDarkeningRatio;$/;"	m	struct:ImGuiState	file:	access:public
MouseClicked	libs/imgui/imgui.h	/^    bool        MouseClicked[5];            \/\/ Mouse button went from !Down to Down$/;"	m	struct:ImGuiIO	access:public
MouseClickedPos	libs/imgui/imgui.h	/^    ImVec2      MouseClickedPos[5];         \/\/ Position at time of clicking$/;"	m	struct:ImGuiIO	access:public
MouseClickedTime	libs/imgui/imgui.h	/^    float       MouseClickedTime[5];        \/\/ Time of last click (used to figure out double-click)$/;"	m	struct:ImGuiIO	access:public
MouseCursor	libs/imgui/imgui.cpp	/^    ImGuiMouseCursor        MouseCursor;$/;"	m	struct:ImGuiState	file:	access:public
MouseCursorData	libs/imgui/imgui.cpp	/^    ImGuiMouseCursorData    MouseCursorData[ImGuiMouseCursor_Count_];$/;"	m	struct:ImGuiState	file:	access:public
MouseDelta	libs/imgui/imgui.h	/^    ImVec2      MouseDelta;                 \/\/ Mouse delta. Note that this is zero if either current or previous position are negative to allow mouse enabling\/disabling.$/;"	m	struct:ImGuiIO	access:public
MouseDoubleClickMaxDist	libs/imgui/imgui.h	/^    float         MouseDoubleClickMaxDist;  \/\/ = 6.0f               \/\/ Distance threshold to stay in to validate a double-click, in pixels.$/;"	m	struct:ImGuiIO	access:public
MouseDoubleClickTime	libs/imgui/imgui.h	/^    float         MouseDoubleClickTime;     \/\/ = 0.30f              \/\/ Time for a double-click, in seconds.$/;"	m	struct:ImGuiIO	access:public
MouseDoubleClicked	libs/imgui/imgui.h	/^    bool        MouseDoubleClicked[5];      \/\/ Has mouse button been double-clicked?$/;"	m	struct:ImGuiIO	access:public
MouseDown	libs/imgui/imgui.h	/^    bool        MouseDown[5];               \/\/ Mouse buttons. ImGui itself only uses button 0 (left button). Others buttons allows to track if mouse is being used by your application + available to user as a convenience via IsMouse** API.$/;"	m	struct:ImGuiIO	access:public
MouseDownDuration	libs/imgui/imgui.h	/^    float       MouseDownDuration[5];       \/\/ Duration the mouse button has been down (0.0f == just clicked)$/;"	m	struct:ImGuiIO	access:public
MouseDownDurationPrev	libs/imgui/imgui.h	/^    float       MouseDownDurationPrev[5];   \/\/ Previous time the mouse button has been down$/;"	m	struct:ImGuiIO	access:public
MouseDownOwned	libs/imgui/imgui.h	/^    bool        MouseDownOwned[5];          \/\/ Track if button was clicked inside a window. We don't request mouse capture from the application if click started outside ImGui bounds.$/;"	m	struct:ImGuiIO	access:public
MouseDragMaxDistanceSqr	libs/imgui/imgui.h	/^    float       MouseDragMaxDistanceSqr[5]; \/\/ Squared maximum distance of how much mouse has traveled from the click point$/;"	m	struct:ImGuiIO	access:public
MouseDragThreshold	libs/imgui/imgui.h	/^    float         MouseDragThreshold;       \/\/ = 6.0f               \/\/ Distance threshold before considering we are dragging$/;"	m	struct:ImGuiIO	access:public
MouseDrawCursor	libs/imgui/imgui.h	/^    bool        MouseDrawCursor;            \/\/ Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor).$/;"	m	struct:ImGuiIO	access:public
MousePos	libs/imgui/imgui.h	/^    ImVec2      MousePos;                   \/\/ Mouse position, in pixels (set to -1,-1 if no mouse \/ on another screen, etc.)$/;"	m	struct:ImGuiIO	access:public
MousePosPrev	libs/imgui/imgui.h	/^    ImVec2      MousePosPrev;               \/\/ Previous mouse position$/;"	m	struct:ImGuiIO	access:public
MouseReleased	libs/imgui/imgui.h	/^    bool        MouseReleased[5];           \/\/ Mouse button went from Down to !Down$/;"	m	struct:ImGuiIO	access:public
MouseWheel	libs/imgui/imgui.h	/^    float       MouseWheel;                 \/\/ Mouse wheel: 1 unit scrolls about 5 lines text. $/;"	m	struct:ImGuiIO	access:public
MoveID	libs/imgui/imgui.cpp	/^    ImGuiID                 MoveID;                             \/\/ == window->GetID("#MOVE")$/;"	m	struct:ImGuiWindow	file:	access:public
MovedWindow	libs/imgui/imgui.cpp	/^    ImGuiWindow*            MovedWindow;                        \/\/ Track the child window we clicked on to move a window. Pointer is only valid if ActiveID is the "#MOVE" identifier of a window.$/;"	m	struct:ImGuiState	file:	access:public
NAME	GaffMaker/Makefile	/^NAME = gaff$/;"	m
NAME	Makefile	/^NAME = build\/platformer$/;"	m
NAME	include/Window.h	/^const char NAME[] = "Platformer";$/;"	v
Name	libs/imgui/imgui.cpp	/^    char*                   Name;$/;"	m	struct:ImGuiWindow	file:	access:public
Name	libs/imgui/imgui.cpp	/^    char*   Name;$/;"	m	struct:ImGuiIniData	file:	access:public
Name	libs/imgui/imgui.h	/^    char            Name[32];                               \/\/ Name (strictly for debugging)$/;"	m	struct:ImFontConfig	access:public
NewFrame	libs/imgui/imgui.cpp	/^void ImGui::NewFrame()$/;"	f	class:ImGui	signature:()
NewFrame	libs/imgui/imgui.h	/^    IMGUI_API void          NewFrame();$/;"	p	namespace:ImGui	signature:()
NextColumn	libs/imgui/imgui.cpp	/^void ImGui::NextColumn()$/;"	f	class:ImGui	signature:()
NextColumn	libs/imgui/imgui.h	/^    IMGUI_API void          NextColumn();                                                       \/\/ next column$/;"	p	namespace:ImGui	signature:()
NextWidth	libs/imgui/imgui.cpp	/^    float  Width, NextWidth;$/;"	m	struct:ImGuiSimpleColumns	file:	access:public
NextWidths	libs/imgui/imgui.cpp	/^    float  Pos[8], NextWidths[8];$/;"	m	struct:ImGuiSimpleColumns	file:	access:public
OFFSETOF	libs/imgui/imgui_impl_glfw_gl3.cpp	215;"	d	file:
OFFSETOF	libs/imgui/imgui_impl_glfw_gl3.cpp	219;"	d	file:
Offset	libs/imgui/imgui.cpp	/^    ImVec2              Offset;$/;"	m	struct:ImGuiMouseCursorData	file:	access:public
OnKeyPressed	libs/imgui/imgui.cpp	/^    void                OnKeyPressed(int key);$/;"	p	struct:ImGuiTextEditState	file:	access:public	signature:(int key)
OnKeyPressed	libs/imgui/imgui.cpp	/^void ImGuiTextEditState::OnKeyPressed(int key)$/;"	f	class:ImGuiTextEditState	signature:(int key)
OpenNextNode	libs/imgui/imgui.h	/^    static inline void      OpenNextNode(bool open) { ImGui::SetNextTreeNodeOpened(open, 0); } \/\/ OBSOLETE 1.34+$/;"	f	namespace:ImGui	signature:(bool open)
OpenPopup	libs/imgui/imgui.cpp	/^void ImGui::OpenPopup(const char* str_id)$/;"	f	class:ImGui	signature:(const char* str_id)
OpenPopup	libs/imgui/imgui.h	/^    IMGUI_API void          OpenPopup(const char* str_id);                                      \/\/ mark popup as open. popup identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup needs to be at the same level). close childs popups if any. will close popup when user click outside, or activate a pressable item, or CloseCurrentPopup() is called within a BeginPopup()\/EndPopup() block.$/;"	p	namespace:ImGui	signature:(const char* str_id)
OpenedPopupStack	libs/imgui/imgui.cpp	/^    ImVector<ImGuiPopupRef> OpenedPopupStack;                   \/\/ Which popups are open$/;"	m	struct:ImGuiState	file:	access:public
Overlaps	libs/imgui/imgui.cpp	/^    bool        Overlaps(const ImRect& r) const     { return r.Min.y < Max.y && r.Max.y > Min.y && r.Min.x < Max.x && r.Max.x > Min.x; }$/;"	f	struct:ImRect	access:public	signature:(const ImRect& r) const
OverlayDrawList	libs/imgui/imgui.cpp	/^    ImDrawList              OverlayDrawList;                    \/\/ Optional software render of mouse cursors, if io.MouseDrawCursor is set + a few debug overlays$/;"	m	struct:ImGuiState	file:	access:public
OversampleH	libs/imgui/imgui.h	/^    int             OversampleH, OversampleV;   \/\/ 3, 1     \/\/ Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.$/;"	m	struct:ImFontConfig	access:public
OversampleV	libs/imgui/imgui.h	/^    int             OversampleH, OversampleV;   \/\/ 3, 1     \/\/ Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.$/;"	m	struct:ImFontConfig	access:public
PAUSE	include/Input.h	/^    const int PAUSE = GLFW_KEY_ESCAPE;$/;"	m	namespace:Key
PRINT_TO_TERMINAL	include/Standard.h	23;"	d
Pair	libs/imgui/imgui.h	/^        Pair(ImGuiID _key, float _val_f) { key = _key; val_f = _val_f; } $/;"	f	struct:ImGuiStorage::Pair	access:public	signature:(ImGuiID _key, float _val_f)
Pair	libs/imgui/imgui.h	/^        Pair(ImGuiID _key, int _val_i) { key = _key; val_i = _val_i; } $/;"	f	struct:ImGuiStorage::Pair	access:public	signature:(ImGuiID _key, int _val_i)
Pair	libs/imgui/imgui.h	/^        Pair(ImGuiID _key, void* _val_p) { key = _key; val_p = _val_p; } $/;"	f	struct:ImGuiStorage::Pair	access:public	signature:(ImGuiID _key, void* _val_p)
Pair	libs/imgui/imgui.h	/^    struct Pair $/;"	s	struct:ImGuiStorage	access:public
ParentMenuSet	libs/imgui/imgui.cpp	/^    ImGuiID             ParentMenuSet;  \/\/ Set on OpenPopup()$/;"	m	struct:ImGuiPopupRef	file:	access:public
ParentWindow	libs/imgui/imgui.cpp	/^    ImGuiWindow*        ParentWindow;   \/\/ Set on OpenPopup()$/;"	m	struct:ImGuiPopupRef	file:	access:public
ParseFormatPrecision	libs/imgui/imgui.cpp	/^static inline int ParseFormatPrecision(const char* fmt, int default_precision)$/;"	f	file:	signature:(const char* fmt, int default_precision)
PassFilter	libs/imgui/imgui.cpp	/^bool ImGuiTextFilter::PassFilter(const char* val) const$/;"	f	class:ImGuiTextFilter	signature:(const char* val) const
PassFilter	libs/imgui/imgui.h	/^    bool PassFilter(const char* val) const;$/;"	p	struct:ImGuiTextFilter	access:public	signature:(const char* val) const
PathArcTo	libs/imgui/imgui.cpp	/^void ImDrawList::PathArcTo(const ImVec2& centre, float radius, float amin, float amax, int num_segments)$/;"	f	class:ImDrawList	signature:(const ImVec2& centre, float radius, float amin, float amax, int num_segments)
PathArcTo	libs/imgui/imgui.h	/^    IMGUI_API void  PathArcTo(const ImVec2& centre, float radius, float a_min, float a_max, int num_segments = 10);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& centre, float radius, float a_min, float a_max, int num_segments = 10)
PathArcToFast	libs/imgui/imgui.cpp	/^void ImDrawList::PathArcToFast(const ImVec2& centre, float radius, int amin, int amax)$/;"	f	class:ImDrawList	signature:(const ImVec2& centre, float radius, int amin, int amax)
PathArcToFast	libs/imgui/imgui.h	/^    IMGUI_API void  PathArcToFast(const ImVec2& centre, float radius, int a_min_of_12, int a_max_of_12);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& centre, float radius, int a_min_of_12, int a_max_of_12)
PathClear	libs/imgui/imgui.h	/^    inline    void  PathClear()                                                 { _Path.resize(0); }$/;"	f	struct:ImDrawList	access:public	signature:()
PathFill	libs/imgui/imgui.h	/^    inline    void  PathFill(ImU32 col)                                         { AddConvexPolyFilled(_Path.Data, _Path.Size, col, true); PathClear(); }$/;"	f	struct:ImDrawList	access:public	signature:(ImU32 col)
PathLineTo	libs/imgui/imgui.h	/^    inline    void  PathLineTo(const ImVec2& p)                                 { _Path.push_back(p); }$/;"	f	struct:ImDrawList	access:public	signature:(const ImVec2& p)
PathRect	libs/imgui/imgui.cpp	/^void ImDrawList::PathRect(const ImVec2& a, const ImVec2& b, float rounding, int rounding_corners)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& b, float rounding, int rounding_corners)
PathRect	libs/imgui/imgui.h	/^    IMGUI_API void  PathRect(const ImVec2& a, const ImVec2& b, float rounding = 0.0f, int rounding_corners = 0x0F);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, float rounding = 0.0f, int rounding_corners = 0x0F)
PathStroke	libs/imgui/imgui.h	/^    inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f)  { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness, true); PathClear(); }$/;"	f	struct:ImDrawList	access:public	signature:(ImU32 col, bool closed, float thickness = 1.0f)
PixelSnapH	libs/imgui/imgui.h	/^    bool            PixelSnapH;                 \/\/ false    \/\/ Align every character to pixel boundary (if enabled, set OversampleH\/V to 1)$/;"	m	struct:ImFontConfig	access:public
Plot	libs/imgui/imgui.cpp	/^static void Plot(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)$/;"	f	file:	signature:(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)
PlotHistogram	libs/imgui/imgui.cpp	/^void ImGui::PlotHistogram(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)$/;"	f	class:ImGui	signature:(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)
PlotHistogram	libs/imgui/imgui.cpp	/^void ImGui::PlotHistogram(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)$/;"	f	class:ImGui	signature:(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)
PlotHistogram	libs/imgui/imgui.h	/^    IMGUI_API void          PlotHistogram(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0), int stride = sizeof(float));$/;"	p	namespace:ImGui	signature:(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0), int stride = sizeof(float))
PlotHistogram	libs/imgui/imgui.h	/^    IMGUI_API void          PlotHistogram(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0));$/;"	p	namespace:ImGui	signature:(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0))
PlotLines	libs/imgui/imgui.cpp	/^void ImGui::PlotLines(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)$/;"	f	class:ImGui	signature:(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)
PlotLines	libs/imgui/imgui.cpp	/^void ImGui::PlotLines(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)$/;"	f	class:ImGui	signature:(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)
PlotLines	libs/imgui/imgui.h	/^    IMGUI_API void          PlotLines(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0), int stride = sizeof(float));$/;"	p	namespace:ImGui	signature:(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0), int stride = sizeof(float))
PlotLines	libs/imgui/imgui.h	/^    IMGUI_API void          PlotLines(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0));$/;"	p	namespace:ImGui	signature:(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0))
Plot_ArrayGetter	libs/imgui/imgui.cpp	/^static float Plot_ArrayGetter(void* data, int idx)$/;"	f	file:	signature:(void* data, int idx)
PopAllowKeyboardFocus	libs/imgui/imgui.cpp	/^void ImGui::PopAllowKeyboardFocus()$/;"	f	class:ImGui	signature:()
PopAllowKeyboardFocus	libs/imgui/imgui.h	/^    IMGUI_API void          PopAllowKeyboardFocus();$/;"	p	namespace:ImGui	signature:()
PopButtonRepeat	libs/imgui/imgui.cpp	/^void ImGui::PopButtonRepeat()$/;"	f	class:ImGui	signature:()
PopButtonRepeat	libs/imgui/imgui.h	/^    IMGUI_API void          PopButtonRepeat();$/;"	p	namespace:ImGui	signature:()
PopClipRect	libs/imgui/imgui.cpp	/^static void PopClipRect()$/;"	f	file:	signature:()
PopClipRect	libs/imgui/imgui.cpp	/^void ImDrawList::PopClipRect()$/;"	f	class:ImDrawList	signature:()
PopClipRect	libs/imgui/imgui.h	/^    IMGUI_API void  PopClipRect();$/;"	p	struct:ImDrawList	access:public	signature:()
PopFont	libs/imgui/imgui.cpp	/^void  ImGui::PopFont()$/;"	f	class:ImGui	signature:()
PopFont	libs/imgui/imgui.h	/^    IMGUI_API void          PopFont();$/;"	p	namespace:ImGui	signature:()
PopID	libs/imgui/imgui.cpp	/^void ImGui::PopID()$/;"	f	class:ImGui	signature:()
PopID	libs/imgui/imgui.h	/^    IMGUI_API void          PopID();$/;"	p	namespace:ImGui	signature:()
PopItemWidth	libs/imgui/imgui.cpp	/^void ImGui::PopItemWidth()$/;"	f	class:ImGui	signature:()
PopItemWidth	libs/imgui/imgui.h	/^    IMGUI_API void          PopItemWidth();$/;"	p	namespace:ImGui	signature:()
PopStyleColor	libs/imgui/imgui.cpp	/^void ImGui::PopStyleColor(int count)$/;"	f	class:ImGui	signature:(int count)
PopStyleColor	libs/imgui/imgui.h	/^    IMGUI_API void          PopStyleColor(int count = 1);$/;"	p	namespace:ImGui	signature:(int count = 1)
PopStyleVar	libs/imgui/imgui.cpp	/^void ImGui::PopStyleVar(int count)$/;"	f	class:ImGui	signature:(int count)
PopStyleVar	libs/imgui/imgui.h	/^    IMGUI_API void          PopStyleVar(int count = 1);$/;"	p	namespace:ImGui	signature:(int count = 1)
PopTextWrapPos	libs/imgui/imgui.cpp	/^void ImGui::PopTextWrapPos()$/;"	f	class:ImGui	signature:()
PopTextWrapPos	libs/imgui/imgui.h	/^    IMGUI_API void          PopTextWrapPos();$/;"	p	namespace:ImGui	signature:()
PopTextureID	libs/imgui/imgui.cpp	/^void ImDrawList::PopTextureID()$/;"	f	class:ImDrawList	signature:()
PopTextureID	libs/imgui/imgui.h	/^    IMGUI_API void  PopTextureID();$/;"	p	struct:ImDrawList	access:public	signature:()
PopupID	libs/imgui/imgui.cpp	/^    ImGuiID                 PopupID;                            \/\/ ID in the popup stack when this window is used as a popup\/menu (because we use generic Name\/ID for recycling) $/;"	m	struct:ImGuiWindow	file:	access:public
PopupID	libs/imgui/imgui.cpp	/^    ImGuiID             PopupID;        \/\/ Set on OpenPopup()$/;"	m	struct:ImGuiPopupRef	file:	access:public
Pos	libs/imgui/imgui.cpp	/^    ImVec2                  Pos;                                \/\/ Position rounded-up to nearest pixel$/;"	m	struct:ImGuiWindow	file:	access:public
Pos	libs/imgui/imgui.cpp	/^    ImVec2  Pos;$/;"	m	struct:ImGuiIniData	file:	access:public
Pos	libs/imgui/imgui.cpp	/^    float  Pos[8], NextWidths[8];$/;"	m	struct:ImGuiSimpleColumns	file:	access:public
PosFloat	libs/imgui/imgui.cpp	/^    ImVec2                  PosFloat;$/;"	m	struct:ImGuiWindow	file:	access:public
PrevLineHeight	libs/imgui/imgui.cpp	/^    float                   PrevLineHeight;$/;"	m	struct:ImGuiDrawContext	file:	access:public
PrevLineTextBaseOffset	libs/imgui/imgui.cpp	/^    float                   PrevLineTextBaseOffset;$/;"	m	struct:ImGuiDrawContext	file:	access:public
PreviousValue	libs/imgui/imgui.cpp	/^    ImVec2      PreviousValue;$/;"	m	struct:ImGuiStyleMod	file:	access:public
PreviousValue	libs/imgui/imgui.cpp	/^    ImVec4      PreviousValue;$/;"	m	struct:ImGuiColMod	file:	access:public
PrimRect	libs/imgui/imgui.cpp	/^void ImDrawList::PrimRect(const ImVec2& a, const ImVec2& c, ImU32 col)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& c, ImU32 col)
PrimRect	libs/imgui/imgui.h	/^    IMGUI_API void  PrimRect(const ImVec2& a, const ImVec2& b, ImU32 col);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, ImU32 col)
PrimRectUV	libs/imgui/imgui.cpp	/^void ImDrawList::PrimRectUV(const ImVec2& a, const ImVec2& c, const ImVec2& uv_a, const ImVec2& uv_c, ImU32 col)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& c, const ImVec2& uv_a, const ImVec2& uv_c, ImU32 col)
PrimRectUV	libs/imgui/imgui.h	/^    IMGUI_API void  PrimRectUV(const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col)
PrimReserve	libs/imgui/imgui.cpp	/^void ImDrawList::PrimReserve(int idx_count, int vtx_count)$/;"	f	class:ImDrawList	signature:(int idx_count, int vtx_count)
PrimReserve	libs/imgui/imgui.h	/^    IMGUI_API void  PrimReserve(int idx_count, int vtx_count);$/;"	p	struct:ImDrawList	access:public	signature:(int idx_count, int vtx_count)
PrimVtx	libs/imgui/imgui.h	/^    inline    void  PrimVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)     { PrimWriteIdx((ImDrawIdx)_VtxCurrentIdx); PrimWriteVtx(pos, uv, col); }$/;"	f	struct:ImDrawList	access:public	signature:(const ImVec2& pos, const ImVec2& uv, ImU32 col)
PrimWriteIdx	libs/imgui/imgui.h	/^    inline    void  PrimWriteIdx(ImDrawIdx idx)                                 { *_IdxWritePtr = idx; _IdxWritePtr++; }$/;"	f	struct:ImDrawList	access:public	signature:(ImDrawIdx idx)
PrimWriteVtx	libs/imgui/imgui.h	/^    inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col){ _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }$/;"	f	struct:ImDrawList	access:public	signature:(const ImVec2& pos, const ImVec2& uv, ImU32 col)
PrivateClipboard	libs/imgui/imgui.cpp	/^    char*                   PrivateClipboard;                   \/\/ if no custom clipboard handler is defined$/;"	m	struct:ImGuiState	file:	access:public
PushAllowKeyboardFocus	libs/imgui/imgui.cpp	/^void ImGui::PushAllowKeyboardFocus(bool allow_keyboard_focus)$/;"	f	class:ImGui	signature:(bool allow_keyboard_focus)
PushAllowKeyboardFocus	libs/imgui/imgui.h	/^    IMGUI_API void          PushAllowKeyboardFocus(bool v);                                     \/\/ allow focusing using TAB\/Shift-TAB, enabled by default but you can disable it for certain widgets$/;"	p	namespace:ImGui	signature:(bool v)
PushButtonRepeat	libs/imgui/imgui.cpp	/^void ImGui::PushButtonRepeat(bool repeat)$/;"	f	class:ImGui	signature:(bool repeat)
PushButtonRepeat	libs/imgui/imgui.h	/^    IMGUI_API void          PushButtonRepeat(bool repeat);                                      \/\/ in 'repeat' mode, Button*() functions return true multiple times as you hold them (uses io.KeyRepeatDelay\/io.KeyRepeatRate for now)$/;"	p	namespace:ImGui	signature:(bool repeat)
PushClipRect	libs/imgui/imgui.cpp	/^static void PushClipRect(const ImVec4& clip_rect, bool clipped = true)$/;"	f	file:	signature:(const ImVec4& clip_rect, bool clipped = true)
PushClipRect	libs/imgui/imgui.cpp	/^void ImDrawList::PushClipRect(const ImVec4& clip_rect)$/;"	f	class:ImDrawList	signature:(const ImVec4& clip_rect)
PushClipRect	libs/imgui/imgui.h	/^    IMGUI_API void  PushClipRect(const ImVec4& clip_rect);          \/\/ Scissoring. The values are x1, y1, x2, y2.$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec4& clip_rect)
PushClipRectFullScreen	libs/imgui/imgui.cpp	/^void ImDrawList::PushClipRectFullScreen()$/;"	f	class:ImDrawList	signature:()
PushClipRectFullScreen	libs/imgui/imgui.h	/^    IMGUI_API void  PushClipRectFullScreen();$/;"	p	struct:ImDrawList	access:public	signature:()
PushColumnClipRect	libs/imgui/imgui.cpp	/^static void         PushColumnClipRect(int column_index = -1);$/;"	p	file:	signature:(int column_index = -1)
PushColumnClipRect	libs/imgui/imgui.cpp	/^static void PushColumnClipRect(int column_index)$/;"	f	file:	signature:(int column_index)
PushFont	libs/imgui/imgui.cpp	/^void ImGui::PushFont(ImFont* font)$/;"	f	class:ImGui	signature:(ImFont* font)
PushFont	libs/imgui/imgui.h	/^    IMGUI_API void          PushFont(ImFont* font);                                             \/\/ use NULL as a shortcut to push default font$/;"	p	namespace:ImGui	signature:(ImFont* font)
PushID	libs/imgui/imgui.cpp	/^void ImGui::PushID(const char* str_id)$/;"	f	class:ImGui	signature:(const char* str_id)
PushID	libs/imgui/imgui.cpp	/^void ImGui::PushID(const char* str_id_begin, const char* str_id_end)$/;"	f	class:ImGui	signature:(const char* str_id_begin, const char* str_id_end)
PushID	libs/imgui/imgui.cpp	/^void ImGui::PushID(const void* ptr_id)$/;"	f	class:ImGui	signature:(const void* ptr_id)
PushID	libs/imgui/imgui.cpp	/^void ImGui::PushID(int int_id)$/;"	f	class:ImGui	signature:(int int_id)
PushID	libs/imgui/imgui.h	/^    IMGUI_API void          PushID(const char* str_id);                                         \/\/ push identifier into the ID stack. IDs are hash of the *entire* stack!$/;"	p	namespace:ImGui	signature:(const char* str_id)
PushID	libs/imgui/imgui.h	/^    IMGUI_API void          PushID(const char* str_id_begin, const char* str_id_end);$/;"	p	namespace:ImGui	signature:(const char* str_id_begin, const char* str_id_end)
PushID	libs/imgui/imgui.h	/^    IMGUI_API void          PushID(const void* ptr_id);$/;"	p	namespace:ImGui	signature:(const void* ptr_id)
PushID	libs/imgui/imgui.h	/^    IMGUI_API void          PushID(int int_id);$/;"	p	namespace:ImGui	signature:(int int_id)
PushItemWidth	libs/imgui/imgui.cpp	/^void ImGui::PushItemWidth(float item_width)$/;"	f	class:ImGui	signature:(float item_width)
PushItemWidth	libs/imgui/imgui.h	/^    IMGUI_API void          PushItemWidth(float item_width);                                    \/\/ width of items for the common item+label case, pixels. 0.0f = default to ~2\/3 of windows width, >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -1.0f always align width to the right side)$/;"	p	namespace:ImGui	signature:(float item_width)
PushMultiItemsWidths	libs/imgui/imgui.cpp	/^static void PushMultiItemsWidths(int components, float w_full = 0.0f)$/;"	f	file:	signature:(int components, float w_full = 0.0f)
PushStyleColor	libs/imgui/imgui.cpp	/^void ImGui::PushStyleColor(ImGuiCol idx, const ImVec4& col)$/;"	f	class:ImGui	signature:(ImGuiCol idx, const ImVec4& col)
PushStyleColor	libs/imgui/imgui.h	/^    IMGUI_API void          PushStyleColor(ImGuiCol idx, const ImVec4& col);$/;"	p	namespace:ImGui	signature:(ImGuiCol idx, const ImVec4& col)
PushStyleVar	libs/imgui/imgui.cpp	/^void ImGui::PushStyleVar(ImGuiStyleVar idx, const ImVec2& val)$/;"	f	class:ImGui	signature:(ImGuiStyleVar idx, const ImVec2& val)
PushStyleVar	libs/imgui/imgui.cpp	/^void ImGui::PushStyleVar(ImGuiStyleVar idx, float val)$/;"	f	class:ImGui	signature:(ImGuiStyleVar idx, float val)
PushStyleVar	libs/imgui/imgui.h	/^    IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, const ImVec2& val);$/;"	p	namespace:ImGui	signature:(ImGuiStyleVar idx, const ImVec2& val)
PushStyleVar	libs/imgui/imgui.h	/^    IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, float val);$/;"	p	namespace:ImGui	signature:(ImGuiStyleVar idx, float val)
PushTextWrapPos	libs/imgui/imgui.cpp	/^void ImGui::PushTextWrapPos(float wrap_pos_x)$/;"	f	class:ImGui	signature:(float wrap_pos_x)
PushTextWrapPos	libs/imgui/imgui.h	/^    IMGUI_API void          PushTextWrapPos(float wrap_pos_x = 0.0f);                           \/\/ word-wrapping for Text*() commands. < 0.0f: no wrapping; 0.0f: wrap to end of window (or column); > 0.0f: wrap at 'wrap_pos_x' position in window local space$/;"	p	namespace:ImGui	signature:(float wrap_pos_x = 0.0f)
PushTextureID	libs/imgui/imgui.cpp	/^void ImDrawList::PushTextureID(const ImTextureID& texture_id)$/;"	f	class:ImDrawList	signature:(const ImTextureID& texture_id)
PushTextureID	libs/imgui/imgui.h	/^    IMGUI_API void  PushTextureID(const ImTextureID& texture_id);$/;"	p	struct:ImDrawList	access:public	signature:(const ImTextureID& texture_id)
READER_H	include/io/Reader.h	2;"	d
RENDER_H	include/gfx/Render.h	2;"	d
RIGHT	include/Input.h	/^    const int RIGHT = GLFW_KEY_D;$/;"	m	namespace:Key
RadioButton	libs/imgui/imgui.cpp	/^bool ImGui::RadioButton(const char* label, bool active)$/;"	f	class:ImGui	signature:(const char* label, bool active)
RadioButton	libs/imgui/imgui.cpp	/^bool ImGui::RadioButton(const char* label, int* v, int v_button)$/;"	f	class:ImGui	signature:(const char* label, int* v, int v_button)
RadioButton	libs/imgui/imgui.h	/^    IMGUI_API bool          RadioButton(const char* label, bool active);$/;"	p	namespace:ImGui	signature:(const char* label, bool active)
RadioButton	libs/imgui/imgui.h	/^    IMGUI_API bool          RadioButton(const char* label, int* v, int v_button);$/;"	p	namespace:ImGui	signature:(const char* label, int* v, int v_button)
Reader	include/io/Reader.h	/^    namespace Reader {$/;"	n	namespace:IO
Reader	src/io/Reader.cpp	/^    namespace Reader {$/;"	n	namespace:IO	file:
Rect	libs/imgui/imgui.cpp	/^    ImRect      Rect() const                            { return ImRect(Pos, Pos+Size); }$/;"	f	struct:ImGuiWindow	access:public	signature:() const
Reduce	libs/imgui/imgui.cpp	/^    void        Reduce(const ImVec2& amount)        { Min.x += amount.x; Min.y += amount.y; Max.x -= amount.x; Max.y -= amount.y; }$/;"	f	struct:ImRect	access:public	signature:(const ImVec2& amount)
RefFrame	libs/imgui/imgui.h	/^    mutable int RefFrame;$/;"	m	struct:ImGuiOnceUponAFrame	access:public
RegisterAliveId	libs/imgui/imgui.cpp	/^static void RegisterAliveId(ImGuiID id)$/;"	f	file:	signature:(ImGuiID id)
Render	include/gfx/Render.h	/^namespace Render {$/;"	n
Render	libs/imgui/imgui.cpp	/^void ImGui::Render()$/;"	f	class:ImGui	signature:()
Render	libs/imgui/imgui.h	/^    IMGUI_API void          Render();$/;"	p	namespace:ImGui	signature:()
Render	src/gfx/Render.cpp	/^namespace Render {$/;"	n	file:
Render	src/legacy/Render.cpp	/^namespace Render {$/;"	n	file:
Render::VertexArrayID	src/gfx/Render.cpp	/^    GLuint VertexArrayID;$/;"	m	namespace:Render	file:
Render::clear	include/gfx/Render.h	/^    void clear();$/;"	p	namespace:Render	signature:()
Render::clear	src/gfx/Render.cpp	/^    void clear() {$/;"	f	namespace:Render	signature:()
Render::clear	src/legacy/Render.cpp	/^    void clear() {$/;"	f	namespace:Render	signature:()
Render::font	include/gfx/Render.h	/^    void font(vec4 position, vec4 color, GLuint tex, int index);$/;"	p	namespace:Render	signature:(vec4 position, vec4 color, GLuint tex, int index)
Render::font	src/gfx/Render.cpp	/^    void font(vec4 position, vec4 color, GLuint tex, int index) {$/;"	f	namespace:Render	signature:(vec4 position, vec4 color, GLuint tex, int index)
Render::fontColor	src/gfx/Render.cpp	/^    GLuint fontColor;$/;"	m	namespace:Render	file:
Render::fontIndex	src/gfx/Render.cpp	/^    GLuint fontIndex;$/;"	m	namespace:Render	file:
Render::fontMatrixID	src/gfx/Render.cpp	/^    GLuint fontMatrixID;$/;"	m	namespace:Render	file:
Render::fontProgramID	src/gfx/Render.cpp	/^    GLuint fontProgramID;$/;"	m	namespace:Render	file:
Render::fontTextureHandler	src/gfx/Render.cpp	/^    GLuint fontTextureHandler;$/;"	m	namespace:Render	file:
Render::fontUVBuffer	src/gfx/Render.cpp	/^    GLuint fontUVBuffer;$/;"	m	namespace:Render	file:
Render::fontVertexBuffer	src/gfx/Render.cpp	/^    GLuint fontVertexBuffer;$/;"	m	namespace:Render	file:
Render::fov	src/gfx/Render.cpp	/^    float fov = 90.0f;$/;"	m	namespace:Render	file:
Render::g_font_uv_buffer_data	src/gfx/Render.cpp	/^    static const GLfloat g_font_uv_buffer_data[] = {$/;"	m	namespace:Render	file:
Render::g_font_vertex_buffer_data	src/gfx/Render.cpp	/^    static const GLfloat g_font_vertex_buffer_data[] = {$/;"	m	namespace:Render	file:
Render::g_tile_uv_buffer_data	src/gfx/Render.cpp	/^    static const GLfloat g_tile_uv_buffer_data[] = {$/;"	m	namespace:Render	file:
Render::g_tile_vertex_buffer_data	src/gfx/Render.cpp	/^    static const GLfloat g_tile_vertex_buffer_data[] = {$/;"	m	namespace:Render	file:
Render::init	include/gfx/Render.h	/^    void init();$/;"	p	namespace:Render	signature:()
Render::init	src/gfx/Render.cpp	/^    void init() {$/;"	f	namespace:Render	signature:()
Render::init	src/legacy/Render.cpp	/^    void init() {$/;"	f	namespace:Render	signature:()
Render::move	include/gfx/Render.h	/^    void move(vec4 toMove);$/;"	p	namespace:Render	signature:(vec4 toMove)
Render::move	src/gfx/Render.cpp	/^    void move(vec4 toMove) {$/;"	f	namespace:Render	signature:(vec4 toMove)
Render::move	src/legacy/Render.cpp	/^    void move(vec4 toMove) {$/;"	f	namespace:Render	signature:(vec4 toMove)
Render::outline	include/gfx/Render.h	/^    void outline(vec4 position, vec2 size, vec4 color);$/;"	p	namespace:Render	signature:(vec4 position, vec2 size, vec4 color)
Render::outline	src/gfx/Render.cpp	/^    void outline(vec4 modelMatrix , vec2 size, vec4 color) {$/;"	f	namespace:Render	signature:(vec4 modelMatrix , vec2 size, vec4 color)
Render::outline	src/legacy/Render.cpp	/^    void outline(vec4 position , vec2 size, vec4 color) {$/;"	f	namespace:Render	signature:(vec4 position , vec2 size, vec4 color)
Render::outlineAbs	include/gfx/Render.h	/^    void outlineAbs(vec4 position, vec2 size, vec4 color);$/;"	p	namespace:Render	signature:(vec4 position, vec2 size, vec4 color)
Render::outlineAbs	src/gfx/Render.cpp	/^    void outlineAbs(vec4 modelMatrix , vec2 size, vec4 color) {$/;"	f	namespace:Render	signature:(vec4 modelMatrix , vec2 size, vec4 color)
Render::outlineAbs	src/legacy/Render.cpp	/^    void outlineAbs(vec4 position , vec2 size, vec4 color) {$/;"	f	namespace:Render	signature:(vec4 position , vec2 size, vec4 color)
Render::projectionMatrix	src/gfx/Render.cpp	/^    mat4 projectionMatrix = perspective(fov, 4.0f \/ 3.0f, 0.1f, 100.0f);$/;"	m	namespace:Render	file:
Render::quad	include/gfx/Render.h	/^    void quad(vec4 position, vec2 size, vec4 color);$/;"	p	namespace:Render	signature:(vec4 position, vec2 size, vec4 color)
Render::quad	src/gfx/Render.cpp	/^    void quad(vec4 modelMatrix , vec2 size, vec4 color) {$/;"	f	namespace:Render	signature:(vec4 modelMatrix , vec2 size, vec4 color)
Render::quad	src/legacy/Render.cpp	/^    void quad(vec4 position , vec2 size, vec4 color) {$/;"	f	namespace:Render	signature:(vec4 position , vec2 size, vec4 color)
Render::quadAbs	include/gfx/Render.h	/^    void quadAbs(vec4 position, vec2 size, vec4 color);$/;"	p	namespace:Render	signature:(vec4 position, vec2 size, vec4 color)
Render::quadAbs	src/gfx/Render.cpp	/^    void quadAbs(vec4 modelMatrix, vec2 size, vec4 color) {$/;"	f	namespace:Render	signature:(vec4 modelMatrix, vec2 size, vec4 color)
Render::quadAbs	src/legacy/Render.cpp	/^    void quadAbs(vec4 position, vec2 size, vec4 color) {$/;"	f	namespace:Render	signature:(vec4 position, vec2 size, vec4 color)
Render::quadTex	include/gfx/Render.h	/^    void quadTex(vec4 position, vec2 size, GLuint tex, vec4 uv);$/;"	p	namespace:Render	signature:(vec4 position, vec2 size, GLuint tex, vec4 uv)
Render::quadTex	src/gfx/Render.cpp	/^    void quadTex(vec4 modelMatrix, vec2 size, GLuint tex, vec4 uv) {$/;"	f	namespace:Render	signature:(vec4 modelMatrix, vec2 size, GLuint tex, vec4 uv)
Render::quadTex	src/legacy/Render.cpp	/^    void quadTex(vec4 position, vec2 size, GLuint tex, vec4 uv) {$/;"	f	namespace:Render	signature:(vec4 position, vec2 size, GLuint tex, vec4 uv)
Render::quadTexAbs	include/gfx/Render.h	/^    void quadTexAbs(vec4 position, vec2 size, GLuint tex, vec4 uv);$/;"	p	namespace:Render	signature:(vec4 position, vec2 size, GLuint tex, vec4 uv)
Render::quadTexAbs	src/gfx/Render.cpp	/^    void quadTexAbs(vec4 position, vec2 size, GLuint tex, vec4 uv) {$/;"	f	namespace:Render	signature:(vec4 position, vec2 size, GLuint tex, vec4 uv)
Render::quadTexAbs	src/legacy/Render.cpp	/^    void quadTexAbs(vec4 position, vec2 size, GLuint tex, vec4 uv) {$/;"	f	namespace:Render	signature:(vec4 position, vec2 size, GLuint tex, vec4 uv)
Render::test	include/gfx/Render.h	/^    void test(vec4 position);$/;"	p	namespace:Render	signature:(vec4 position)
Render::test	src/legacy/Render.cpp	/^    void test() {$/;"	f	namespace:Render	signature:()
Render::tile	include/gfx/Render.h	/^    void tile(vec4 position, GLuint tex);$/;"	p	namespace:Render	signature:(vec4 position, GLuint tex)
Render::tile	src/gfx/Render.cpp	/^    void tile(vec4 position, GLuint tex) {$/;"	f	namespace:Render	signature:(vec4 position, GLuint tex)
Render::tile	src/legacy/Render.cpp	/^    void tile(vec4 position, GLuint tex) {$/;"	f	namespace:Render	signature:(vec4 position, GLuint tex)
Render::tileMatrixID	src/gfx/Render.cpp	/^    GLuint tileMatrixID;$/;"	m	namespace:Render	file:
Render::tileProgramID	src/gfx/Render.cpp	/^    GLuint tileProgramID;$/;"	m	namespace:Render	file:
Render::tileTextureHandler	src/gfx/Render.cpp	/^    GLuint tileTextureHandler;$/;"	m	namespace:Render	file:
Render::tileUVBuffer	src/gfx/Render.cpp	/^    GLuint tileUVBuffer;$/;"	m	namespace:Render	file:
Render::tileVertexBuffer	src/gfx/Render.cpp	/^    GLuint tileVertexBuffer;$/;"	m	namespace:Render	file:
Render::view	src/gfx/Render.cpp	/^    vec4 view = vec4(0, 0, 10, 1);$/;"	m	namespace:Render	file:
Render::view	src/legacy/Render.cpp	/^    vec4 view = vec4(0, 0, 0, 1);$/;"	m	namespace:Render	file:
Render::viewMatrix	src/gfx/Render.cpp	/^    mat4 viewMatrix = lookAt(vec3(view.x, view.y, view.z), vec3(view.x, view.y, view.z-1), vec3(0, 1, 0));$/;"	m	namespace:Render	file:
Render::viewMatrix	src/legacy/Render.cpp	/^    mat4 viewMatrix = translate(IDENTITY, vec3(0));$/;"	m	namespace:Render	file:
RenderCheckMark	libs/imgui/imgui.cpp	/^static void         RenderCheckMark(ImVec2 pos, ImU32 col);$/;"	p	file:	signature:(ImVec2 pos, ImU32 col)
RenderCheckMark	libs/imgui/imgui.cpp	/^static void RenderCheckMark(ImVec2 pos, ImU32 col)$/;"	f	file:	signature:(ImVec2 pos, ImU32 col)
RenderCollapseTriangle	libs/imgui/imgui.cpp	/^static void         RenderCollapseTriangle(ImVec2 p_min, bool opened, float scale = 1.0f, bool shadow = false);$/;"	p	file:	signature:(ImVec2 p_min, bool opened, float scale = 1.0f, bool shadow = false)
RenderCollapseTriangle	libs/imgui/imgui.cpp	/^static void RenderCollapseTriangle(ImVec2 p_min, bool opened, float scale, bool shadow)$/;"	f	file:	signature:(ImVec2 p_min, bool opened, float scale, bool shadow)
RenderCustomTexData	libs/imgui/imgui.cpp	/^void ImFontAtlas::RenderCustomTexData(int pass, void* p_rects)$/;"	f	class:ImFontAtlas	signature:(int pass, void* p_rects)
RenderCustomTexData	libs/imgui/imgui.h	/^    IMGUI_API void              RenderCustomTexData(int pass, void* rects);$/;"	p	struct:ImFontAtlas	access:public	signature:(int pass, void* rects)
RenderDrawLists	libs/imgui/imgui.cpp	/^    ImVector<ImDrawList*>   RenderDrawLists[3];$/;"	m	struct:ImGuiState	file:	access:public
RenderDrawListsFn	libs/imgui/imgui.h	/^    void        (*RenderDrawListsFn)(ImDrawData* data);      $/;"	m	struct:ImGuiIO	access:public
RenderFrame	libs/imgui/imgui.cpp	/^static void         RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border = true, float rounding = 0.0f);$/;"	p	file:	signature:(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border = true, float rounding = 0.0f)
RenderFrame	libs/imgui/imgui.cpp	/^static void RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border, float rounding)$/;"	f	file:	signature:(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border, float rounding)
RenderText	libs/imgui/imgui.cpp	/^static void         RenderText(ImVec2 pos, const char* text, const char* text_end = NULL, bool hide_text_after_hash = true);$/;"	p	file:	signature:(ImVec2 pos, const char* text, const char* text_end = NULL, bool hide_text_after_hash = true)
RenderText	libs/imgui/imgui.cpp	/^static void RenderText(ImVec2 pos, const char* text, const char* text_end, bool hide_text_after_hash)$/;"	f	file:	signature:(ImVec2 pos, const char* text, const char* text_end, bool hide_text_after_hash)
RenderText	libs/imgui/imgui.cpp	/^void ImFont::RenderText(float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, ImDrawList* draw_list, float wrap_width, bool cpu_fine_clip) const$/;"	f	class:ImFont	signature:(float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, ImDrawList* draw_list, float wrap_width, bool cpu_fine_clip) const
RenderText	libs/imgui/imgui.h	/^    IMGUI_API void              RenderText(float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, ImDrawList* draw_list, float wrap_width = 0.0f, bool cpu_fine_clip = false) const;$/;"	p	struct:ImFont	access:public	signature:(float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, ImDrawList* draw_list, float wrap_width = 0.0f, bool cpu_fine_clip = false) const
RenderTextClipped	libs/imgui/imgui.cpp	/^static void         RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, ImGuiAlign align = ImGuiAlign_Default, const ImVec2* clip_min = NULL, const ImVec2* clip_max = NULL);$/;"	p	file:	signature:(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, ImGuiAlign align = ImGuiAlign_Default, const ImVec2* clip_min = NULL, const ImVec2* clip_max = NULL)
RenderTextClipped	libs/imgui/imgui.cpp	/^static void RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, ImGuiAlign align, const ImVec2* clip_min, const ImVec2* clip_max)$/;"	f	file:	signature:(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, ImGuiAlign align, const ImVec2* clip_min, const ImVec2* clip_max)
RenderTextWrapped	libs/imgui/imgui.cpp	/^static void         RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width);$/;"	p	file:	signature:(ImVec2 pos, const char* text, const char* text_end, float wrap_width)
RenderTextWrapped	libs/imgui/imgui.cpp	/^static void RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width)$/;"	f	file:	signature:(ImVec2 pos, const char* text, const char* text_end, float wrap_width)
ResetMouseDragDelta	libs/imgui/imgui.cpp	/^void ImGui::ResetMouseDragDelta(int button)$/;"	f	class:ImGui	signature:(int button)
ResetMouseDragDelta	libs/imgui/imgui.h	/^    IMGUI_API void          ResetMouseDragDelta(int button = 0);                                \/\/ $/;"	p	namespace:ImGui	signature:(int button = 0)
RootNonPopupWindow	libs/imgui/imgui.cpp	/^    ImGuiWindow*            RootNonPopupWindow;$/;"	m	struct:ImGuiWindow	file:	access:public
RootWindow	libs/imgui/imgui.cpp	/^    ImGuiWindow*            RootWindow;$/;"	m	struct:ImGuiWindow	file:	access:public
Round	libs/imgui/imgui.cpp	/^    void        Round()                             { Min.x = (float)(int)Min.x; Min.y = (float)(int)Min.y; Max.x = (float)(int)Max.x; Max.y = (float)(int)Max.y; } $/;"	f	struct:ImRect	access:public	signature:()
RoundScalar	libs/imgui/imgui.cpp	/^static inline float RoundScalar(float value, int decimal_precision)$/;"	f	file:	signature:(float value, int decimal_precision)
Run	libs/imgui/imgui.cpp	/^    void    Run(const char* title, bool* opened)$/;"	f	struct:ExampleAppConsole	access:public	signature:(const char* title, bool* opened)
Run	src/util/Console.cpp	/^	void    Run(const char* title, bool* opened)$/;"	f	struct:Console::Console	access:public	signature:(const char* title, bool* opened)
SCALE	include/Standard.h	11;"	d
SCRIPT_H	include/Script.h	2;"	d
SHADERLOADER_H	include/gfx/ShaderLoader.h	2;"	d
SOURCES	GaffMaker/Makefile	/^SOURCES = $(shell find $(SRC_PATH)\/ -name '*.$(SRC_EXT)' -printf '%T@\\t%p\\n' \\$/;"	m
SOURCES	Makefile	/^SOURCES = $(shell find $(SRC_PATH)\/ -name '*.$(SRC_EXT)' -printf '%T@\\t%p\\n' \\$/;"	m
SRC_EXT	GaffMaker/Makefile	/^SRC_EXT = cpp$/;"	m
SRC_EXT	Makefile	/^SRC_EXT = cpp$/;"	m
SRC_PATH	GaffMaker/Makefile	/^SRC_PATH = src$/;"	m
SRC_PATH	Makefile	/^SRC_PATH = src$/;"	m
STANDARD_GCH	GaffMaker/Makefile	/^STANDARD_GCH = $(STANDARD_H).gch$/;"	m
STANDARD_GCH	Makefile	/^STANDARD_GCH = $(STANDARD_H).gch$/;"	m
STANDARD_H	GaffMaker/Makefile	/^STANDARD_H = $(HEADER_PATH)\/Standard.h$/;"	m
STANDARD_H	GaffMaker/include/Standard.h	2;"	d
STANDARD_H	Makefile	/^STANDARD_H = $(HEADER_PATH)\/Standard.h$/;"	m
STANDARD_H	include/Standard.h	2;"	d
STBRP_ASSERT	libs/imgui/imgui.cpp	530;"	d	file:
STBRP_ASSERT	libs/imgui/stb_rect_pack.h	176;"	d
STBRP_DEF	libs/imgui/stb_rect_pack.h	40;"	d
STBRP_DEF	libs/imgui/stb_rect_pack.h	42;"	d
STBRP_HEURISTIC_Skyline_BF_sortHeight	libs/imgui/stb_rect_pack.h	/^   STBRP_HEURISTIC_Skyline_BF_sortHeight$/;"	e	enum:__anon23
STBRP_HEURISTIC_Skyline_BL_sortHeight	libs/imgui/stb_rect_pack.h	/^   STBRP_HEURISTIC_Skyline_BL_sortHeight = STBRP_HEURISTIC_Skyline_default,$/;"	e	enum:__anon23
STBRP_HEURISTIC_Skyline_default	libs/imgui/stb_rect_pack.h	/^   STBRP_HEURISTIC_Skyline_default=0,$/;"	e	enum:__anon23
STBRP_STATIC	libs/imgui/imgui.cpp	532;"	d	file:
STBRP__INIT_skyline	libs/imgui/stb_rect_pack.h	/^   STBRP__INIT_skyline = 1$/;"	e	enum:__anon24
STBRP__MAXVAL	libs/imgui/stb_rect_pack.h	510;"	d
STBRP__MAXVAL	libs/imgui/stb_rect_pack.h	512;"	d
STBTT_DEF	libs/imgui/stb_truetype.h	438;"	d
STBTT_DEF	libs/imgui/stb_truetype.h	440;"	d
STBTT_FIX	libs/imgui/stb_truetype.h	1656;"	d
STBTT_FIXMASK	libs/imgui/stb_truetype.h	1657;"	d
STBTT_FIXSHIFT	libs/imgui/stb_truetype.h	1655;"	d
STBTT_MACSTYLE_BOLD	libs/imgui/stb_truetype.h	835;"	d
STBTT_MACSTYLE_DONTCARE	libs/imgui/stb_truetype.h	834;"	d
STBTT_MACSTYLE_ITALIC	libs/imgui/stb_truetype.h	836;"	d
STBTT_MACSTYLE_NONE	libs/imgui/stb_truetype.h	838;"	d
STBTT_MACSTYLE_UNDERSCORE	libs/imgui/stb_truetype.h	837;"	d
STBTT_MAC_EID_ARABIC	libs/imgui/stb_truetype.h	/^   STBTT_MAC_EID_ROMAN        =0,   STBTT_MAC_EID_ARABIC       =4,$/;"	e	enum:__anon17
STBTT_MAC_EID_CHINESE_TRAD	libs/imgui/stb_truetype.h	/^   STBTT_MAC_EID_CHINESE_TRAD =2,   STBTT_MAC_EID_GREEK        =6,$/;"	e	enum:__anon17
STBTT_MAC_EID_GREEK	libs/imgui/stb_truetype.h	/^   STBTT_MAC_EID_CHINESE_TRAD =2,   STBTT_MAC_EID_GREEK        =6,$/;"	e	enum:__anon17
STBTT_MAC_EID_HEBREW	libs/imgui/stb_truetype.h	/^   STBTT_MAC_EID_JAPANESE     =1,   STBTT_MAC_EID_HEBREW       =5,$/;"	e	enum:__anon17
STBTT_MAC_EID_JAPANESE	libs/imgui/stb_truetype.h	/^   STBTT_MAC_EID_JAPANESE     =1,   STBTT_MAC_EID_HEBREW       =5,$/;"	e	enum:__anon17
STBTT_MAC_EID_KOREAN	libs/imgui/stb_truetype.h	/^   STBTT_MAC_EID_KOREAN       =3,   STBTT_MAC_EID_RUSSIAN      =7$/;"	e	enum:__anon17
STBTT_MAC_EID_ROMAN	libs/imgui/stb_truetype.h	/^   STBTT_MAC_EID_ROMAN        =0,   STBTT_MAC_EID_ARABIC       =4,$/;"	e	enum:__anon17
STBTT_MAC_EID_RUSSIAN	libs/imgui/stb_truetype.h	/^   STBTT_MAC_EID_KOREAN       =3,   STBTT_MAC_EID_RUSSIAN      =7$/;"	e	enum:__anon17
STBTT_MAC_LANG_ARABIC	libs/imgui/stb_truetype.h	/^   STBTT_MAC_LANG_ARABIC       =12,   STBTT_MAC_LANG_KOREAN       =23,$/;"	e	enum:__anon19
STBTT_MAC_LANG_CHINESE_SIMPLIFIED	libs/imgui/stb_truetype.h	/^   STBTT_MAC_LANG_HEBREW       =10,   STBTT_MAC_LANG_CHINESE_SIMPLIFIED =33,$/;"	e	enum:__anon19
STBTT_MAC_LANG_CHINESE_TRAD	libs/imgui/stb_truetype.h	/^   STBTT_MAC_LANG_ITALIAN      =3 ,   STBTT_MAC_LANG_CHINESE_TRAD =19$/;"	e	enum:__anon19
STBTT_MAC_LANG_DUTCH	libs/imgui/stb_truetype.h	/^   STBTT_MAC_LANG_DUTCH        =4 ,   STBTT_MAC_LANG_RUSSIAN      =32,$/;"	e	enum:__anon19
STBTT_MAC_LANG_ENGLISH	libs/imgui/stb_truetype.h	/^   STBTT_MAC_LANG_ENGLISH      =0 ,   STBTT_MAC_LANG_JAPANESE     =11,$/;"	e	enum:__anon19
STBTT_MAC_LANG_FRENCH	libs/imgui/stb_truetype.h	/^   STBTT_MAC_LANG_FRENCH       =1 ,   STBTT_MAC_LANG_SPANISH      =6 ,$/;"	e	enum:__anon19
STBTT_MAC_LANG_GERMAN	libs/imgui/stb_truetype.h	/^   STBTT_MAC_LANG_GERMAN       =2 ,   STBTT_MAC_LANG_SWEDISH      =5 ,$/;"	e	enum:__anon19
STBTT_MAC_LANG_HEBREW	libs/imgui/stb_truetype.h	/^   STBTT_MAC_LANG_HEBREW       =10,   STBTT_MAC_LANG_CHINESE_SIMPLIFIED =33,$/;"	e	enum:__anon19
STBTT_MAC_LANG_ITALIAN	libs/imgui/stb_truetype.h	/^   STBTT_MAC_LANG_ITALIAN      =3 ,   STBTT_MAC_LANG_CHINESE_TRAD =19$/;"	e	enum:__anon19
STBTT_MAC_LANG_JAPANESE	libs/imgui/stb_truetype.h	/^   STBTT_MAC_LANG_ENGLISH      =0 ,   STBTT_MAC_LANG_JAPANESE     =11,$/;"	e	enum:__anon19
STBTT_MAC_LANG_KOREAN	libs/imgui/stb_truetype.h	/^   STBTT_MAC_LANG_ARABIC       =12,   STBTT_MAC_LANG_KOREAN       =23,$/;"	e	enum:__anon19
STBTT_MAC_LANG_RUSSIAN	libs/imgui/stb_truetype.h	/^   STBTT_MAC_LANG_DUTCH        =4 ,   STBTT_MAC_LANG_RUSSIAN      =32,$/;"	e	enum:__anon19
STBTT_MAC_LANG_SPANISH	libs/imgui/stb_truetype.h	/^   STBTT_MAC_LANG_FRENCH       =1 ,   STBTT_MAC_LANG_SPANISH      =6 ,$/;"	e	enum:__anon19
STBTT_MAC_LANG_SWEDISH	libs/imgui/stb_truetype.h	/^   STBTT_MAC_LANG_GERMAN       =2 ,   STBTT_MAC_LANG_SWEDISH      =5 ,$/;"	e	enum:__anon19
STBTT_MAX_OVERSAMPLE	libs/imgui/stb_truetype.h	917;"	d
STBTT_MS_EID_SHIFTJIS	libs/imgui/stb_truetype.h	/^   STBTT_MS_EID_SHIFTJIS      =2,$/;"	e	enum:__anon16
STBTT_MS_EID_SYMBOL	libs/imgui/stb_truetype.h	/^   STBTT_MS_EID_SYMBOL        =0,$/;"	e	enum:__anon16
STBTT_MS_EID_UNICODE_BMP	libs/imgui/stb_truetype.h	/^   STBTT_MS_EID_UNICODE_BMP   =1,$/;"	e	enum:__anon16
STBTT_MS_EID_UNICODE_FULL	libs/imgui/stb_truetype.h	/^   STBTT_MS_EID_UNICODE_FULL  =10$/;"	e	enum:__anon16
STBTT_MS_LANG_CHINESE	libs/imgui/stb_truetype.h	/^   STBTT_MS_LANG_CHINESE     =0x0804,   STBTT_MS_LANG_JAPANESE    =0x0411,$/;"	e	enum:__anon18
STBTT_MS_LANG_DUTCH	libs/imgui/stb_truetype.h	/^   STBTT_MS_LANG_DUTCH       =0x0413,   STBTT_MS_LANG_KOREAN      =0x0412,$/;"	e	enum:__anon18
STBTT_MS_LANG_ENGLISH	libs/imgui/stb_truetype.h	/^   STBTT_MS_LANG_ENGLISH     =0x0409,   STBTT_MS_LANG_ITALIAN     =0x0410,$/;"	e	enum:__anon18
STBTT_MS_LANG_FRENCH	libs/imgui/stb_truetype.h	/^   STBTT_MS_LANG_FRENCH      =0x040c,   STBTT_MS_LANG_RUSSIAN     =0x0419,$/;"	e	enum:__anon18
STBTT_MS_LANG_GERMAN	libs/imgui/stb_truetype.h	/^   STBTT_MS_LANG_GERMAN      =0x0407,   STBTT_MS_LANG_SPANISH     =0x0409,$/;"	e	enum:__anon18
STBTT_MS_LANG_HEBREW	libs/imgui/stb_truetype.h	/^   STBTT_MS_LANG_HEBREW      =0x040d,   STBTT_MS_LANG_SWEDISH     =0x041D$/;"	e	enum:__anon18
STBTT_MS_LANG_ITALIAN	libs/imgui/stb_truetype.h	/^   STBTT_MS_LANG_ENGLISH     =0x0409,   STBTT_MS_LANG_ITALIAN     =0x0410,$/;"	e	enum:__anon18
STBTT_MS_LANG_JAPANESE	libs/imgui/stb_truetype.h	/^   STBTT_MS_LANG_CHINESE     =0x0804,   STBTT_MS_LANG_JAPANESE    =0x0411,$/;"	e	enum:__anon18
STBTT_MS_LANG_KOREAN	libs/imgui/stb_truetype.h	/^   STBTT_MS_LANG_DUTCH       =0x0413,   STBTT_MS_LANG_KOREAN      =0x0412,$/;"	e	enum:__anon18
STBTT_MS_LANG_RUSSIAN	libs/imgui/stb_truetype.h	/^   STBTT_MS_LANG_FRENCH      =0x040c,   STBTT_MS_LANG_RUSSIAN     =0x0419,$/;"	e	enum:__anon18
STBTT_MS_LANG_SPANISH	libs/imgui/stb_truetype.h	/^   STBTT_MS_LANG_GERMAN      =0x0407,   STBTT_MS_LANG_SPANISH     =0x0409,$/;"	e	enum:__anon18
STBTT_MS_LANG_SWEDISH	libs/imgui/stb_truetype.h	/^   STBTT_MS_LANG_HEBREW      =0x040d,   STBTT_MS_LANG_SWEDISH     =0x041D$/;"	e	enum:__anon18
STBTT_PLATFORM_ID_ISO	libs/imgui/stb_truetype.h	/^   STBTT_PLATFORM_ID_ISO       =2,$/;"	e	enum:__anon14
STBTT_PLATFORM_ID_MAC	libs/imgui/stb_truetype.h	/^   STBTT_PLATFORM_ID_MAC       =1,$/;"	e	enum:__anon14
STBTT_PLATFORM_ID_MICROSOFT	libs/imgui/stb_truetype.h	/^   STBTT_PLATFORM_ID_MICROSOFT =3$/;"	e	enum:__anon14
STBTT_PLATFORM_ID_UNICODE	libs/imgui/stb_truetype.h	/^   STBTT_PLATFORM_ID_UNICODE   =0,$/;"	e	enum:__anon14
STBTT_POINT_SIZE	libs/imgui/stb_truetype.h	527;"	d
STBTT_RASTERIZER_VERSION	libs/imgui/stb_truetype.h	927;"	d
STBTT_STATIC	libs/imgui/imgui.cpp	541;"	d	file:
STBTT_UNICODE_EID_ISO_10646	libs/imgui/stb_truetype.h	/^   STBTT_UNICODE_EID_ISO_10646      =2,$/;"	e	enum:__anon15
STBTT_UNICODE_EID_UNICODE_1_0	libs/imgui/stb_truetype.h	/^   STBTT_UNICODE_EID_UNICODE_1_0    =0,$/;"	e	enum:__anon15
STBTT_UNICODE_EID_UNICODE_1_1	libs/imgui/stb_truetype.h	/^   STBTT_UNICODE_EID_UNICODE_1_1    =1,$/;"	e	enum:__anon15
STBTT_UNICODE_EID_UNICODE_2_0_BMP	libs/imgui/stb_truetype.h	/^   STBTT_UNICODE_EID_UNICODE_2_0_BMP=3,$/;"	e	enum:__anon15
STBTT_UNICODE_EID_UNICODE_2_0_FULL	libs/imgui/stb_truetype.h	/^   STBTT_UNICODE_EID_UNICODE_2_0_FULL=4$/;"	e	enum:__anon15
STBTT__COMPARE	libs/imgui/stb_truetype.h	2137;"	d
STBTT__NOTUSED	libs/imgui/stb_truetype.h	2567;"	d
STBTT__NOTUSED	libs/imgui/stb_truetype.h	2569;"	d
STBTT__OVER_MASK	libs/imgui/stb_truetype.h	2689;"	d
STBTT_assert	libs/imgui/imgui.cpp	539;"	d	file:
STBTT_assert	libs/imgui/stb_truetype.h	412;"	d
STBTT_free	libs/imgui/imgui.cpp	538;"	d	file:
STBTT_free	libs/imgui/stb_truetype.h	407;"	d
STBTT_iceil	libs/imgui/stb_truetype.h	395;"	d
STBTT_ifloor	libs/imgui/stb_truetype.h	394;"	d
STBTT_malloc	libs/imgui/imgui.cpp	537;"	d	file:
STBTT_malloc	libs/imgui/stb_truetype.h	406;"	d
STBTT_memcpy	libs/imgui/stb_truetype.h	422;"	d
STBTT_memset	libs/imgui/stb_truetype.h	423;"	d
STBTT_sqrt	libs/imgui/stb_truetype.h	400;"	d
STBTT_strlen	libs/imgui/stb_truetype.h	417;"	d
STBTT_vcurve	libs/imgui/stb_truetype.h	/^      STBTT_vcurve$/;"	e	enum:__anon11
STBTT_vline	libs/imgui/stb_truetype.h	/^      STBTT_vline,$/;"	e	enum:__anon11
STBTT_vmove	libs/imgui/stb_truetype.h	/^      STBTT_vmove=1,$/;"	e	enum:__anon11
STB_INCLUDE_STB_RECT_PACK_H	libs/imgui/stb_rect_pack.h	35;"	d
STB_RECT_PACK_IMPLEMENTATION	libs/imgui/imgui.cpp	533;"	d	file:
STB_RECT_PACK_VERSION	libs/imgui/stb_rect_pack.h	37;"	d
STB_TEXTEDIT_CHARTYPE	libs/imgui/imgui.cpp	549;"	d	file:
STB_TEXTEDIT_CHARTYPE	libs/imgui/imgui.cpp	551;"	d	file:
STB_TEXTEDIT_CHARTYPE	libs/imgui/stb_textedit.h	269;"	d
STB_TEXTEDIT_DELETECHARS	libs/imgui/imgui.cpp	/^static void STB_TEXTEDIT_DELETECHARS(STB_TEXTEDIT_STRING* obj, int pos, int n)$/;"	f	file:	signature:(STB_TEXTEDIT_STRING* obj, int pos, int n)
STB_TEXTEDIT_GETCHAR	libs/imgui/imgui.cpp	/^static ImWchar STB_TEXTEDIT_GETCHAR(const STB_TEXTEDIT_STRING* obj, int idx)                      { return obj->Text[idx]; }$/;"	f	file:	signature:(const STB_TEXTEDIT_STRING* obj, int idx)
STB_TEXTEDIT_GETWIDTH	libs/imgui/imgui.cpp	/^static float   STB_TEXTEDIT_GETWIDTH(STB_TEXTEDIT_STRING* obj, int line_start_idx, int char_idx)  { ImWchar c = obj->Text[line_start_idx+char_idx]; if (c == '\\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; return GImGui->Font->GetCharAdvance(c) * (GImGui->FontSize \/ GImGui->Font->FontSize); }$/;"	f	file:	signature:(STB_TEXTEDIT_STRING* obj, int line_start_idx, int char_idx)
STB_TEXTEDIT_GETWIDTH_NEWLINE	libs/imgui/imgui.cpp	552;"	d	file:
STB_TEXTEDIT_IMPLEMENTATION	libs/imgui/imgui.cpp	6992;"	d	file:
STB_TEXTEDIT_INSERTCHARS	libs/imgui/imgui.cpp	/^static bool STB_TEXTEDIT_INSERTCHARS(STB_TEXTEDIT_STRING* obj, int pos, const ImWchar* new_text, int new_text_len)$/;"	f	file:	signature:(STB_TEXTEDIT_STRING* obj, int pos, const ImWchar* new_text, int new_text_len)
STB_TEXTEDIT_IS_SPACE	libs/imgui/imgui.cpp	6933;"	d	file:
STB_TEXTEDIT_KEYTOTEXT	libs/imgui/imgui.cpp	/^static int     STB_TEXTEDIT_KEYTOTEXT(int key)                                                    { return key >= 0x10000 ? 0 : key; }$/;"	f	file:	signature:(int key)
STB_TEXTEDIT_K_BACKSPACE	libs/imgui/imgui.cpp	6981;"	d	file:
STB_TEXTEDIT_K_DELETE	libs/imgui/imgui.cpp	6980;"	d	file:
STB_TEXTEDIT_K_DOWN	libs/imgui/imgui.cpp	6975;"	d	file:
STB_TEXTEDIT_K_LEFT	libs/imgui/imgui.cpp	6972;"	d	file:
STB_TEXTEDIT_K_LINEEND	libs/imgui/imgui.cpp	6977;"	d	file:
STB_TEXTEDIT_K_LINESTART	libs/imgui/imgui.cpp	6976;"	d	file:
STB_TEXTEDIT_K_REDO	libs/imgui/imgui.cpp	6983;"	d	file:
STB_TEXTEDIT_K_RIGHT	libs/imgui/imgui.cpp	6973;"	d	file:
STB_TEXTEDIT_K_SHIFT	libs/imgui/imgui.cpp	6986;"	d	file:
STB_TEXTEDIT_K_TEXTEND	libs/imgui/imgui.cpp	6979;"	d	file:
STB_TEXTEDIT_K_TEXTSTART	libs/imgui/imgui.cpp	6978;"	d	file:
STB_TEXTEDIT_K_UNDO	libs/imgui/imgui.cpp	6982;"	d	file:
STB_TEXTEDIT_K_UP	libs/imgui/imgui.cpp	6974;"	d	file:
STB_TEXTEDIT_K_WORDLEFT	libs/imgui/imgui.cpp	6984;"	d	file:
STB_TEXTEDIT_K_WORDRIGHT	libs/imgui/imgui.cpp	6985;"	d	file:
STB_TEXTEDIT_LAYOUTROW	libs/imgui/imgui.cpp	/^static void    STB_TEXTEDIT_LAYOUTROW(StbTexteditRow* r, STB_TEXTEDIT_STRING* obj, int line_start_idx)$/;"	f	file:	signature:(StbTexteditRow* r, STB_TEXTEDIT_STRING* obj, int line_start_idx)
STB_TEXTEDIT_NEWLINE	libs/imgui/imgui.cpp	/^static ImWchar STB_TEXTEDIT_NEWLINE = '\\n';$/;"	v	file:
STB_TEXTEDIT_POSITIONTYPE	libs/imgui/stb_textedit.h	272;"	d
STB_TEXTEDIT_STRING	libs/imgui/imgui.cpp	548;"	d	file:
STB_TEXTEDIT_STRING	libs/imgui/imgui.cpp	550;"	d	file:
STB_TEXTEDIT_STRINGLEN	libs/imgui/imgui.cpp	/^static int     STB_TEXTEDIT_STRINGLEN(const STB_TEXTEDIT_STRING* obj)                             { return obj->CurLenW; }$/;"	f	file:	signature:(const STB_TEXTEDIT_STRING* obj)
STB_TEXTEDIT_UNDOCHARCOUNT	libs/imgui/stb_textedit.h	266;"	d
STB_TEXTEDIT_UNDOSTATECOUNT	libs/imgui/stb_textedit.h	263;"	d
STB_TEXT_HAS_SELECTION	libs/imgui/stb_textedit.h	522;"	d
STB_TRUETYPE_IMPLEMENTATION	libs/imgui/imgui.cpp	542;"	d	file:
STB_TexteditState	libs/imgui/stb_textedit.h	/^} STB_TexteditState;$/;"	t	typeref:struct:__anon4
STRING_H	include/util/String.h	2;"	d
SWAP	include/Standard.h	17;"	d
SameLine	libs/imgui/imgui.cpp	/^void ImGui::SameLine(float pos_x, float spacing_w)$/;"	f	class:ImGui	signature:(float pos_x, float spacing_w)
SameLine	libs/imgui/imgui.h	/^    IMGUI_API void          SameLine(float pos_x = 0.0f, float spacing_w = -1.0f);              \/\/ call between widgets or groups to layout them horizontally$/;"	p	namespace:ImGui	signature:(float pos_x = 0.0f, float spacing_w = -1.0f)
SaveSettings	libs/imgui/imgui.cpp	/^static void SaveSettings()$/;"	f	file:	signature:()
ScalarAsInputTextId	libs/imgui/imgui.cpp	/^    ImGuiID                 ScalarAsInputTextId;                \/\/ Temporary text input when CTRL+clicking on a slider, etc.$/;"	m	struct:ImGuiState	file:	access:public
Scale	libs/imgui/imgui.h	/^    float                       Scale;              \/\/ = 1.0f          \/\/ Base font scale, multiplied by the per-window font scale which you can adjust with SetFontScale()$/;"	m	struct:ImFont	access:public
Script	include/Script.h	/^namespace Script {$/;"	n
ScrollTargetCenterRatioY	libs/imgui/imgui.cpp	/^    float                   ScrollTargetCenterRatioY;           \/\/ 0.0f = scroll so that target position is at top, 0.5f = scroll so that target position is centered$/;"	m	struct:ImGuiWindow	file:	access:public
ScrollTargetRelY	libs/imgui/imgui.cpp	/^    float                   ScrollTargetRelY;                   \/\/ target scroll position. stored as cursor position with scrolling canceled out, so the highest point is always 0.0f. (FLT_MAX for no change)$/;"	m	struct:ImGuiWindow	file:	access:public
ScrollToBottom	libs/imgui/imgui.cpp	/^    bool                  ScrollToBottom;$/;"	m	struct:ExampleAppConsole	file:	access:public
ScrollToBottom	src/util/Console.cpp	/^	bool                  ScrollToBottom;$/;"	m	struct:Console::Console	file:	access:public
ScrollX	libs/imgui/imgui.cpp	/^    float               ScrollX;$/;"	m	struct:ImGuiTextEditState	file:	access:public
ScrollY	libs/imgui/imgui.cpp	/^    float                   ScrollY;$/;"	m	struct:ImGuiWindow	file:	access:public
Scrollbar	libs/imgui/imgui.cpp	/^static void         Scrollbar(ImGuiWindow* window);$/;"	p	file:	signature:(ImGuiWindow* window)
Scrollbar	libs/imgui/imgui.cpp	/^static void Scrollbar(ImGuiWindow* window)$/;"	f	file:	signature:(ImGuiWindow* window)
ScrollbarClickDeltaToGrabCenter	libs/imgui/imgui.cpp	/^    float                   ScrollbarClickDeltaToGrabCenter;    \/\/ distance between mouse and center of grab box, normalized in parent space$/;"	m	struct:ImGuiState	file:	access:public
ScrollbarRounding	libs/imgui/imgui.h	/^    float       ScrollbarRounding;          \/\/ Radius of grab corners for scrollbar$/;"	m	struct:ImGuiStyle	access:public
ScrollbarWidth	libs/imgui/imgui.cpp	/^    float       ScrollbarWidth() const                  { return ScrollbarY ? GImGui->Style.ScrollbarWidth : 0.0f; }$/;"	f	struct:ImGuiWindow	access:public	signature:() const
ScrollbarWidth	libs/imgui/imgui.h	/^    float       ScrollbarWidth;             \/\/ Width of the vertical scrollbar$/;"	m	struct:ImGuiStyle	access:public
ScrollbarY	libs/imgui/imgui.cpp	/^    bool                    ScrollbarY;$/;"	m	struct:ImGuiWindow	file:	access:public
SelectAll	libs/imgui/imgui.cpp	/^    void                SelectAll()                     { StbState.select_start = 0; StbState.select_end = CurLenW; StbState.cursor = StbState.select_end; StbState.has_preferred_x = false; }$/;"	f	struct:ImGuiTextEditState	access:public	signature:()
Selectable	libs/imgui/imgui.cpp	/^bool ImGui::Selectable(const char* label, bool selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)$/;"	f	class:ImGui	signature:(const char* label, bool selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)
Selectable	libs/imgui/imgui.cpp	/^bool ImGui::Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)$/;"	f	class:ImGui	signature:(const char* label, bool* p_selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)
Selectable	libs/imgui/imgui.h	/^    IMGUI_API bool          Selectable(const char* label, bool selected = false, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0));  \/\/ size.x==0.0: use remaining width, size.x>0.0: specify width. size.y==0.0: use label height, size.y>0.0: specify height $/;"	p	namespace:ImGui	signature:(const char* label, bool selected = false, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0))
Selectable	libs/imgui/imgui.h	/^    IMGUI_API bool          Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0));$/;"	p	namespace:ImGui	signature:(const char* label, bool* p_selected, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0))
SelectedAllMouseLock	libs/imgui/imgui.cpp	/^    bool                SelectedAllMouseLock;$/;"	m	struct:ImGuiTextEditState	file:	access:public
SelectionEnd	libs/imgui/imgui.h	/^    int                 SelectionEnd;   \/\/                                      \/\/ Read-write$/;"	m	struct:ImGuiTextEditCallbackData	access:public
SelectionStart	libs/imgui/imgui.h	/^    int                 SelectionStart; \/\/                                      \/\/ Read-write (== to SelectionEnd when no selection)$/;"	m	struct:ImGuiTextEditCallbackData	access:public
Separator	libs/imgui/imgui.cpp	/^void ImGui::Separator()$/;"	f	class:ImGui	signature:()
Separator	libs/imgui/imgui.h	/^    IMGUI_API void          Separator();                                                        \/\/ horizontal line$/;"	p	namespace:ImGui	signature:()
SetActiveId	libs/imgui/imgui.cpp	/^static void SetActiveId(ImGuiID id, ImGuiWindow* window = NULL) $/;"	f	file:	signature:(ImGuiID id, ImGuiWindow* window = NULL)
SetAllInt	libs/imgui/imgui.cpp	/^void ImGuiStorage::SetAllInt(int v)$/;"	f	class:ImGuiStorage	signature:(int v)
SetAllInt	libs/imgui/imgui.h	/^    IMGUI_API void    SetAllInt(int val);$/;"	p	struct:ImGuiStorage	access:public	signature:(int val)
SetClipboardTextFn	libs/imgui/imgui.h	/^    void        (*SetClipboardTextFn)(const char* text);$/;"	m	struct:ImGuiIO	access:public
SetClipboardTextFn_DefaultImpl	libs/imgui/imgui.cpp	/^static void         SetClipboardTextFn_DefaultImpl(const char* text);$/;"	p	file:	signature:(const char* text)
SetClipboardTextFn_DefaultImpl	libs/imgui/imgui.cpp	/^static void SetClipboardTextFn_DefaultImpl(const char* text)$/;"	f	file:	signature:(const char* text)
SetColumnOffset	libs/imgui/imgui.cpp	/^void ImGui::SetColumnOffset(int column_index, float offset)$/;"	f	class:ImGui	signature:(int column_index, float offset)
SetColumnOffset	libs/imgui/imgui.h	/^    IMGUI_API void          SetColumnOffset(int column_index, float offset_x);                  \/\/ set position of column line (in pixels, from the left side of the contents region). pass -1 to use current column$/;"	p	namespace:ImGui	signature:(int column_index, float offset_x)
SetCurrentWindow	libs/imgui/imgui.cpp	/^static inline void SetCurrentWindow(ImGuiWindow* window)$/;"	f	file:	signature:(ImGuiWindow* window)
SetCursorPos	libs/imgui/imgui.cpp	/^void ImGui::SetCursorPos(const ImVec2& pos)$/;"	f	class:ImGui	signature:(const ImVec2& pos)
SetCursorPos	libs/imgui/imgui.h	/^    IMGUI_API void          SetCursorPos(const ImVec2& pos);                                    \/\/ "$/;"	p	namespace:ImGui	signature:(const ImVec2& pos)
SetCursorPosX	libs/imgui/imgui.cpp	/^void ImGui::SetCursorPosX(float x)$/;"	f	class:ImGui	signature:(float x)
SetCursorPosX	libs/imgui/imgui.h	/^    IMGUI_API void          SetCursorPosX(float x);                                             \/\/ "$/;"	p	namespace:ImGui	signature:(float x)
SetCursorPosY	libs/imgui/imgui.cpp	/^void ImGui::SetCursorPosY(float y)$/;"	f	class:ImGui	signature:(float y)
SetCursorPosY	libs/imgui/imgui.h	/^    IMGUI_API void          SetCursorPosY(float y);                                             \/\/ "$/;"	p	namespace:ImGui	signature:(float y)
SetCursorScreenPos	libs/imgui/imgui.cpp	/^void ImGui::SetCursorScreenPos(const ImVec2& screen_pos)$/;"	f	class:ImGui	signature:(const ImVec2& screen_pos)
SetCursorScreenPos	libs/imgui/imgui.h	/^    IMGUI_API void          SetCursorScreenPos(const ImVec2& pos);                              \/\/ cursor position in absolute screen coordinates [0..io.DisplaySize]$/;"	p	namespace:ImGui	signature:(const ImVec2& pos)
SetFallbackChar	libs/imgui/imgui.cpp	/^void ImFont::SetFallbackChar(ImWchar c)$/;"	f	class:ImFont	signature:(ImWchar c)
SetFallbackChar	libs/imgui/imgui.h	/^    IMGUI_API void              SetFallbackChar(ImWchar c);$/;"	p	struct:ImFont	access:public	signature:(ImWchar c)
SetFloat	libs/imgui/imgui.cpp	/^void ImGuiStorage::SetFloat(ImU32 key, float val)$/;"	f	class:ImGuiStorage	signature:(ImU32 key, float val)
SetFloat	libs/imgui/imgui.h	/^    IMGUI_API void    SetFloat(ImGuiID key, float val);$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, float val)
SetFont	libs/imgui/imgui.cpp	/^static void         SetFont(ImFont* font);$/;"	p	file:	signature:(ImFont* font)
SetFont	libs/imgui/imgui.cpp	/^static void SetFont(ImFont* font)$/;"	f	file:	signature:(ImFont* font)
SetInt	libs/imgui/imgui.cpp	/^void ImGuiStorage::SetInt(ImU32 key, int val)$/;"	f	class:ImGuiStorage	signature:(ImU32 key, int val)
SetInt	libs/imgui/imgui.h	/^    IMGUI_API void    SetInt(ImGuiID key, int val);$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, int val)
SetInternalState	libs/imgui/imgui.cpp	/^void ImGui::SetInternalState(void* state, bool construct)$/;"	f	class:ImGui	signature:(void* state, bool construct)
SetInternalState	libs/imgui/imgui.h	/^    IMGUI_API void          SetInternalState(void* state, bool construct = false);$/;"	p	namespace:ImGui	signature:(void* state, bool construct = false)
SetKeyboardFocusHere	libs/imgui/imgui.cpp	/^void ImGui::SetKeyboardFocusHere(int offset)$/;"	f	class:ImGui	signature:(int offset)
SetKeyboardFocusHere	libs/imgui/imgui.h	/^    IMGUI_API void          SetKeyboardFocusHere(int offset = 0);                               \/\/ focus keyboard on the next widget. Use positive 'offset' to access sub components of a multiple component widget$/;"	p	namespace:ImGui	signature:(int offset = 0)
SetMouseCursor	libs/imgui/imgui.cpp	/^void ImGui::SetMouseCursor(ImGuiMouseCursor cursor_type)$/;"	f	class:ImGui	signature:(ImGuiMouseCursor cursor_type)
SetMouseCursor	libs/imgui/imgui.h	/^    IMGUI_API void          SetMouseCursor(ImGuiMouseCursor type);                              \/\/ set desired cursor type$/;"	p	namespace:ImGui	signature:(ImGuiMouseCursor type)
SetNextTreeNodeOpened	libs/imgui/imgui.cpp	/^void ImGui::SetNextTreeNodeOpened(bool opened, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(bool opened, ImGuiSetCond cond)
SetNextTreeNodeOpened	libs/imgui/imgui.h	/^    IMGUI_API void          SetNextTreeNodeOpened(bool opened, ImGuiSetCond cond = 0);          \/\/ set next tree node to be opened.$/;"	p	namespace:ImGui	signature:(bool opened, ImGuiSetCond cond = 0)
SetNextTreeNodeOpenedCond	libs/imgui/imgui.cpp	/^    ImGuiSetCond            SetNextTreeNodeOpenedCond;$/;"	m	struct:ImGuiState	file:	access:public
SetNextTreeNodeOpenedVal	libs/imgui/imgui.cpp	/^    bool                    SetNextTreeNodeOpenedVal;$/;"	m	struct:ImGuiState	file:	access:public
SetNextWindowCollapsed	libs/imgui/imgui.cpp	/^void ImGui::SetNextWindowCollapsed(bool collapsed, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(bool collapsed, ImGuiSetCond cond)
SetNextWindowCollapsed	libs/imgui/imgui.h	/^    IMGUI_API void          SetNextWindowCollapsed(bool collapsed, ImGuiSetCond cond = 0);      \/\/ set next window collapsed state. call before Begin()$/;"	p	namespace:ImGui	signature:(bool collapsed, ImGuiSetCond cond = 0)
SetNextWindowCollapsedCond	libs/imgui/imgui.cpp	/^    ImGuiSetCond            SetNextWindowCollapsedCond;$/;"	m	struct:ImGuiState	file:	access:public
SetNextWindowCollapsedVal	libs/imgui/imgui.cpp	/^    bool                    SetNextWindowCollapsedVal;$/;"	m	struct:ImGuiState	file:	access:public
SetNextWindowFocus	libs/imgui/imgui.cpp	/^    bool                    SetNextWindowFocus;$/;"	m	struct:ImGuiState	file:	access:public
SetNextWindowFocus	libs/imgui/imgui.cpp	/^void ImGui::SetNextWindowFocus()$/;"	f	class:ImGui	signature:()
SetNextWindowFocus	libs/imgui/imgui.h	/^    IMGUI_API void          SetNextWindowFocus();                                               \/\/ set next window to be focused \/ front-most. call before Begin()$/;"	p	namespace:ImGui	signature:()
SetNextWindowPos	libs/imgui/imgui.cpp	/^void ImGui::SetNextWindowPos(const ImVec2& pos, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(const ImVec2& pos, ImGuiSetCond cond)
SetNextWindowPos	libs/imgui/imgui.h	/^    IMGUI_API void          SetNextWindowPos(const ImVec2& pos, ImGuiSetCond cond = 0);         \/\/ set next window position. call before Begin()$/;"	p	namespace:ImGui	signature:(const ImVec2& pos, ImGuiSetCond cond = 0)
SetNextWindowPosCenter	libs/imgui/imgui.cpp	/^void ImGui::SetNextWindowPosCenter(ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(ImGuiSetCond cond)
SetNextWindowPosCenter	libs/imgui/imgui.h	/^    IMGUI_API void          SetNextWindowPosCenter(ImGuiSetCond cond = 0);                      \/\/ set next window position to be centered on screen. call before Begin()$/;"	p	namespace:ImGui	signature:(ImGuiSetCond cond = 0)
SetNextWindowPosCond	libs/imgui/imgui.cpp	/^    ImGuiSetCond            SetNextWindowPosCond;$/;"	m	struct:ImGuiState	file:	access:public
SetNextWindowPosVal	libs/imgui/imgui.cpp	/^    ImVec2                  SetNextWindowPosVal;$/;"	m	struct:ImGuiState	file:	access:public
SetNextWindowSize	libs/imgui/imgui.cpp	/^void ImGui::SetNextWindowSize(const ImVec2& size, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(const ImVec2& size, ImGuiSetCond cond)
SetNextWindowSize	libs/imgui/imgui.h	/^    IMGUI_API void          SetNextWindowSize(const ImVec2& size, ImGuiSetCond cond = 0);       \/\/ set next window size. set to ImVec2(0,0) to force an auto-fit. call before Begin()$/;"	p	namespace:ImGui	signature:(const ImVec2& size, ImGuiSetCond cond = 0)
SetNextWindowSizeCond	libs/imgui/imgui.cpp	/^    ImGuiSetCond            SetNextWindowSizeCond;$/;"	m	struct:ImGuiState	file:	access:public
SetNextWindowSizeVal	libs/imgui/imgui.cpp	/^    ImVec2                  SetNextWindowSizeVal;$/;"	m	struct:ImGuiState	file:	access:public
SetScrollFromPosY	libs/imgui/imgui.cpp	/^void ImGui::SetScrollFromPosY(float pos_y, float center_y_ratio)$/;"	f	class:ImGui	signature:(float pos_y, float center_y_ratio)
SetScrollFromPosY	libs/imgui/imgui.h	/^    IMGUI_API void          SetScrollFromPosY(float pos_y, float center_y_ratio = 0.5f);        \/\/ adjust scrolling amount to make given position valid. use GetCursorPos() or GetCursorStartPos()+offset to get valid positions.$/;"	p	namespace:ImGui	signature:(float pos_y, float center_y_ratio = 0.5f)
SetScrollHere	libs/imgui/imgui.cpp	/^void ImGui::SetScrollHere(float center_y_ratio)$/;"	f	class:ImGui	signature:(float center_y_ratio)
SetScrollHere	libs/imgui/imgui.h	/^    IMGUI_API void          SetScrollHere(float center_y_ratio = 0.5f);                         \/\/ adjust scrolling amount to make current cursor position visible. center_y_ratio=0.0: top, 0.5: center, 1.0: bottom.$/;"	p	namespace:ImGui	signature:(float center_y_ratio = 0.5f)
SetScrollPosHere	libs/imgui/imgui.h	/^    static inline void      SetScrollPosHere() { SetScrollHere(); }                            \/\/ OBSOLETE 1.42+$/;"	f	namespace:ImGui	signature:()
SetScrollY	libs/imgui/imgui.cpp	/^void ImGui::SetScrollY(float scroll_y)$/;"	f	class:ImGui	signature:(float scroll_y)
SetScrollY	libs/imgui/imgui.h	/^    IMGUI_API void          SetScrollY(float scroll_y);                                         \/\/ set scrolling amount [0..GetScrollMaxY()]$/;"	p	namespace:ImGui	signature:(float scroll_y)
SetStateStorage	libs/imgui/imgui.cpp	/^void ImGui::SetStateStorage(ImGuiStorage* tree)$/;"	f	class:ImGui	signature:(ImGuiStorage* tree)
SetStateStorage	libs/imgui/imgui.h	/^    IMGUI_API void          SetStateStorage(ImGuiStorage* tree);                                \/\/ replace tree state storage with our own (if you want to manipulate it yourself, typically clear subsection of it)$/;"	p	namespace:ImGui	signature:(ImGuiStorage* tree)
SetTexID	libs/imgui/imgui.h	/^    IMGUI_API void              SetTexID(void* id)  { TexID = id; }$/;"	f	struct:ImFontAtlas	access:public	signature:(void* id)
SetTooltip	libs/imgui/imgui.cpp	/^void ImGui::SetTooltip(const char* fmt, ...)$/;"	f	class:ImGui	signature:(const char* fmt, ...)
SetTooltip	libs/imgui/imgui.h	/^    IMGUI_API void          SetTooltip(const char* fmt, ...);                                   \/\/ set tooltip under mouse-cursor, typically use with ImGui::IsHovered(). last call wins$/;"	p	namespace:ImGui	signature:(const char* fmt, ...)
SetTooltipV	libs/imgui/imgui.cpp	/^void ImGui::SetTooltipV(const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const char* fmt, va_list args)
SetTooltipV	libs/imgui/imgui.h	/^    IMGUI_API void          SetTooltipV(const char* fmt, va_list args);$/;"	p	namespace:ImGui	signature:(const char* fmt, va_list args)
SetVoidPtr	libs/imgui/imgui.cpp	/^void ImGuiStorage::SetVoidPtr(ImU32 key, void* val)$/;"	f	class:ImGuiStorage	signature:(ImU32 key, void* val)
SetVoidPtr	libs/imgui/imgui.h	/^    IMGUI_API void    SetVoidPtr(ImGuiID key, void* val);$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, void* val)
SetWindowCollapsed	libs/imgui/imgui.cpp	/^static void SetWindowCollapsed(ImGuiWindow* window, bool collapsed, ImGuiSetCond cond)$/;"	f	file:	signature:(ImGuiWindow* window, bool collapsed, ImGuiSetCond cond)
SetWindowCollapsed	libs/imgui/imgui.cpp	/^void ImGui::SetWindowCollapsed(bool collapsed, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(bool collapsed, ImGuiSetCond cond)
SetWindowCollapsed	libs/imgui/imgui.cpp	/^void ImGui::SetWindowCollapsed(const char* name, bool collapsed, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(const char* name, bool collapsed, ImGuiSetCond cond)
SetWindowCollapsed	libs/imgui/imgui.h	/^    IMGUI_API void          SetWindowCollapsed(bool collapsed, ImGuiSetCond cond = 0);          \/\/ set current window collapsed state$/;"	p	namespace:ImGui	signature:(bool collapsed, ImGuiSetCond cond = 0)
SetWindowCollapsed	libs/imgui/imgui.h	/^    IMGUI_API void          SetWindowCollapsed(const char* name, bool collapsed, ImGuiSetCond cond = 0);   \/\/ set named window collapsed state$/;"	p	namespace:ImGui	signature:(const char* name, bool collapsed, ImGuiSetCond cond = 0)
SetWindowCollapsedAllowFlags	libs/imgui/imgui.cpp	/^    int                     SetWindowCollapsedAllowFlags;       \/\/ bit ImGuiSetCond_*** specify if SetWindowCollapsed() call will succeed with this particular flag. $/;"	m	struct:ImGuiWindow	file:	access:public
SetWindowFocus	libs/imgui/imgui.cpp	/^void ImGui::SetWindowFocus()$/;"	f	class:ImGui	signature:()
SetWindowFocus	libs/imgui/imgui.cpp	/^void ImGui::SetWindowFocus(const char* name)$/;"	f	class:ImGui	signature:(const char* name)
SetWindowFocus	libs/imgui/imgui.h	/^    IMGUI_API void          SetWindowFocus();                                                   \/\/ set current window to be focused \/ front-most$/;"	p	namespace:ImGui	signature:()
SetWindowFocus	libs/imgui/imgui.h	/^    IMGUI_API void          SetWindowFocus(const char* name);                                              \/\/ set named window to be focused \/ front-most. use NULL to remove focus.$/;"	p	namespace:ImGui	signature:(const char* name)
SetWindowFontScale	libs/imgui/imgui.cpp	/^void ImGui::SetWindowFontScale(float scale)$/;"	f	class:ImGui	signature:(float scale)
SetWindowFontScale	libs/imgui/imgui.h	/^    IMGUI_API void          SetWindowFontScale(float scale);                                    \/\/ per-window font scale. Adjust IO.FontGlobalScale if you want to scale all windows$/;"	p	namespace:ImGui	signature:(float scale)
SetWindowPos	libs/imgui/imgui.cpp	/^static void SetWindowPos(ImGuiWindow* window, const ImVec2& pos, ImGuiSetCond cond)$/;"	f	file:	signature:(ImGuiWindow* window, const ImVec2& pos, ImGuiSetCond cond)
SetWindowPos	libs/imgui/imgui.cpp	/^void ImGui::SetWindowPos(const ImVec2& pos, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(const ImVec2& pos, ImGuiSetCond cond)
SetWindowPos	libs/imgui/imgui.cpp	/^void ImGui::SetWindowPos(const char* name, const ImVec2& pos, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(const char* name, const ImVec2& pos, ImGuiSetCond cond)
SetWindowPos	libs/imgui/imgui.h	/^    IMGUI_API void          SetWindowPos(const ImVec2& pos, ImGuiSetCond cond = 0);             \/\/ set current window position - call within Begin()\/End(). may incur tearing$/;"	p	namespace:ImGui	signature:(const ImVec2& pos, ImGuiSetCond cond = 0)
SetWindowPos	libs/imgui/imgui.h	/^    IMGUI_API void          SetWindowPos(const char* name, const ImVec2& pos, ImGuiSetCond cond = 0);      \/\/ set named window position - call within Begin()\/End(). may incur tearing$/;"	p	namespace:ImGui	signature:(const char* name, const ImVec2& pos, ImGuiSetCond cond = 0)
SetWindowPosAllowFlags	libs/imgui/imgui.cpp	/^    int                     SetWindowPosAllowFlags;             \/\/ bit ImGuiSetCond_*** specify if SetWindowPos() call will succeed with this particular flag. $/;"	m	struct:ImGuiWindow	file:	access:public
SetWindowPosCenterWanted	libs/imgui/imgui.cpp	/^    bool                    SetWindowPosCenterWanted;$/;"	m	struct:ImGuiWindow	file:	access:public
SetWindowScrollY	libs/imgui/imgui.cpp	/^static void         SetWindowScrollY(ImGuiWindow* window, float scroll_y);$/;"	p	file:	signature:(ImGuiWindow* window, float scroll_y)
SetWindowScrollY	libs/imgui/imgui.cpp	/^static void SetWindowScrollY(ImGuiWindow* window, float new_scroll_y)$/;"	f	file:	signature:(ImGuiWindow* window, float new_scroll_y)
SetWindowSize	libs/imgui/imgui.cpp	/^static void SetWindowSize(ImGuiWindow* window, const ImVec2& size, ImGuiSetCond cond)$/;"	f	file:	signature:(ImGuiWindow* window, const ImVec2& size, ImGuiSetCond cond)
SetWindowSize	libs/imgui/imgui.cpp	/^void ImGui::SetWindowSize(const ImVec2& size, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(const ImVec2& size, ImGuiSetCond cond)
SetWindowSize	libs/imgui/imgui.cpp	/^void ImGui::SetWindowSize(const char* name, const ImVec2& size, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(const char* name, const ImVec2& size, ImGuiSetCond cond)
SetWindowSize	libs/imgui/imgui.h	/^    IMGUI_API void          SetWindowSize(const ImVec2& size, ImGuiSetCond cond = 0);           \/\/ set current window size. set to ImVec2(0,0) to force an auto-fit. may incur tearing$/;"	p	namespace:ImGui	signature:(const ImVec2& size, ImGuiSetCond cond = 0)
SetWindowSize	libs/imgui/imgui.h	/^    IMGUI_API void          SetWindowSize(const char* name, const ImVec2& size, ImGuiSetCond cond = 0);    \/\/ set named window size. set to ImVec2(0,0) to force an auto-fit. may incur tearing$/;"	p	namespace:ImGui	signature:(const char* name, const ImVec2& size, ImGuiSetCond cond = 0)
SetWindowSizeAllowFlags	libs/imgui/imgui.cpp	/^    int                     SetWindowSizeAllowFlags;            \/\/ bit ImGuiSetCond_*** specify if SetWindowSize() call will succeed with this particular flag. $/;"	m	struct:ImGuiWindow	file:	access:public
Settings	libs/imgui/imgui.cpp	/^    ImVector<ImGuiIniData>  Settings;$/;"	m	struct:ImGuiState	file:	access:public
SettingsDirtyTimer	libs/imgui/imgui.cpp	/^    float                   SettingsDirtyTimer;$/;"	m	struct:ImGuiState	file:	access:public
Shader	include/gfx/ShaderLoader.h	/^namespace Shader {$/;"	n
Shader	src/gfx/ShaderLoader.cpp	/^namespace Shader {$/;"	n	file:
Shader::compileShader	src/gfx/ShaderLoader.cpp	/^    GLuint compileShader(std::string name, GLenum shaderType) {$/;"	f	namespace:Shader	signature:(std::string name, GLenum shaderType)
Shader::compileShader	src/gfx/ShaderLoader.cpp	/^    GLuint compileShader(std::string name, GLenum shaderType);$/;"	p	namespace:Shader	file:	signature:(std::string name, GLenum shaderType)
Shader::load	include/gfx/ShaderLoader.h	/^    GLuint load(const char *nameVert, const char *nameFrag);$/;"	p	namespace:Shader	signature:(const char *nameVert, const char *nameFrag)
Shader::load	src/gfx/ShaderLoader.cpp	/^    GLuint load(const char *nameVert, const char *nameFrag) {$/;"	f	namespace:Shader	signature:(const char *nameVert, const char *nameFrag)
Shader::readShader	src/gfx/ShaderLoader.cpp	/^    void readShader(std::string fileName, std::vector<char> &buffer) {$/;"	f	namespace:Shader	signature:(std::string fileName, std::vector<char> &buffer)
Shader::readShader	src/gfx/ShaderLoader.cpp	/^    void readShader(std::string fileName, std::vector<char> &buffer);$/;"	p	namespace:Shader	file:	signature:(std::string fileName, std::vector<char> &buffer)
ShowExampleAppAutoResize	libs/imgui/imgui.cpp	/^static void ShowExampleAppAutoResize(bool* opened)$/;"	f	file:	signature:(bool* opened)
ShowExampleAppAutoResize	libs/imgui/imgui.cpp	/^static void ShowExampleAppAutoResize(bool* opened);$/;"	p	file:	signature:(bool* opened)
ShowExampleAppConsole	libs/imgui/imgui.cpp	/^static void ShowExampleAppConsole(bool* opened)$/;"	f	file:	signature:(bool* opened)
ShowExampleAppConsole	libs/imgui/imgui.cpp	/^static void ShowExampleAppConsole(bool* opened);$/;"	p	file:	signature:(bool* opened)
ShowExampleAppCustomRendering	libs/imgui/imgui.cpp	/^static void ShowExampleAppCustomRendering(bool* opened)$/;"	f	file:	signature:(bool* opened)
ShowExampleAppCustomRendering	libs/imgui/imgui.cpp	/^static void ShowExampleAppCustomRendering(bool* opened);$/;"	p	file:	signature:(bool* opened)
ShowExampleAppFixedOverlay	libs/imgui/imgui.cpp	/^static void ShowExampleAppFixedOverlay(bool* opened)$/;"	f	file:	signature:(bool* opened)
ShowExampleAppFixedOverlay	libs/imgui/imgui.cpp	/^static void ShowExampleAppFixedOverlay(bool* opened);$/;"	p	file:	signature:(bool* opened)
ShowExampleAppLayout	libs/imgui/imgui.cpp	/^static void ShowExampleAppLayout(bool* opened)$/;"	f	file:	signature:(bool* opened)
ShowExampleAppLayout	libs/imgui/imgui.cpp	/^static void ShowExampleAppLayout(bool* opened);$/;"	p	file:	signature:(bool* opened)
ShowExampleAppLongText	libs/imgui/imgui.cpp	/^static void ShowExampleAppLongText(bool* opened)$/;"	f	file:	signature:(bool* opened)
ShowExampleAppLongText	libs/imgui/imgui.cpp	/^static void ShowExampleAppLongText(bool* opened);$/;"	p	file:	signature:(bool* opened)
ShowExampleAppMainMenuBar	libs/imgui/imgui.cpp	/^static void ShowExampleAppMainMenuBar()$/;"	f	file:	signature:()
ShowExampleAppMainMenuBar	libs/imgui/imgui.cpp	/^static void ShowExampleAppMainMenuBar();$/;"	p	file:	signature:()
ShowExampleAppManipulatingWindowTitle	libs/imgui/imgui.cpp	/^static void ShowExampleAppManipulatingWindowTitle(bool* opened)$/;"	f	file:	signature:(bool* opened)
ShowExampleAppManipulatingWindowTitle	libs/imgui/imgui.cpp	/^static void ShowExampleAppManipulatingWindowTitle(bool* opened);$/;"	p	file:	signature:(bool* opened)
ShowExampleMenuFile	libs/imgui/imgui.cpp	/^static void ShowExampleMenuFile()$/;"	f	file:	signature:()
ShowExampleMenuFile	libs/imgui/imgui.cpp	/^static void ShowExampleMenuFile();$/;"	p	file:	signature:()
ShowHelpMarker	libs/imgui/imgui.cpp	/^static void ShowHelpMarker(const char* desc)$/;"	f	file:	signature:(const char* desc)
ShowMetricsWindow	libs/imgui/imgui.cpp	/^void ImGui::ShowMetricsWindow(bool* opened)$/;"	f	class:ImGui	signature:(bool* opened)
ShowMetricsWindow	libs/imgui/imgui.h	/^    IMGUI_API void          ShowMetricsWindow(bool* opened = NULL);     \/\/ metrics window for debugging imgui$/;"	p	namespace:ImGui	signature:(bool* opened = NULL)
ShowStyleEditor	libs/imgui/imgui.cpp	/^void ImGui::ShowStyleEditor(ImGuiStyle* ref)$/;"	f	class:ImGui	signature:(ImGuiStyle* ref)
ShowStyleEditor	libs/imgui/imgui.h	/^    IMGUI_API void          ShowStyleEditor(ImGuiStyle* ref = NULL);    \/\/ style editor block$/;"	p	namespace:ImGui	signature:(ImGuiStyle* ref = NULL)
ShowTestWindow	libs/imgui/imgui.cpp	/^void ImGui::ShowTestWindow(bool* opened)$/;"	f	class:ImGui	signature:(bool* opened)
ShowTestWindow	libs/imgui/imgui.cpp	/^void ImGui::ShowTestWindow(bool*) {}$/;"	f	class:ImGui	signature:(bool*)
ShowTestWindow	libs/imgui/imgui.h	/^    IMGUI_API void          ShowTestWindow(bool* opened = NULL);        \/\/ test window, demonstrate ImGui features$/;"	p	namespace:ImGui	signature:(bool* opened = NULL)
ShowUserGuide	libs/imgui/imgui.cpp	/^void ImGui::ShowUserGuide()$/;"	f	class:ImGui	signature:()
ShowUserGuide	libs/imgui/imgui.h	/^    IMGUI_API void          ShowUserGuide();                            \/\/ help block$/;"	p	namespace:ImGui	signature:()
Shutdown	libs/imgui/imgui.cpp	/^void ImGui::Shutdown()$/;"	f	class:ImGui	signature:()
Shutdown	libs/imgui/imgui.h	/^    IMGUI_API void          Shutdown();$/;"	p	namespace:ImGui	signature:()
Size	libs/imgui/imgui.cpp	/^    ImVec2                  Size;                               \/\/ Current size (==SizeFull or collapsed title bar size)$/;"	m	struct:ImGuiWindow	file:	access:public
Size	libs/imgui/imgui.cpp	/^    ImVec2              Size;$/;"	m	struct:ImGuiMouseCursorData	file:	access:public
Size	libs/imgui/imgui.cpp	/^    ImVec2  Size;$/;"	m	struct:ImGuiIniData	file:	access:public
Size	libs/imgui/imgui.h	/^    int                         Size;$/;"	m	class:ImVector	access:public
SizeContents	libs/imgui/imgui.cpp	/^    ImVec2                  SizeContents;                       \/\/ Size of contents (== extents reach of the drawing cursor) from previous frame$/;"	m	struct:ImGuiWindow	file:	access:public
SizeFull	libs/imgui/imgui.cpp	/^    ImVec2                  SizeFull;                           \/\/ Size when non collapsed$/;"	m	struct:ImGuiWindow	file:	access:public
SizePixels	libs/imgui/imgui.h	/^    float           SizePixels;                 \/\/          \/\/ Size in pixels for rasterizer$/;"	m	struct:ImFontConfig	access:public
SkipItems	libs/imgui/imgui.cpp	/^    bool                    SkipItems;                          \/\/ == Visible && !Collapsed$/;"	m	struct:ImGuiWindow	file:	access:public
SliderAngle	libs/imgui/imgui.cpp	/^bool ImGui::SliderAngle(const char* label, float* v_rad, float v_degrees_min, float v_degrees_max)$/;"	f	class:ImGui	signature:(const char* label, float* v_rad, float v_degrees_min, float v_degrees_max)
SliderAngle	libs/imgui/imgui.h	/^    IMGUI_API bool          SliderAngle(const char* label, float* v_rad, float v_degrees_min = -360.0f, float v_degrees_max = +360.0f);$/;"	p	namespace:ImGui	signature:(const char* label, float* v_rad, float v_degrees_min = -360.0f, float v_degrees_max = +360.0f)
SliderBehavior	libs/imgui/imgui.cpp	/^static bool SliderBehavior(const ImRect& frame_bb, ImGuiID id, float* v, float v_min, float v_max, float power, int decimal_precision, bool horizontal)$/;"	f	file:	signature:(const ImRect& frame_bb, ImGuiID id, float* v, float v_min, float v_max, float power, int decimal_precision, bool horizontal)
SliderFloat	libs/imgui/imgui.cpp	/^bool ImGui::SliderFloat(const char* label, float* v, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float* v, float v_min, float v_max, const char* display_format, float power)
SliderFloat	libs/imgui/imgui.h	/^    IMGUI_API bool          SliderFloat(const char* label, float* v, float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);     \/\/ adjust display_format to decorate the value with a prefix or a suffix. Use power!=1.0 for logarithmic sliders$/;"	p	namespace:ImGui	signature:(const char* label, float* v, float v_min, float v_max, const char* display_format = Ó, float power = 1.0f)
SliderFloat2	libs/imgui/imgui.cpp	/^bool ImGui::SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float v[2], float v_min, float v_max, const char* display_format, float power)
SliderFloat2	libs/imgui/imgui.h	/^    IMGUI_API bool          SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);$/;"	p	namespace:ImGui	signature:(const char* label, float v[2], float v_min, float v_max, const char* display_format = Ó, float power = 1.0f)
SliderFloat3	libs/imgui/imgui.cpp	/^bool ImGui::SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float v[3], float v_min, float v_max, const char* display_format, float power)
SliderFloat3	libs/imgui/imgui.h	/^    IMGUI_API bool          SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);$/;"	p	namespace:ImGui	signature:(const char* label, float v[3], float v_min, float v_max, const char* display_format = Ó, float power = 1.0f)
SliderFloat4	libs/imgui/imgui.cpp	/^bool ImGui::SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float v[4], float v_min, float v_max, const char* display_format, float power)
SliderFloat4	libs/imgui/imgui.h	/^    IMGUI_API bool          SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);$/;"	p	namespace:ImGui	signature:(const char* label, float v[4], float v_min, float v_max, const char* display_format = Ó, float power = 1.0f)
SliderFloatN	libs/imgui/imgui.cpp	/^static bool SliderFloatN(const char* label, float* v, int components, float v_min, float v_max, const char* display_format, float power)$/;"	f	file:	signature:(const char* label, float* v, int components, float v_min, float v_max, const char* display_format, float power)
SliderInt	libs/imgui/imgui.cpp	/^bool ImGui::SliderInt(const char* label, int* v, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int* v, int v_min, int v_max, const char* display_format)
SliderInt	libs/imgui/imgui.h	/^    IMGUI_API bool          SliderInt(const char* label, int* v, int v_min, int v_max, const char* display_format = "%.0f");$/;"	p	namespace:ImGui	signature:(const char* label, int* v, int v_min, int v_max, const char* display_format = Ó)
SliderInt2	libs/imgui/imgui.cpp	/^bool ImGui::SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int v[2], int v_min, int v_max, const char* display_format)
SliderInt2	libs/imgui/imgui.h	/^    IMGUI_API bool          SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* display_format = "%.0f");$/;"	p	namespace:ImGui	signature:(const char* label, int v[2], int v_min, int v_max, const char* display_format = Ó)
SliderInt3	libs/imgui/imgui.cpp	/^bool ImGui::SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int v[3], int v_min, int v_max, const char* display_format)
SliderInt3	libs/imgui/imgui.h	/^    IMGUI_API bool          SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* display_format = "%.0f");$/;"	p	namespace:ImGui	signature:(const char* label, int v[3], int v_min, int v_max, const char* display_format = Ó)
SliderInt4	libs/imgui/imgui.cpp	/^bool ImGui::SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int v[4], int v_min, int v_max, const char* display_format)
SliderInt4	libs/imgui/imgui.h	/^    IMGUI_API bool          SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* display_format = "%.0f");$/;"	p	namespace:ImGui	signature:(const char* label, int v[4], int v_min, int v_max, const char* display_format = Ó)
SliderIntN	libs/imgui/imgui.cpp	/^static bool SliderIntN(const char* label, int* v, int components, int v_min, int v_max, const char* display_format)$/;"	f	file:	signature:(const char* label, int* v, int components, int v_min, int v_max, const char* display_format)
SmallButton	libs/imgui/imgui.cpp	/^bool ImGui::SmallButton(const char* label)$/;"	f	class:ImGui	signature:(const char* label)
SmallButton	libs/imgui/imgui.h	/^    IMGUI_API bool          SmallButton(const char* label);$/;"	p	namespace:ImGui	signature:(const char* label)
Spacing	libs/imgui/imgui.cpp	/^    float  Spacing;$/;"	m	struct:ImGuiSimpleColumns	file:	access:public
Spacing	libs/imgui/imgui.cpp	/^void ImGui::Spacing()$/;"	f	class:ImGui	signature:()
Spacing	libs/imgui/imgui.h	/^    IMGUI_API void          Spacing();                                                          \/\/ add spacing$/;"	p	namespace:ImGui	signature:()
StackSizesBackup	libs/imgui/imgui.cpp	/^    int                     StackSizesBackup[6];    \/\/ Store size of various stacks for asserting$/;"	m	struct:ImGuiDrawContext	file:	access:public
StateStorage	libs/imgui/imgui.cpp	/^    ImGuiStorage            StateStorage;$/;"	m	struct:ImGuiWindow	file:	access:public
StateStorage	libs/imgui/imgui.cpp	/^    ImGuiStorage*           StateStorage;$/;"	m	struct:ImGuiDrawContext	file:	access:public
StbFindState	libs/imgui/stb_textedit.h	/^} StbFindState;$/;"	t	typeref:struct:__anon6
StbState	libs/imgui/imgui.cpp	/^    STB_TexteditState   StbState;$/;"	m	struct:ImGuiTextEditState	file:	access:public
StbTexteditRow	libs/imgui/stb_textedit.h	/^} StbTexteditRow;$/;"	t	typeref:struct:__anon5
StbUndoRecord	libs/imgui/stb_textedit.h	/^} StbUndoRecord;$/;"	t	typeref:struct:__anon2
StbUndoState	libs/imgui/stb_textedit.h	/^} StbUndoState;$/;"	t	typeref:struct:__anon3
Stride	libs/imgui/imgui.cpp	/^    int Stride;$/;"	m	struct:ImGuiPlotArrayGetterData	file:	access:public
String	include/util/String.h	/^namespace String {$/;"	n
String	src/util/String.cpp	/^namespace String {$/;"	n	file:
String::format	include/util/String.h	/^    std::string format(const char *fmt, ...);$/;"	p	namespace:String	signature:(const char *fmt, ...)
String::format	src/util/String.cpp	/^    std::string format(const char *fmt, ...) {$/;"	f	namespace:String	signature:(const char *fmt, ...)
Style	libs/imgui/imgui.cpp	/^    ImGuiStyle              Style;$/;"	m	struct:ImGuiState	file:	access:public
StyleModifiers	libs/imgui/imgui.cpp	/^    ImVector<ImGuiStyleMod> StyleModifiers;$/;"	m	struct:ImGuiState	file:	access:public
TEXTURE_LOADER_H	include/gfx/TextureLoader.h	2;"	d
TILE_H	include/level/Tile.h	2;"	d
TPS	include/Standard.h	14;"	d
TYPE_ENTITY	GaffMaker/include/Definitions.h	/^const byte TYPE_ENTITY = 0x04;$/;"	v
TYPE_ENTITY	include/Definitions.h	/^const byte TYPE_ENTITY = 0x04;$/;"	v
TYPE_SOLID	GaffMaker/include/Definitions.h	/^const byte TYPE_SOLID = 0x02;$/;"	v
TYPE_SOLID	include/Definitions.h	/^const byte TYPE_SOLID = 0x02;$/;"	v
TYPE_TILE	GaffMaker/include/Definitions.h	/^const byte TYPE_TILE = 0x01;$/;"	v
TYPE_TILE	include/Definitions.h	/^const byte TYPE_TILE = 0x01;$/;"	v
TempBuffer	libs/imgui/imgui.cpp	/^    char                    TempBuffer[1024*3+1];               \/\/ temporary text buffer$/;"	m	struct:ImGuiState	file:	access:public
TempTextBuffer	libs/imgui/imgui.cpp	/^    ImVector<char>      TempTextBuffer;$/;"	m	struct:ImGuiTextEditState	file:	access:public
TexHeight	libs/imgui/imgui.h	/^    int                         TexHeight;$/;"	m	struct:ImFontAtlas	access:public
TexID	libs/imgui/imgui.h	/^    void*                       TexID;              \/\/ User data to refer to the texture once it has been uploaded to user's graphic systems. It ia passed back to you during rendering.$/;"	m	struct:ImFontAtlas	access:public
TexPixelsAlpha8	libs/imgui/imgui.h	/^    unsigned char*              TexPixelsAlpha8;    \/\/ 1 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight$/;"	m	struct:ImFontAtlas	access:public
TexPixelsRGBA32	libs/imgui/imgui.h	/^    unsigned int*               TexPixelsRGBA32;    \/\/ 4 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight * 4$/;"	m	struct:ImFontAtlas	access:public
TexUvMax	libs/imgui/imgui.cpp	/^    ImVec2              TexUvMax[2];$/;"	m	struct:ImGuiMouseCursorData	file:	access:public
TexUvMin	libs/imgui/imgui.cpp	/^    ImVec2              TexUvMin[2];$/;"	m	struct:ImGuiMouseCursorData	file:	access:public
TexUvWhitePixel	libs/imgui/imgui.h	/^    ImVec2                      TexUvWhitePixel;    \/\/ Texture coordinates to a white pixel (part of the TexExtraData block)$/;"	m	struct:ImFontAtlas	access:public
TexWidth	libs/imgui/imgui.h	/^    int                         TexWidth;$/;"	m	struct:ImFontAtlas	access:public
Text	libs/imgui/imgui.cpp	/^    ImVector<ImWchar>   Text;                           \/\/ edit buffer, we need to persist but can't guarantee the persistence of the user-provided buffer. so we copy into own buffer.$/;"	m	struct:ImGuiTextEditState	file:	access:public
Text	libs/imgui/imgui.cpp	/^void ImGui::Text(const char* fmt, ...)$/;"	f	class:ImGui	signature:(const char* fmt, ...)
Text	libs/imgui/imgui.h	/^    IMGUI_API void          Text(const char* fmt, ...);$/;"	p	namespace:ImGui	signature:(const char* fmt, ...)
TextColored	libs/imgui/imgui.cpp	/^void ImGui::TextColored(const ImVec4& col, const char* fmt, ...)$/;"	f	class:ImGui	signature:(const ImVec4& col, const char* fmt, ...)
TextColored	libs/imgui/imgui.h	/^    IMGUI_API void          TextColored(const ImVec4& col, const char* fmt, ...);               \/\/ shortcut for PushStyleColor(ImGuiCol_Text, col); Text(fmt, ...); PopStyleColor();$/;"	p	namespace:ImGui	signature:(const ImVec4& col, const char* fmt, ...)
TextColoredV	libs/imgui/imgui.cpp	/^void ImGui::TextColoredV(const ImVec4& col, const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const ImVec4& col, const char* fmt, va_list args)
TextColoredV	libs/imgui/imgui.h	/^    IMGUI_API void          TextColoredV(const ImVec4& col, const char* fmt, va_list args);$/;"	p	namespace:ImGui	signature:(const ImVec4& col, const char* fmt, va_list args)
TextDisabled	libs/imgui/imgui.cpp	/^void ImGui::TextDisabled(const char* fmt, ...)$/;"	f	class:ImGui	signature:(const char* fmt, ...)
TextDisabled	libs/imgui/imgui.h	/^    IMGUI_API void          TextDisabled(const char* fmt, ...);                                 \/\/ shortcut for PushStyleColor(ImGuiCol_Text, style.Colors[ImGuiCol_TextDisabled]); Text(fmt, ...); PopStyleColor();$/;"	p	namespace:ImGui	signature:(const char* fmt, ...)
TextDisabledV	libs/imgui/imgui.cpp	/^void ImGui::TextDisabledV(const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const char* fmt, va_list args)
TextDisabledV	libs/imgui/imgui.h	/^    IMGUI_API void          TextDisabledV(const char* fmt, va_list args);$/;"	p	namespace:ImGui	signature:(const char* fmt, va_list args)
TextEditCallback	libs/imgui/imgui.cpp	/^    int     TextEditCallback(ImGuiTextEditCallbackData* data)$/;"	f	struct:ExampleAppConsole	access:public	signature:(ImGuiTextEditCallbackData* data)
TextEditCallback	src/util/Console.cpp	/^	int     TextEditCallback(ImGuiTextEditCallbackData* data)$/;"	f	struct:Console::Console	access:public	signature:(ImGuiTextEditCallbackData* data)
TextEditCallbackStub	libs/imgui/imgui.cpp	/^    static int TextEditCallbackStub(ImGuiTextEditCallbackData* data) \/\/ In C++11 you are better off using lambdas for this sort of forwarding callbacks$/;"	f	struct:ExampleAppConsole	access:public	signature:(ImGuiTextEditCallbackData* data)
TextEditCallbackStub	src/util/Console.cpp	/^	static int TextEditCallbackStub(ImGuiTextEditCallbackData* data) \/\/ In C++11 you are better off using lambdas for this sort of forwarding callbacks$/;"	f	struct:Console::Console	access:public	signature:(ImGuiTextEditCallbackData* data)
TextRange	libs/imgui/imgui.h	/^        TextRange() { b = e = NULL; }$/;"	f	struct:ImGuiTextFilter::TextRange	access:public	signature:()
TextRange	libs/imgui/imgui.h	/^        TextRange(const char* _b, const char* _e) { b = _b; e = _e; }$/;"	f	struct:ImGuiTextFilter::TextRange	access:public	signature:(const char* _b, const char* _e)
TextRange	libs/imgui/imgui.h	/^    struct TextRange$/;"	s	struct:ImGuiTextFilter	access:public
TextUnformatted	libs/imgui/imgui.cpp	/^void ImGui::TextUnformatted(const char* text, const char* text_end)$/;"	f	class:ImGui	signature:(const char* text, const char* text_end)
TextUnformatted	libs/imgui/imgui.h	/^    IMGUI_API void          TextUnformatted(const char* text, const char* text_end = NULL);     \/\/ doesn't require null terminated string if 'text_end' is specified. no copy done to any bounded stack buffer, recommended for long chunks of text$/;"	p	namespace:ImGui	signature:(const char* text, const char* text_end = NULL)
TextV	libs/imgui/imgui.cpp	/^void ImGui::TextV(const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const char* fmt, va_list args)
TextV	libs/imgui/imgui.h	/^    IMGUI_API void          TextV(const char* fmt, va_list args);$/;"	p	namespace:ImGui	signature:(const char* fmt, va_list args)
TextWrapPos	libs/imgui/imgui.cpp	/^    float                   TextWrapPos;            \/\/ == TextWrapPosStack.back() [empty == -1.0f]$/;"	m	struct:ImGuiDrawContext	file:	access:public
TextWrapPosStack	libs/imgui/imgui.cpp	/^    ImVector<float>         TextWrapPosStack;$/;"	m	struct:ImGuiDrawContext	file:	access:public
TextWrapped	libs/imgui/imgui.cpp	/^void ImGui::TextWrapped(const char* fmt, ...)$/;"	f	class:ImGui	signature:(const char* fmt, ...)
TextWrapped	libs/imgui/imgui.h	/^    IMGUI_API void          TextWrapped(const char* fmt, ...);                                  \/\/ shortcut for PushTextWrapPos(0.0f); Text(fmt, ...); PopTextWrapPos();. Note that this won't work on an auto-resizing window if there's no other widgets to extend the window width, yoy may need to set a size using SetNextWindowSize().$/;"	p	namespace:ImGui	signature:(const char* fmt, ...)
TextWrappedV	libs/imgui/imgui.cpp	/^void ImGui::TextWrappedV(const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const char* fmt, va_list args)
TextWrappedV	libs/imgui/imgui.h	/^    IMGUI_API void          TextWrappedV(const char* fmt, va_list args);$/;"	p	namespace:ImGui	signature:(const char* fmt, va_list args)
Texture	include/gfx/TextureLoader.h	/^namespace Texture {$/;"	n
Texture	src/gfx/TextureLoader.cpp	/^namespace Texture {$/;"	n	file:
Texture::load	include/gfx/TextureLoader.h	/^	GLuint load(std::string name);$/;"	p	namespace:Texture	signature:(std::string name)
Texture::load	src/gfx/TextureLoader.cpp	/^    GLuint load(std::string name) {$/;"	f	namespace:Texture	signature:(std::string name)
TextureId	libs/imgui/imgui.h	/^    ImTextureID     TextureId;              \/\/ User-provided texture ID. Set by user in ImfontAtlas::SetTexID() for fonts or passed to Image*() functions. Ignore if never using images or multiple fonts atlas.$/;"	m	struct:ImDrawCmd	access:public
Tile	include/level/Tile.h	/^namespace Tile {$/;"	n
Tile::create	include/level/Tile.h	/^    void create(std::string name, byte id);$/;"	p	namespace:Tile	signature:(std::string name, byte id)
Tile::create	src/level/Tile.cpp	/^void Tile::create(std::string name, byte id) {$/;"	f	class:Tile	signature:(std::string name, byte id)
Tile::render	include/level/Tile.h	/^    void render(vec4 position, byte id);$/;"	p	namespace:Tile	signature:(vec4 position, byte id)
Tile::render	src/level/Tile.cpp	/^void Tile::render(vec4 position, byte id) {$/;"	f	class:Tile	signature:(vec4 position, byte id)
Time	libs/imgui/imgui.cpp	/^    float                   Time;$/;"	m	struct:ImGuiState	file:	access:public
TitleBarHeight	libs/imgui/imgui.cpp	/^    float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }$/;"	f	struct:ImGuiWindow	access:public	signature:() const
TitleBarRect	libs/imgui/imgui.cpp	/^    ImRect      TitleBarRect() const                    { return ImRect(Pos, Pos + ImVec2(SizeFull.x, TitleBarHeight())); }$/;"	f	struct:ImGuiWindow	access:public	signature:() const
Tooltip	libs/imgui/imgui.cpp	/^    char                    Tooltip[1024];$/;"	m	struct:ImGuiState	file:	access:public
TotalIdxCount	libs/imgui/imgui.h	/^    int             TotalIdxCount;          \/\/ For convenience, sum of all cmd_lists idx_buffer.Size$/;"	m	struct:ImDrawData	access:public
TotalVtxCount	libs/imgui/imgui.h	/^    int             TotalVtxCount;          \/\/ For convenience, sum of all cmd_lists vtx_buffer.Size$/;"	m	struct:ImDrawData	access:public
TouchExtraPadding	libs/imgui/imgui.h	/^    ImVec2      TouchExtraPadding;          \/\/ Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!$/;"	m	struct:ImGuiStyle	access:public
TreeDepth	libs/imgui/imgui.cpp	/^    int                     TreeDepth;$/;"	m	struct:ImGuiDrawContext	file:	access:public
TreeNode	libs/imgui/imgui.cpp	/^bool ImGui::TreeNode(const char* str_id, const char* fmt, ...)$/;"	f	class:ImGui	signature:(const char* str_id, const char* fmt, ...)
TreeNode	libs/imgui/imgui.cpp	/^bool ImGui::TreeNode(const char* str_label_id)$/;"	f	class:ImGui	signature:(const char* str_label_id)
TreeNode	libs/imgui/imgui.cpp	/^bool ImGui::TreeNode(const void* ptr_id, const char* fmt, ...)$/;"	f	class:ImGui	signature:(const void* ptr_id, const char* fmt, ...)
TreeNode	libs/imgui/imgui.h	/^    IMGUI_API bool          TreeNode(const char* str_id, const char* fmt, ...);                 \/\/ "$/;"	p	namespace:ImGui	signature:(const char* str_id, const char* fmt, ...)
TreeNode	libs/imgui/imgui.h	/^    IMGUI_API bool          TreeNode(const char* str_label_id);                                 \/\/ if returning 'true' the node is open and the user is responsible for calling TreePop$/;"	p	namespace:ImGui	signature:(const char* str_label_id)
TreeNode	libs/imgui/imgui.h	/^    IMGUI_API bool          TreeNode(const void* ptr_id, const char* fmt, ...);                 \/\/ "$/;"	p	namespace:ImGui	signature:(const void* ptr_id, const char* fmt, ...)
TreeNodeV	libs/imgui/imgui.cpp	/^bool ImGui::TreeNodeV(const char* str_id, const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const char* str_id, const char* fmt, va_list args)
TreeNodeV	libs/imgui/imgui.cpp	/^bool ImGui::TreeNodeV(const void* ptr_id, const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const void* ptr_id, const char* fmt, va_list args)
TreeNodeV	libs/imgui/imgui.h	/^    IMGUI_API bool          TreeNodeV(const char* str_id, const char* fmt, va_list args);       \/\/ "$/;"	p	namespace:ImGui	signature:(const char* str_id, const char* fmt, va_list args)
TreeNodeV	libs/imgui/imgui.h	/^    IMGUI_API bool          TreeNodeV(const void* ptr_id, const char* fmt, va_list args);       \/\/ "$/;"	p	namespace:ImGui	signature:(const void* ptr_id, const char* fmt, va_list args)
TreePop	libs/imgui/imgui.cpp	/^void ImGui::TreePop()$/;"	f	class:ImGui	signature:()
TreePop	libs/imgui/imgui.h	/^    IMGUI_API void          TreePop();$/;"	p	namespace:ImGui	signature:()
TreePush	libs/imgui/imgui.cpp	/^void ImGui::TreePush(const char* str_id)$/;"	f	class:ImGui	signature:(const char* str_id)
TreePush	libs/imgui/imgui.cpp	/^void ImGui::TreePush(const void* ptr_id)$/;"	f	class:ImGui	signature:(const void* ptr_id)
TreePush	libs/imgui/imgui.h	/^    IMGUI_API void          TreePush(const char* str_id = NULL);                                \/\/ already called by TreeNode(), but you can call Push\/Pop yourself for layouting purpose$/;"	p	namespace:ImGui	signature:(const char* str_id = NULL)
TreePush	libs/imgui/imgui.h	/^    IMGUI_API void          TreePush(const void* ptr_id = NULL);                                \/\/ "$/;"	p	namespace:ImGui	signature:(const void* ptr_id = NULL)
Type	libs/imgui/imgui.cpp	/^    ImGuiMouseCursor    Type;$/;"	m	struct:ImGuiMouseCursorData	file:	access:public
U0	libs/imgui/imgui.h	/^        float                   U0, V0, U1, V1;     \/\/ Texture coordinates$/;"	m	struct:ImFont::Glyph	access:public
U1	libs/imgui/imgui.h	/^        float                   U0, V0, U1, V1;     \/\/ Texture coordinates$/;"	m	struct:ImFont::Glyph	access:public
UP	include/Input.h	/^    const int UP = GLFW_KEY_W;$/;"	m	namespace:Key
Unindent	libs/imgui/imgui.cpp	/^void ImGui::Unindent()$/;"	f	class:ImGui	signature:()
Unindent	libs/imgui/imgui.h	/^    IMGUI_API void          Unindent();                                                         \/\/ move content position back to the left (cancel Indent)$/;"	p	namespace:ImGui	signature:()
Update	libs/imgui/imgui.cpp	/^    void Update(int count, float spacing, bool clear)$/;"	f	struct:ImGuiSimpleColumns	access:public	signature:(int count, float spacing, bool clear)
UpdateClipRect	libs/imgui/imgui.cpp	/^void ImDrawList::UpdateClipRect()$/;"	f	class:ImDrawList	signature:()
UpdateClipRect	libs/imgui/imgui.h	/^    IMGUI_API void  UpdateClipRect();$/;"	p	struct:ImDrawList	access:public	signature:()
UpdateTextureID	libs/imgui/imgui.cpp	/^void ImDrawList::UpdateTextureID()$/;"	f	class:ImDrawList	signature:()
UpdateTextureID	libs/imgui/imgui.h	/^    IMGUI_API void  UpdateTextureID();$/;"	p	struct:ImDrawList	access:public	signature:()
UserCallback	libs/imgui/imgui.h	/^    ImDrawCallback  UserCallback;           \/\/ If != NULL, call the function instead of rendering the vertices. clip_rect and texture_id will be set normally.$/;"	m	struct:ImDrawCmd	access:public
UserCallbackData	libs/imgui/imgui.h	/^    void*           UserCallbackData;       \/\/ The draw callback code can access this.$/;"	m	struct:ImDrawCmd	access:public
UserData	libs/imgui/imgui.h	/^    void*               UserData;       \/\/ What user passed to InputText()      \/\/ Read-only$/;"	m	struct:ImGuiTextEditCallbackData	access:public
UserData	libs/imgui/imgui.h	/^    void*         UserData;                 \/\/ = NULL               \/\/ Store your own data for retrieval by callbacks.$/;"	m	struct:ImGuiIO	access:public
V0	libs/imgui/imgui.h	/^        float                   U0, V0, U1, V1;     \/\/ Texture coordinates$/;"	m	struct:ImFont::Glyph	access:public
V1	libs/imgui/imgui.h	/^        float                   U0, V0, U1, V1;     \/\/ Texture coordinates$/;"	m	struct:ImFont::Glyph	access:public
VERSION	GaffMaker/include/Definitions.h	/^	static const byte VERSION = 0x01;$/;"	m	class:Gaff	access:public
VERSION	include/Definitions.h	/^	static const byte VERSION = 0x01;$/;"	m	class:Gaff	access:public
VSliderFloat	libs/imgui/imgui.cpp	/^bool ImGui::VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* display_format, float power)
VSliderFloat	libs/imgui/imgui.h	/^    IMGUI_API bool          VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);$/;"	p	namespace:ImGui	signature:(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* display_format = Ó, float power = 1.0f)
VSliderInt	libs/imgui/imgui.cpp	/^bool ImGui::VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* display_format)
VSliderInt	libs/imgui/imgui.h	/^    IMGUI_API bool          VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* display_format = "%.0f");$/;"	p	namespace:ImGui	signature:(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* display_format = Ó)
VT	include/Game.h	/^const float VT = 60.0f\/TPS;$/;"	v
Value	libs/imgui/imgui.cpp	/^void ImGui::Value(const char* prefix, bool b)$/;"	f	class:ImGui	signature:(const char* prefix, bool b)
Value	libs/imgui/imgui.cpp	/^void ImGui::Value(const char* prefix, float v, const char* float_format)$/;"	f	class:ImGui	signature:(const char* prefix, float v, const char* float_format)
Value	libs/imgui/imgui.cpp	/^void ImGui::Value(const char* prefix, int v)$/;"	f	class:ImGui	signature:(const char* prefix, int v)
Value	libs/imgui/imgui.cpp	/^void ImGui::Value(const char* prefix, unsigned int v)$/;"	f	class:ImGui	signature:(const char* prefix, unsigned int v)
Value	libs/imgui/imgui.h	/^    IMGUI_API void          Value(const char* prefix, bool b);$/;"	p	namespace:ImGui	signature:(const char* prefix, bool b)
Value	libs/imgui/imgui.h	/^    IMGUI_API void          Value(const char* prefix, float v, const char* float_format = NULL);$/;"	p	namespace:ImGui	signature:(const char* prefix, float v, const char* float_format = NULL)
Value	libs/imgui/imgui.h	/^    IMGUI_API void          Value(const char* prefix, int v);$/;"	p	namespace:ImGui	signature:(const char* prefix, int v)
Value	libs/imgui/imgui.h	/^    IMGUI_API void          Value(const char* prefix, unsigned int v);$/;"	p	namespace:ImGui	signature:(const char* prefix, unsigned int v)
Value	libs/imgui/imgui.h	/^    ImVec4              Value;$/;"	m	struct:ImColor	access:public
Values	libs/imgui/imgui.cpp	/^    const float* Values;$/;"	m	struct:ImGuiPlotArrayGetterData	file:	access:public
Var	libs/imgui/imgui.cpp	/^    ImGuiStyleVar Var;$/;"	m	struct:ImGuiStyleMod	file:	access:public
VertexArrayID	src/gfx/Render.cpp	/^    GLuint VertexArrayID;$/;"	m	namespace:Render	file:
VtxBuffer	libs/imgui/imgui.h	/^    ImVector<ImDrawVert>    VtxBuffer;          \/\/ Vertex buffer.$/;"	m	struct:ImDrawList	access:public
WARNING	include/util/Log.h	/^const int WARNING = 0x03;$/;"	v
WIDTH	include/Window.h	/^const int WIDTH = 608;$/;"	v
WIN32_LEAN_AND_MEAN	libs/imgui/imgui.cpp	10993;"	d	file:
WIN32_LEAN_AND_MEAN	libs/imgui/imgui.cpp	11069;"	d	file:
WINDOW_H	include/Window.h	2;"	d
WRITER_H	GaffMaker/include/Writer.h	2;"	d
WantCaptureKeyboard	libs/imgui/imgui.h	/^    bool        WantCaptureKeyboard;        \/\/ Widget is active (= ImGui will use your keyboard input)$/;"	m	struct:ImGuiIO	access:public
WantCaptureMouse	libs/imgui/imgui.h	/^    bool        WantCaptureMouse;           \/\/ Mouse is hovering a window or widget is active (= ImGui will use your mouse input)$/;"	m	struct:ImGuiIO	access:public
WasActive	libs/imgui/imgui.cpp	/^    bool                    WasActive;$/;"	m	struct:ImGuiWindow	file:	access:public
Width	libs/imgui/imgui.cpp	/^    float  Width, NextWidth;$/;"	m	struct:ImGuiSimpleColumns	file:	access:public
Window	include/Window.h	/^namespace Window {$/;"	n
Window	libs/imgui/imgui.cpp	/^    ImGuiWindow*        Window;         \/\/ Resolved on BeginPopup() - may stay unresolved if user never calls OpenPopup()$/;"	m	struct:ImGuiPopupRef	file:	access:public
Window	src/Window.cpp	/^namespace Window {$/;"	n	file:
Window	src/legacy/Window.cpp	/^namespace Window {$/;"	n	file:
Window::create	include/Window.h	/^    void create();$/;"	p	namespace:Window	signature:()
Window::create	src/Window.cpp	/^    void create() {$/;"	f	namespace:Window	signature:()
Window::create	src/legacy/Window.cpp	/^    void create() {$/;"	f	namespace:Window	signature:()
Window::destroy	include/Window.h	/^    void destroy();$/;"	p	namespace:Window	signature:()
Window::destroy	src/Window.cpp	/^    void destroy() {$/;"	f	namespace:Window	signature:()
Window::destroy	src/legacy/Window.cpp	/^    void destroy() {$/;"	f	namespace:Window	signature:()
Window::poll	include/Window.h	/^    void poll();$/;"	p	namespace:Window	signature:()
Window::poll	src/Window.cpp	/^    void poll() {$/;"	f	namespace:Window	signature:()
Window::poll	src/legacy/Window.cpp	/^    void poll() {$/;"	f	namespace:Window	signature:()
Window::shouldClose	include/Window.h	/^    bool shouldClose();$/;"	p	namespace:Window	signature:()
Window::shouldClose	src/Window.cpp	/^    bool shouldClose() {$/;"	f	namespace:Window	signature:()
Window::shouldClose	src/legacy/Window.cpp	/^    bool shouldClose() {$/;"	f	namespace:Window	signature:()
Window::swap	include/Window.h	/^    void swap();$/;"	p	namespace:Window	signature:()
Window::swap	src/Window.cpp	/^    void swap() {$/;"	f	namespace:Window	signature:()
Window::swap	src/legacy/Window.cpp	/^    void swap() {$/;"	f	namespace:Window	signature:()
Window::terminate	include/Window.h	/^    void terminate();$/;"	p	namespace:Window	signature:()
Window::terminate	src/Window.cpp	/^    void terminate() {$/;"	f	namespace:Window	signature:()
Window::terminate	src/legacy/Window.cpp	/^    void terminate() {$/;"	f	namespace:Window	signature:()
Window::tweakBarInit	src/legacy/Window.cpp	/^    void tweakBarInit() {$/;"	f	namespace:Window	signature:()
Window::tweakBarInit	src/legacy/Window.cpp	/^    void tweakBarInit();$/;"	p	namespace:Window	file:	signature:()
Window::window	src/Window.cpp	/^    GLFWwindow* window;$/;"	m	namespace:Window	file:
Window::window	src/legacy/Window.cpp	/^    GLFWwindow* window;$/;"	m	namespace:Window	file:
WindowFillAlphaDefault	libs/imgui/imgui.h	/^    float       WindowFillAlphaDefault;     \/\/ Default alpha of window background, if not specified in ImGui::Begin()$/;"	m	struct:ImGuiStyle	access:public
WindowMinSize	libs/imgui/imgui.h	/^    ImVec2      WindowMinSize;              \/\/ Minimum window size$/;"	m	struct:ImGuiStyle	access:public
WindowPadding	libs/imgui/imgui.cpp	/^    ImVec2                  WindowPadding;                      \/\/ Window padding at the time of begin. We need to lock it, in particular manipulation of the ShowBorder would have an effect$/;"	m	struct:ImGuiWindow	file:	access:public
WindowPadding	libs/imgui/imgui.h	/^    ImVec2      WindowPadding;              \/\/ Padding within a window$/;"	m	struct:ImGuiStyle	access:public
WindowRounding	libs/imgui/imgui.h	/^    float       WindowRounding;             \/\/ Radius of window corners rounding. Set to 0.0f to have rectangular windows$/;"	m	struct:ImGuiStyle	access:public
WindowTitleAlign	libs/imgui/imgui.h	/^    ImGuiAlign  WindowTitleAlign;           \/\/ Alignment for title bar text$/;"	m	struct:ImGuiStyle	access:public
Windows	libs/imgui/imgui.cpp	/^    ImVector<ImGuiWindow*>  Windows;$/;"	m	struct:ImGuiState	file:	access:public
WindowsSortBuffer	libs/imgui/imgui.cpp	/^    ImVector<ImGuiWindow*>  WindowsSortBuffer;$/;"	m	struct:ImGuiState	file:	access:public
X0	libs/imgui/imgui.h	/^        float                   X0, Y0, X1, Y1;$/;"	m	struct:ImFont::Glyph	access:public
X1	libs/imgui/imgui.h	/^        float                   X0, Y0, X1, Y1;$/;"	m	struct:ImFont::Glyph	access:public
XAdvance	libs/imgui/imgui.h	/^        float                   XAdvance;$/;"	m	struct:ImFont::Glyph	access:public
Y0	libs/imgui/imgui.h	/^        float                   X0, Y0, X1, Y1;$/;"	m	struct:ImFont::Glyph	access:public
Y1	libs/imgui/imgui.h	/^        float                   X0, Y0, X1, Y1;$/;"	m	struct:ImFont::Glyph	access:public
_CRT_SECURE_NO_WARNINGS	libs/imgui/imgui.cpp	467;"	d	file:
_ChannelCurrent	libs/imgui/imgui.h	/^    int                     _ChannelCurrent;    \/\/ [Internal] current channel number (0)$/;"	m	struct:ImDrawList	access:public
_Channels	libs/imgui/imgui.h	/^    ImVector<ImDrawChannel> _Channels;          \/\/ [Internal] draw channels for columns API$/;"	m	struct:ImDrawList	access:public
_ClipRectStack	libs/imgui/imgui.h	/^    ImVector<ImVec4>        _ClipRectStack;     \/\/ [Internal]$/;"	m	struct:ImDrawList	access:public
_IdxWritePtr	libs/imgui/imgui.h	/^    ImDrawIdx*              _IdxWritePtr;       \/\/ [Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)$/;"	m	struct:ImDrawList	access:public
_OwnerName	libs/imgui/imgui.h	/^    const char*             _OwnerName;         \/\/ Pointer to owner window's name (if any) for debugging$/;"	m	struct:ImDrawList	access:public
_Path	libs/imgui/imgui.h	/^    ImVector<ImVec2>        _Path;				\/\/ [Internal] current path building$/;"	m	struct:ImDrawList	access:public
_TextureIdStack	libs/imgui/imgui.h	/^    ImVector<ImTextureID>   _TextureIdStack;    \/\/ [Internal] $/;"	m	struct:ImDrawList	access:public
_VtxCurrentIdx	libs/imgui/imgui.h	/^    unsigned int            _VtxCurrentIdx;     \/\/ [Internal] == VtxBuffer.Size$/;"	m	struct:ImDrawList	access:public
_VtxWritePtr	libs/imgui/imgui.h	/^    ImDrawVert*             _VtxWritePtr;       \/\/ [Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)$/;"	m	struct:ImDrawList	access:public
__STB_INCLUDE_STB_TRUETYPE_H__	libs/imgui/stb_truetype.h	435;"	d
__anon10::array_of_unicode_codepoints	libs/imgui/stb_truetype.h	/^   int *array_of_unicode_codepoints;       \/\/ if non-zero, then this is an array of unicode codepoints$/;"	m	struct:__anon10	access:public
__anon10::chardata_for_range	libs/imgui/stb_truetype.h	/^   stbtt_packedchar *chardata_for_range; \/\/ output$/;"	m	struct:__anon10	access:public
__anon10::first_unicode_codepoint_in_range	libs/imgui/stb_truetype.h	/^   int first_unicode_codepoint_in_range;  \/\/ if non-zero, then the chars are continuous, and this is the first codepoint$/;"	m	struct:__anon10	access:public
__anon10::font_size	libs/imgui/stb_truetype.h	/^   float font_size;$/;"	m	struct:__anon10	access:public
__anon10::h_oversample	libs/imgui/stb_truetype.h	/^   unsigned char h_oversample, v_oversample; \/\/ don't set these, they're used internally$/;"	m	struct:__anon10	access:public
__anon10::num_chars	libs/imgui/stb_truetype.h	/^   int num_chars;$/;"	m	struct:__anon10	access:public
__anon10::v_oversample	libs/imgui/stb_truetype.h	/^   unsigned char h_oversample, v_oversample; \/\/ don't set these, they're used internally$/;"	m	struct:__anon10	access:public
__anon12::cx	libs/imgui/stb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy;$/;"	m	struct:__anon12	access:public
__anon12::cy	libs/imgui/stb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy;$/;"	m	struct:__anon12	access:public
__anon12::padding	libs/imgui/stb_truetype.h	/^      unsigned char type,padding;$/;"	m	struct:__anon12	access:public
__anon12::type	libs/imgui/stb_truetype.h	/^      unsigned char type,padding;$/;"	m	struct:__anon12	access:public
__anon12::x	libs/imgui/stb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy;$/;"	m	struct:__anon12	access:public
__anon12::y	libs/imgui/stb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy;$/;"	m	struct:__anon12	access:public
__anon13::h	libs/imgui/stb_truetype.h	/^   int w,h,stride;$/;"	m	struct:__anon13	access:public
__anon13::pixels	libs/imgui/stb_truetype.h	/^   unsigned char *pixels;$/;"	m	struct:__anon13	access:public
__anon13::stride	libs/imgui/stb_truetype.h	/^   int w,h,stride;$/;"	m	struct:__anon13	access:public
__anon13::w	libs/imgui/stb_truetype.h	/^   int w,h,stride;$/;"	m	struct:__anon13	access:public
__anon20::x	libs/imgui/stb_truetype.h	/^   float x,y;$/;"	m	struct:__anon20	access:public
__anon20::y	libs/imgui/stb_truetype.h	/^   float x,y;$/;"	m	struct:__anon20	access:public
__anon21::bottom_y	libs/imgui/stb_truetype.h	/^   int x,y,bottom_y;$/;"	m	struct:__anon21	access:public
__anon21::height	libs/imgui/stb_truetype.h	/^   int width,height;$/;"	m	struct:__anon21	access:public
__anon21::width	libs/imgui/stb_truetype.h	/^   int width,height;$/;"	m	struct:__anon21	access:public
__anon21::x	libs/imgui/stb_truetype.h	/^   int x,y,bottom_y;$/;"	m	struct:__anon21	access:public
__anon21::y	libs/imgui/stb_truetype.h	/^   int x,y,bottom_y;$/;"	m	struct:__anon21	access:public
__anon22::x	libs/imgui/stb_truetype.h	/^   unsigned char x;$/;"	m	struct:__anon22	access:public
__anon25::prev_link	libs/imgui/stb_rect_pack.h	/^   stbrp_node **prev_link;$/;"	m	struct:__anon25	access:public
__anon25::x	libs/imgui/stb_rect_pack.h	/^   int x,y;$/;"	m	struct:__anon25	access:public
__anon25::y	libs/imgui/stb_rect_pack.h	/^   int x,y;$/;"	m	struct:__anon25	access:public
__anon2::char_storage	libs/imgui/stb_textedit.h	/^   short           char_storage;$/;"	m	struct:__anon2	access:public
__anon2::delete_length	libs/imgui/stb_textedit.h	/^   short           delete_length;$/;"	m	struct:__anon2	access:public
__anon2::insert_length	libs/imgui/stb_textedit.h	/^   short           insert_length;$/;"	m	struct:__anon2	access:public
__anon2::where	libs/imgui/stb_textedit.h	/^   STB_TEXTEDIT_POSITIONTYPE  where;$/;"	m	struct:__anon2	access:public
__anon3::redo_char_point	libs/imgui/stb_textedit.h	/^   short undo_char_point, redo_char_point;$/;"	m	struct:__anon3	access:public
__anon3::redo_point	libs/imgui/stb_textedit.h	/^   short undo_point, redo_point;$/;"	m	struct:__anon3	access:public
__anon3::undo_char	libs/imgui/stb_textedit.h	/^   STB_TEXTEDIT_CHARTYPE  undo_char[STB_TEXTEDIT_UNDOCHARCOUNT];$/;"	m	struct:__anon3	access:public
__anon3::undo_char_point	libs/imgui/stb_textedit.h	/^   short undo_char_point, redo_char_point;$/;"	m	struct:__anon3	access:public
__anon3::undo_point	libs/imgui/stb_textedit.h	/^   short undo_point, redo_point;$/;"	m	struct:__anon3	access:public
__anon3::undo_rec	libs/imgui/stb_textedit.h	/^   StbUndoRecord          undo_rec [STB_TEXTEDIT_UNDOSTATECOUNT];$/;"	m	struct:__anon3	access:public
__anon4::cursor	libs/imgui/stb_textedit.h	/^   int cursor;$/;"	m	struct:__anon4	access:public
__anon4::cursor_at_end_of_line	libs/imgui/stb_textedit.h	/^   unsigned char cursor_at_end_of_line; \/\/ not implemented yet$/;"	m	struct:__anon4	access:public
__anon4::has_preferred_x	libs/imgui/stb_textedit.h	/^   unsigned char has_preferred_x;$/;"	m	struct:__anon4	access:public
__anon4::initialized	libs/imgui/stb_textedit.h	/^   unsigned char initialized;$/;"	m	struct:__anon4	access:public
__anon4::insert_mode	libs/imgui/stb_textedit.h	/^   unsigned char insert_mode;$/;"	m	struct:__anon4	access:public
__anon4::padding1	libs/imgui/stb_textedit.h	/^   unsigned char padding1, padding2, padding3;$/;"	m	struct:__anon4	access:public
__anon4::padding2	libs/imgui/stb_textedit.h	/^   unsigned char padding1, padding2, padding3;$/;"	m	struct:__anon4	access:public
__anon4::padding3	libs/imgui/stb_textedit.h	/^   unsigned char padding1, padding2, padding3;$/;"	m	struct:__anon4	access:public
__anon4::preferred_x	libs/imgui/stb_textedit.h	/^   float preferred_x; \/\/ this determines where the cursor up\/down tries to seek to along x$/;"	m	struct:__anon4	access:public
__anon4::select_end	libs/imgui/stb_textedit.h	/^   int select_end;$/;"	m	struct:__anon4	access:public
__anon4::select_start	libs/imgui/stb_textedit.h	/^   int select_start;          \/\/ selection start point$/;"	m	struct:__anon4	access:public
__anon4::single_line	libs/imgui/stb_textedit.h	/^   unsigned char single_line;$/;"	m	struct:__anon4	access:public
__anon4::undostate	libs/imgui/stb_textedit.h	/^   StbUndoState undostate;$/;"	m	struct:__anon4	access:public
__anon5::baseline_y_delta	libs/imgui/stb_textedit.h	/^   float baseline_y_delta;  \/\/ position of baseline relative to previous row's baseline$/;"	m	struct:__anon5	access:public
__anon5::num_chars	libs/imgui/stb_textedit.h	/^   int num_chars;$/;"	m	struct:__anon5	access:public
__anon5::x0	libs/imgui/stb_textedit.h	/^   float x0,x1;             \/\/ starting x location, end x location (allows for align=right, etc)$/;"	m	struct:__anon5	access:public
__anon5::x1	libs/imgui/stb_textedit.h	/^   float x0,x1;             \/\/ starting x location, end x location (allows for align=right, etc)$/;"	m	struct:__anon5	access:public
__anon5::ymax	libs/imgui/stb_textedit.h	/^   float ymin,ymax;         \/\/ height of row above and below baseline$/;"	m	struct:__anon5	access:public
__anon5::ymin	libs/imgui/stb_textedit.h	/^   float ymin,ymax;         \/\/ height of row above and below baseline$/;"	m	struct:__anon5	access:public
__anon6::first_char	libs/imgui/stb_textedit.h	/^   int first_char, length; \/\/ first char of row, and length$/;"	m	struct:__anon6	access:public
__anon6::height	libs/imgui/stb_textedit.h	/^   float height; \/\/ height of line$/;"	m	struct:__anon6	access:public
__anon6::length	libs/imgui/stb_textedit.h	/^   int first_char, length; \/\/ first char of row, and length$/;"	m	struct:__anon6	access:public
__anon6::prev_first	libs/imgui/stb_textedit.h	/^   int prev_first;  \/\/ first char of previous row$/;"	m	struct:__anon6	access:public
__anon6::x	libs/imgui/stb_textedit.h	/^   float x,y;    \/\/ position of n'th character$/;"	m	struct:__anon6	access:public
__anon6::y	libs/imgui/stb_textedit.h	/^   float x,y;    \/\/ position of n'th character$/;"	m	struct:__anon6	access:public
__anon7::x0	libs/imgui/stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon7	access:public
__anon7::x1	libs/imgui/stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon7	access:public
__anon7::xadvance	libs/imgui/stb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon7	access:public
__anon7::xoff	libs/imgui/stb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon7	access:public
__anon7::y0	libs/imgui/stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon7	access:public
__anon7::y1	libs/imgui/stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon7	access:public
__anon7::yoff	libs/imgui/stb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon7	access:public
__anon8::s0	libs/imgui/stb_truetype.h	/^   float x0,y0,s0,t0; \/\/ top-left$/;"	m	struct:__anon8	access:public
__anon8::s1	libs/imgui/stb_truetype.h	/^   float x1,y1,s1,t1; \/\/ bottom-right$/;"	m	struct:__anon8	access:public
__anon8::t0	libs/imgui/stb_truetype.h	/^   float x0,y0,s0,t0; \/\/ top-left$/;"	m	struct:__anon8	access:public
__anon8::t1	libs/imgui/stb_truetype.h	/^   float x1,y1,s1,t1; \/\/ bottom-right$/;"	m	struct:__anon8	access:public
__anon8::x0	libs/imgui/stb_truetype.h	/^   float x0,y0,s0,t0; \/\/ top-left$/;"	m	struct:__anon8	access:public
__anon8::x1	libs/imgui/stb_truetype.h	/^   float x1,y1,s1,t1; \/\/ bottom-right$/;"	m	struct:__anon8	access:public
__anon8::y0	libs/imgui/stb_truetype.h	/^   float x0,y0,s0,t0; \/\/ top-left$/;"	m	struct:__anon8	access:public
__anon8::y1	libs/imgui/stb_truetype.h	/^   float x1,y1,s1,t1; \/\/ bottom-right$/;"	m	struct:__anon8	access:public
__anon9::x0	libs/imgui/stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon9	access:public
__anon9::x1	libs/imgui/stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon9	access:public
__anon9::xadvance	libs/imgui/stb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon9	access:public
__anon9::xoff	libs/imgui/stb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon9	access:public
__anon9::xoff2	libs/imgui/stb_truetype.h	/^   float xoff2,yoff2;$/;"	m	struct:__anon9	access:public
__anon9::y0	libs/imgui/stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon9	access:public
__anon9::y1	libs/imgui/stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon9	access:public
__anon9::yoff	libs/imgui/stb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon9	access:public
__anon9::yoff2	libs/imgui/stb_truetype.h	/^   float xoff2,yoff2;$/;"	m	struct:__anon9	access:public
_grow_capacity	libs/imgui/imgui.h	/^    inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity\/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }$/;"	f	class:ImVector	access:public	signature:(int new_size)
acceleration	src/entities/Entity.cpp	/^const float acceleration = (10.0f\/16) \/ (1 \/ (1 - frictionFloat)) * VT;$/;"	v
active_head	libs/imgui/stb_rect_pack.h	/^   stbrp_node *active_head;$/;"	m	struct:stbrp_context	access:public
actualFPS	src/Game.cpp	/^    int actualFPS = 0;$/;"	m	namespace:Game	file:
actualTPS	src/Game.cpp	/^    int actualTPS = 0;$/;"	m	namespace:Game	file:
align	libs/imgui/stb_rect_pack.h	/^   int align;$/;"	m	struct:stbrp_context	access:public
append	libs/imgui/imgui.cpp	/^void ImGuiTextBuffer::append(const char* fmt, ...)$/;"	f	class:ImGuiTextBuffer	signature:(const char* fmt, ...)
append	libs/imgui/imgui.h	/^    IMGUI_API void      append(const char* fmt, ...);$/;"	p	struct:ImGuiTextBuffer	access:public	signature:(const char* fmt, ...)
appendv	libs/imgui/imgui.cpp	/^void ImGuiTextBuffer::appendv(const char* fmt, va_list args)$/;"	f	class:ImGuiTextBuffer	signature:(const char* fmt, va_list args)
appendv	libs/imgui/imgui.h	/^    IMGUI_API void      appendv(const char* fmt, va_list args);$/;"	p	struct:ImGuiTextBuffer	access:public	signature:(const char* fmt, va_list args)
array_of_unicode_codepoints	libs/imgui/stb_truetype.h	/^   int *array_of_unicode_codepoints;       \/\/ if non-zero, then this is an array of unicode codepoints$/;"	m	struct:__anon10	access:public
avgFT	src/Game.cpp	/^    float avgFT = 0;$/;"	m	namespace:Game	file:
b	GaffMaker/include/Definitions.h	/^    byte b[2] = {0x00};$/;"	m	union:byteShort	access:public
b	GaffMaker/include/Definitions.h	/^    byte b[4] = {0x00};$/;"	m	union:byteInt	access:public
b	include/Definitions.h	/^    byte b[2] = {0x00};$/;"	m	union:byteShort	access:public
b	include/Definitions.h	/^    byte b[4] = {0x00};$/;"	m	union:byteInt	access:public
b	libs/imgui/imgui.h	/^        const char* b;$/;"	m	struct:ImGuiTextFilter::TextRange	access:public
back	libs/imgui/imgui.h	/^    inline const value_type&    back() const                    { IM_ASSERT(Size > 0); return Data[Size-1]; }$/;"	f	class:ImVector	access:public	signature:() const
back	libs/imgui/imgui.h	/^    inline value_type&          back()                          { IM_ASSERT(Size > 0); return Data[Size-1]; }$/;"	f	class:ImVector	access:public	signature:()
baseline_y_delta	libs/imgui/stb_textedit.h	/^   float baseline_y_delta;  \/\/ position of baseline relative to previous row's baseline$/;"	m	struct:__anon5	access:public
begin	libs/imgui/imgui.h	/^        const char* begin() const { return b; }$/;"	f	struct:ImGuiTextFilter::TextRange	access:public	signature:() const
begin	libs/imgui/imgui.h	/^    const char*         begin() const { return &Buf.front(); }$/;"	f	struct:ImGuiTextBuffer	access:public	signature:() const
begin	libs/imgui/imgui.h	/^    inline const_iterator       begin() const                   { return Data; }$/;"	f	class:ImVector	access:public	signature:() const
begin	libs/imgui/imgui.h	/^    inline iterator             begin()                         { return Data; }$/;"	f	class:ImVector	access:public	signature:()
bottom_y	libs/imgui/stb_truetype.h	/^   int x,y,bottom_y;$/;"	m	struct:__anon21	access:public
byte	GaffMaker/include/Definitions.h	/^typedef unsigned char byte;$/;"	t
byte	include/Definitions.h	/^typedef unsigned char byte;$/;"	t
byteInt	GaffMaker/include/Definitions.h	/^union byteInt {$/;"	u
byteInt	include/Definitions.h	/^union byteInt {$/;"	u
byteInt::b	GaffMaker/include/Definitions.h	/^    byte b[4] = {0x00};$/;"	m	union:byteInt	access:public
byteInt::b	include/Definitions.h	/^    byte b[4] = {0x00};$/;"	m	union:byteInt	access:public
byteInt::i	GaffMaker/include/Definitions.h	/^    uint i;$/;"	m	union:byteInt	access:public
byteInt::i	include/Definitions.h	/^    uint i;$/;"	m	union:byteInt	access:public
byteShort	GaffMaker/include/Definitions.h	/^union byteShort {$/;"	u
byteShort	include/Definitions.h	/^union byteShort {$/;"	u
byteShort::b	GaffMaker/include/Definitions.h	/^    byte b[2] = {0x00};$/;"	m	union:byteShort	access:public
byteShort::b	include/Definitions.h	/^    byte b[2] = {0x00};$/;"	m	union:byteShort	access:public
byteShort::s	GaffMaker/include/Definitions.h	/^    unsigned short s;$/;"	m	union:byteShort	access:public
byteShort::s	include/Definitions.h	/^    unsigned short s;$/;"	m	union:byteShort	access:public
capacity	libs/imgui/imgui.h	/^    inline int                  capacity() const                { return Capacity; }$/;"	f	class:ImVector	access:public	signature:() const
cdata	libs/imgui/stb_truetype.h	/^stbtt_bakedchar cdata[96]; \/\/ ASCII 32..126 is 95 glyphs$/;"	v
charCount	src/gfx/Font.cpp	/^    const int charCount = chars.length();$/;"	m	namespace:Font	file:
charWidth	src/gfx/Font.cpp	/^    const float charWidth = 1.0f\/charCount;$/;"	m	namespace:Font	file:
char_storage	libs/imgui/stb_textedit.h	/^   short           char_storage;$/;"	m	struct:__anon2	access:public
chardata_for_range	libs/imgui/stb_truetype.h	/^   stbtt_packedchar *chardata_for_range; \/\/ output$/;"	m	struct:__anon10	access:public
chars	src/gfx/Font.cpp	/^    const std::string chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,:;'\\"!?$%()-=+\/*[] ";$/;"	m	namespace:Font	file:
clear	include/gfx/Render.h	/^    void clear();$/;"	p	namespace:Render	signature:()
clear	libs/imgui/imgui.h	/^    inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }$/;"	f	class:ImVector	access:public	signature:()
clear	libs/imgui/imgui.h	/^    void                clear() { Buf.clear(); Buf.push_back(0); }$/;"	f	struct:ImGuiTextBuffer	access:public	signature:()
clear	src/gfx/Render.cpp	/^    void clear() {$/;"	f	namespace:Render	signature:()
clear	src/legacy/Render.cpp	/^    void clear() {$/;"	f	namespace:Render	signature:()
col	libs/imgui/imgui.h	/^    ImU32   col;$/;"	m	struct:ImDrawVert	access:public
commandList	include/util/Command.h	/^    const std::string commandList[] = {"hello"};$/;"	m	namespace:Command
compileShader	src/gfx/ShaderLoader.cpp	/^    GLuint compileShader(std::string name, GLenum shaderType) {$/;"	f	namespace:Shader	signature:(std::string name, GLenum shaderType)
compileShader	src/gfx/ShaderLoader.cpp	/^    GLuint compileShader(std::string name, GLenum shaderType);$/;"	p	namespace:Shader	file:	signature:(std::string name, GLenum shaderType)
const_iterator	libs/imgui/imgui.h	/^    typedef const value_type*   const_iterator;$/;"	t	class:ImVector	access:public
control	src/Game.cpp	/^    void control() {$/;"	f	namespace:Game	signature:()
control	src/Game.cpp	/^    void control();$/;"	p	namespace:Game	file:	signature:()
count	include/util/Command.h	/^    const int count = sizeof(commandList)\/sizeof(std::string);$/;"	m	namespace:Command
counter	GaffMaker/src/Writer.cpp	/^int counter = 0;$/;"	v
create	include/Window.h	/^    void create();$/;"	p	namespace:Window	signature:()
create	include/level/Tile.h	/^    void create(std::string name, byte id);$/;"	p	namespace:Tile	signature:(std::string name, byte id)
create	src/Window.cpp	/^    void create() {$/;"	f	namespace:Window	signature:()
create	src/legacy/Window.cpp	/^    void create() {$/;"	f	namespace:Window	signature:()
create	src/level/Tile.cpp	/^void Tile::create(std::string name, byte id) {$/;"	f	class:Tile	signature:(std::string name, byte id)
cursor	libs/imgui/stb_textedit.h	/^   int cursor;$/;"	m	struct:__anon4	access:public
cursor_at_end_of_line	libs/imgui/stb_textedit.h	/^   unsigned char cursor_at_end_of_line; \/\/ not implemented yet$/;"	m	struct:__anon4	access:public
cx	libs/imgui/stb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy;$/;"	m	struct:__anon12	access:public
cy	libs/imgui/stb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy;$/;"	m	struct:__anon12	access:public
data	GaffMaker/include/LoadPNG.h	/^    byte *data;$/;"	m	struct:image	access:public
data	GaffMaker/src/Writer.cpp	/^    byte *data;$/;"	m	struct:fileAll	file:	access:public
data	libs/imgui/stb_truetype.h	/^   unsigned char  * data;              \/\/ pointer to .ttf file$/;"	m	struct:stbtt_fontinfo	access:public
delete_length	libs/imgui/stb_textedit.h	/^   short           delete_length;$/;"	m	struct:__anon2	access:public
destroy	include/Window.h	/^    void destroy();$/;"	p	namespace:Window	signature:()
destroy	src/Window.cpp	/^    void destroy() {$/;"	f	namespace:Window	signature:()
destroy	src/legacy/Window.cpp	/^    void destroy() {$/;"	f	namespace:Window	signature:()
direction	libs/imgui/stb_truetype.h	/^   float direction;$/;"	m	struct:stbtt__active_edge	access:public
direction	libs/imgui/stb_truetype.h	/^   int direction;$/;"	m	struct:stbtt__active_edge	access:public
dx	libs/imgui/stb_truetype.h	/^   int x,dx;$/;"	m	struct:stbtt__active_edge	access:public
e	libs/imgui/imgui.h	/^        const char* e;$/;"	m	struct:ImGuiTextFilter::TextRange	access:public
empty	libs/imgui/imgui.h	/^        bool empty() const { return b == e; }$/;"	f	struct:ImGuiTextFilter::TextRange	access:public	signature:() const
empty	libs/imgui/imgui.h	/^    bool                empty() { return size() >= 1; }$/;"	f	struct:ImGuiTextBuffer	access:public	signature:()
empty	libs/imgui/imgui.h	/^    inline bool                 empty() const                   { return Size == 0; }$/;"	f	class:ImVector	access:public	signature:() const
end	include/level/Level.h	/^    void end();$/;"	p	namespace:Level	signature:()
end	libs/imgui/imgui.h	/^        const char* end() const { return e; }$/;"	f	struct:ImGuiTextFilter::TextRange	access:public	signature:() const
end	libs/imgui/imgui.h	/^    const char*         end() const { return &Buf.back(); }      \/\/ Buf is zero-terminated, so end() will point on the zero-terminator$/;"	f	struct:ImGuiTextBuffer	access:public	signature:() const
end	libs/imgui/imgui.h	/^    inline const_iterator       end() const                     { return Data + Size; }$/;"	f	class:ImVector	access:public	signature:() const
end	libs/imgui/imgui.h	/^    inline iterator             end()                           { return Data + Size; }$/;"	f	class:ImVector	access:public	signature:()
end	src/Game.cpp	/^    void end() {$/;"	f	namespace:Game	signature:()
end	src/Game.cpp	/^    void end();$/;"	p	namespace:Game	file:	signature:()
end	src/level/Level.cpp	/^    void end() {$/;"	f	namespace:Level	signature:()
entity	src/level/Level.cpp	/^    Entity entity;$/;"	m	namespace:Level	file:
erase	libs/imgui/imgui.h	/^    inline iterator             erase(const_iterator it)        { IM_ASSERT(it >= begin() && it < end()); const ptrdiff_t off = it - begin(); memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(value_type)); Size--; return Data + off; }$/;"	f	class:ImVector	access:public	signature:(const_iterator it)
extra	GaffMaker/include/Definitions.h	/^	    byteInt extra;$/;"	m	struct:Gaff::fileInfo	access:public
extra	include/Definitions.h	/^	    byteInt extra;$/;"	m	struct:Gaff::fileInfo	access:public
extra	libs/imgui/stb_rect_pack.h	/^   stbrp_node extra[2]; \/\/ we allocate two extra nodes so optimal user-node-count is 'width' not 'width+2'$/;"	m	struct:stbrp_context	access:public
ey	libs/imgui/stb_truetype.h	/^   float ey;$/;"	m	struct:stbtt__active_edge	access:public
fdx	libs/imgui/stb_truetype.h	/^   float fx,fdx,fdy;$/;"	m	struct:stbtt__active_edge	access:public
fdy	libs/imgui/stb_truetype.h	/^   float fx,fdx,fdy;$/;"	m	struct:stbtt__active_edge	access:public
fileAll	GaffMaker/src/Writer.cpp	/^struct fileAll {$/;"	s	file:
fileAll::data	GaffMaker/src/Writer.cpp	/^    byte *data;$/;"	m	struct:fileAll	file:	access:public
fileAll::info	GaffMaker/src/Writer.cpp	/^    Gaff::fileInfo info;$/;"	m	struct:fileAll	file:	access:public
fileInfo	GaffMaker/include/Definitions.h	/^	struct fileInfo {$/;"	s	class:Gaff	access:public
fileInfo	include/Definitions.h	/^	struct fileInfo {$/;"	s	class:Gaff	access:public
files	GaffMaker/src/Writer.cpp	/^fileAll files[255];$/;"	v
files	src/io/Reader.cpp	/^	static Gaff::fileInfo files[256];$/;"	m	namespace:IO::Reader	file:
first_char	libs/imgui/stb_textedit.h	/^   int first_char, length; \/\/ first char of row, and length$/;"	m	struct:__anon6	access:public
first_free	libs/imgui/stb_truetype.h	/^   void   *first_free;$/;"	m	struct:stbtt__hheap	access:public
first_unicode_codepoint_in_range	libs/imgui/stb_truetype.h	/^   int first_unicode_codepoint_in_range;  \/\/ if non-zero, then the chars are continuous, and this is the first codepoint$/;"	m	struct:__anon10	access:public
font	include/gfx/Render.h	/^    void font(vec4 position, vec4 color, GLuint tex, int index);$/;"	p	namespace:Render	signature:(vec4 position, vec4 color, GLuint tex, int index)
font	src/gfx/Render.cpp	/^    void font(vec4 position, vec4 color, GLuint tex, int index) {$/;"	f	namespace:Render	signature:(vec4 position, vec4 color, GLuint tex, int index)
fontColor	src/gfx/Render.cpp	/^    GLuint fontColor;$/;"	m	namespace:Render	file:
fontIndex	src/gfx/Render.cpp	/^    GLuint fontIndex;$/;"	m	namespace:Render	file:
fontMatrixID	src/gfx/Render.cpp	/^    GLuint fontMatrixID;$/;"	m	namespace:Render	file:
fontProgramID	src/gfx/Render.cpp	/^    GLuint fontProgramID;$/;"	m	namespace:Render	file:
fontScaleFloat	src/gfx/Font.cpp	/^    float fontScaleFloat = 1.0f;$/;"	m	namespace:Font	file:
fontTextureHandler	src/gfx/Render.cpp	/^    GLuint fontTextureHandler;$/;"	m	namespace:Render	file:
fontUVBuffer	src/gfx/Render.cpp	/^    GLuint fontUVBuffer;$/;"	m	namespace:Render	file:
fontVertexBuffer	src/gfx/Render.cpp	/^    GLuint fontVertexBuffer;$/;"	m	namespace:Render	file:
font_size	libs/imgui/stb_truetype.h	/^   float font_size;$/;"	m	struct:__anon10	access:public
fontstart	libs/imgui/stb_truetype.h	/^   int              fontstart;         \/\/ offset of start of font$/;"	m	struct:stbtt_fontinfo	access:public
format	include/util/String.h	/^    std::string format(const char *fmt, ...);$/;"	p	namespace:String	signature:(const char *fmt, ...)
format	src/util/String.cpp	/^    std::string format(const char *fmt, ...) {$/;"	f	namespace:String	signature:(const char *fmt, ...)
fov	src/gfx/Render.cpp	/^    float fov = 90.0f;$/;"	m	namespace:Render	file:
frames	src/Game.cpp	/^    int frames = 0;$/;"	m	namespace:Game	file:
freeReader	include/io/Reader.h	/^	void freeReader();$/;"	p	namespace:IO::Reader	signature:()
freeReader	src/io/Reader.cpp	/^	void freeReader() {$/;"	f	namespace:IO::Reader	signature:()
free_head	libs/imgui/stb_rect_pack.h	/^   stbrp_node *free_head;$/;"	m	struct:stbrp_context	access:public
friction	src/entities/Entity.cpp	/^const mat4 friction = scale(mat4(IDENTITY), vec3(frictionFloat));$/;"	v
frictionFloat	src/entities/Entity.cpp	/^const float frictionFloat = pow(0.8f, VT);$/;"	v
front	libs/imgui/imgui.h	/^        char front() const { return *b; }$/;"	f	struct:ImGuiTextFilter::TextRange	access:public	signature:() const
front	libs/imgui/imgui.h	/^    inline const value_type&    front() const                   { IM_ASSERT(Size > 0); return Data[0]; }$/;"	f	class:ImVector	access:public	signature:() const
front	libs/imgui/imgui.h	/^    inline value_type&          front()                         { IM_ASSERT(Size > 0); return Data[0]; }$/;"	f	class:ImVector	access:public	signature:()
ftex	libs/imgui/stb_truetype.h	/^GLuint ftex;$/;"	v
fx	libs/imgui/stb_truetype.h	/^   float fx,fdx,fdy;$/;"	m	struct:stbtt__active_edge	access:public
g_AttribLocationColor	libs/imgui/imgui_impl_glfw_gl3.cpp	/^static int          g_AttribLocationPosition = 0, g_AttribLocationUV = 0, g_AttribLocationColor = 0;$/;"	v	file:
g_AttribLocationPosition	libs/imgui/imgui_impl_glfw_gl3.cpp	/^static int          g_AttribLocationPosition = 0, g_AttribLocationUV = 0, g_AttribLocationColor = 0;$/;"	v	file:
g_AttribLocationProjMtx	libs/imgui/imgui_impl_glfw_gl3.cpp	/^static int          g_AttribLocationTex = 0, g_AttribLocationProjMtx = 0;$/;"	v	file:
g_AttribLocationTex	libs/imgui/imgui_impl_glfw_gl3.cpp	/^static int          g_AttribLocationTex = 0, g_AttribLocationProjMtx = 0;$/;"	v	file:
g_AttribLocationUV	libs/imgui/imgui_impl_glfw_gl3.cpp	/^static int          g_AttribLocationPosition = 0, g_AttribLocationUV = 0, g_AttribLocationColor = 0;$/;"	v	file:
g_ElementsHandle	libs/imgui/imgui_impl_glfw_gl3.cpp	/^static unsigned int g_VboHandle = 0, g_VaoHandle = 0, g_ElementsHandle = 0;$/;"	v	file:
g_FontTexture	libs/imgui/imgui_impl_glfw_gl3.cpp	/^static GLuint       g_FontTexture = 0;$/;"	v	file:
g_FragHandle	libs/imgui/imgui_impl_glfw_gl3.cpp	/^static int          g_ShaderHandle = 0, g_VertHandle = 0, g_FragHandle = 0;$/;"	v	file:
g_MousePressed	libs/imgui/imgui_impl_glfw_gl3.cpp	/^static bool         g_MousePressed[3] = { false, false, false };$/;"	v	file:
g_MouseWheel	libs/imgui/imgui_impl_glfw_gl3.cpp	/^static float        g_MouseWheel = 0.0f;$/;"	v	file:
g_ShaderHandle	libs/imgui/imgui_impl_glfw_gl3.cpp	/^static int          g_ShaderHandle = 0, g_VertHandle = 0, g_FragHandle = 0;$/;"	v	file:
g_Time	libs/imgui/imgui_impl_glfw_gl3.cpp	/^static double       g_Time = 0.0f;$/;"	v	file:
g_VaoHandle	libs/imgui/imgui_impl_glfw_gl3.cpp	/^static unsigned int g_VboHandle = 0, g_VaoHandle = 0, g_ElementsHandle = 0;$/;"	v	file:
g_VboHandle	libs/imgui/imgui_impl_glfw_gl3.cpp	/^static unsigned int g_VboHandle = 0, g_VaoHandle = 0, g_ElementsHandle = 0;$/;"	v	file:
g_VertHandle	libs/imgui/imgui_impl_glfw_gl3.cpp	/^static int          g_ShaderHandle = 0, g_VertHandle = 0, g_FragHandle = 0;$/;"	v	file:
g_Window	libs/imgui/imgui_impl_glfw_gl3.cpp	/^static GLFWwindow*  g_Window = NULL;$/;"	v	file:
g_font_uv_buffer_data	src/gfx/Render.cpp	/^    static const GLfloat g_font_uv_buffer_data[] = {$/;"	m	namespace:Render	file:
g_font_vertex_buffer_data	src/gfx/Render.cpp	/^    static const GLfloat g_font_vertex_buffer_data[] = {$/;"	m	namespace:Render	file:
g_tile_uv_buffer_data	src/gfx/Render.cpp	/^    static const GLfloat g_tile_uv_buffer_data[] = {$/;"	m	namespace:Render	file:
g_tile_vertex_buffer_data	src/gfx/Render.cpp	/^    static const GLfloat g_tile_vertex_buffer_data[] = {$/;"	m	namespace:Render	file:
gameLoop	src/Game.cpp	/^    void gameLoop() {$/;"	f	namespace:Game	signature:()
gameLoop	src/Game.cpp	/^    void gameLoop();$/;"	p	namespace:Game	file:	signature:()
getConsole	src/util/Console.cpp	/^    Console* getConsole() {$/;"	f	namespace:Console	signature:()
getId	include/io/Reader.h	/^	uint getId(std::string);$/;"	p	namespace:IO::Reader	signature:(std::string)
getId	src/io/Reader.cpp	/^	uint getId(string name) {$/;"	f	namespace:IO::Reader	signature:(string name)
getImageSize	include/io/Reader.h	/^	vec2 getImageSize(int id);$/;"	p	namespace:IO::Reader	signature:(int id)
getImageSize	src/io/Reader.cpp	/^	vec2 getImageSize(int id) {$/;"	f	namespace:IO::Reader	signature:(int id)
getName	include/io/Reader.h	/^	std::string getName(uint id);$/;"	p	namespace:IO::Reader	signature:(uint id)
getName	src/io/Reader.cpp	/^	string getName(uint id) {$/;"	f	namespace:IO::Reader	signature:(uint id)
getPlayer	include/level/Level.h	/^    Entity* getPlayer();$/;"	p	namespace:Level	signature:()
getPlayer	src/level/Level.cpp	/^    Entity* getPlayer() {$/;"	f	namespace:Level	signature:()
getWithType	include/io/Reader.h	/^	void getWithType(byte type, uint *idList);$/;"	p	namespace:IO::Reader	signature:(byte type, uint *idList)
getWithType	src/io/Reader.cpp	/^	void getWithType(byte type, uint *idList) {$/;"	f	namespace:IO::Reader	signature:(byte type, uint *idList)
glyf	libs/imgui/stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo	access:public
h	libs/imgui/stb_rect_pack.h	/^   stbrp_coord    w, h;$/;"	m	struct:stbrp_rect	access:public
h	libs/imgui/stb_truetype.h	/^   int id,w,h,was_packed;$/;"	m	struct:stbrp_rect	access:public
h	libs/imgui/stb_truetype.h	/^   int w,h,stride;$/;"	m	struct:__anon13	access:public
h_oversample	libs/imgui/stb_truetype.h	/^   unsigned char h_oversample, v_oversample; \/\/ don't set these, they're used internally$/;"	m	struct:__anon10	access:public
h_oversample	libs/imgui/stb_truetype.h	/^   unsigned int   h_oversample, v_oversample;$/;"	m	struct:stbtt_pack_context	access:public
has_preferred_x	libs/imgui/stb_textedit.h	/^   unsigned char has_preferred_x;$/;"	m	struct:__anon4	access:public
head	libs/imgui/stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo	access:public
head	libs/imgui/stb_truetype.h	/^   struct stbtt__hheap_chunk *head;$/;"	m	struct:stbtt__hheap	typeref:struct:stbtt__hheap::stbtt__hheap_chunk	access:public
height	GaffMaker/include/LoadPNG.h	/^    short height = 0;$/;"	m	struct:image	access:public
height	include/level/Level.h	/^    const int height = 48;$/;"	m	namespace:Level
height	libs/imgui/stb_rect_pack.h	/^   int height;$/;"	m	struct:stbrp_context	access:public
height	libs/imgui/stb_textedit.h	/^   float height; \/\/ height of line$/;"	m	struct:__anon6	access:public
height	libs/imgui/stb_truetype.h	/^   int   height;$/;"	m	struct:stbtt_pack_context	access:public
height	libs/imgui/stb_truetype.h	/^   int width,height;$/;"	m	struct:__anon21	access:public
heuristic	libs/imgui/stb_rect_pack.h	/^   int heuristic;$/;"	m	struct:stbrp_context	access:public
hhea	libs/imgui/stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo	access:public
hmtx	libs/imgui/stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo	access:public
i	GaffMaker/include/Definitions.h	/^    uint i;$/;"	m	union:byteInt	access:public
i	include/Definitions.h	/^    uint i;$/;"	m	union:byteInt	access:public
id	libs/imgui/stb_rect_pack.h	/^   int            id;$/;"	m	struct:stbrp_rect	access:public
id	libs/imgui/stb_truetype.h	/^   int id,w,h,was_packed;$/;"	m	struct:stbrp_rect	access:public
image	GaffMaker/include/LoadPNG.h	/^struct image {$/;"	s
image::data	GaffMaker/include/LoadPNG.h	/^    byte *data;$/;"	m	struct:image	access:public
image::height	GaffMaker/include/LoadPNG.h	/^    short height = 0;$/;"	m	struct:image	access:public
image::size	GaffMaker/include/LoadPNG.h	/^    int size = 0;$/;"	m	struct:image	access:public
image::width	GaffMaker/include/LoadPNG.h	/^    short width = 0;$/;"	m	struct:image	access:public
imageSize	GaffMaker/src/Writer.cpp	/^int imageSize(int width, int height) {$/;"	f	signature:(int width, int height)
imageSize	GaffMaker/src/Writer.cpp	/^int imageSize(int width, int height);$/;"	p	file:	signature:(int width, int height)
indexToLocFormat	libs/imgui/stb_truetype.h	/^   int indexToLocFormat;              \/\/ format needed to map from glyph index to glyph$/;"	m	struct:stbtt_fontinfo	access:public
index_map	libs/imgui/stb_truetype.h	/^   int index_map;                     \/\/ a cmap mapping for our chosen character encoding$/;"	m	struct:stbtt_fontinfo	access:public
info	GaffMaker/src/Writer.cpp	/^    Gaff::fileInfo info;$/;"	m	struct:fileAll	file:	access:public
init	include/entities/Entity.h	/^	void init();$/;"	p	class:Entity	access:public	signature:()
init	include/gfx/Camera.h	/^    void init();$/;"	p	namespace:Camera	signature:()
init	include/gfx/Font.h	/^    void init();$/;"	p	namespace:Font	signature:()
init	include/gfx/Render.h	/^    void init();$/;"	p	namespace:Render	signature:()
init	include/level/Level.h	/^    void init();$/;"	p	namespace:Level	signature:()
init	src/Game.cpp	/^    void init() {$/;"	f	namespace:Game	signature:()
init	src/Game.cpp	/^    void init();$/;"	p	namespace:Game	file:	signature:()
init	src/entities/Entity.cpp	/^void Entity::init() {$/;"	f	class:Entity	signature:()
init	src/gfx/Camera.cpp	/^    void init() {$/;"	f	namespace:Camera	signature:()
init	src/gfx/Font.cpp	/^    void init() {$/;"	f	namespace:Font	signature:()
init	src/gfx/Render.cpp	/^    void init() {$/;"	f	namespace:Render	signature:()
init	src/legacy/Render.cpp	/^    void init() {$/;"	f	namespace:Render	signature:()
init	src/level/Level.cpp	/^    void init() {$/;"	f	namespace:Level	signature:()
initMatrix	src/gfx/Font.cpp	/^    mat4 initMatrix = translate(IDENTITY, vec3(0.8f * fontScaleFloat, fontScaleFloat, 0));$/;"	m	namespace:Font	file:
init_mode	libs/imgui/stb_rect_pack.h	/^   int init_mode;$/;"	m	struct:stbrp_context	access:public
initialized	libs/imgui/stb_textedit.h	/^   unsigned char initialized;$/;"	m	struct:__anon4	access:public
insert	libs/imgui/imgui.h	/^    inline iterator             insert(const_iterator it, const value_type& v)  { IM_ASSERT(it >= begin() && it <= end()); const ptrdiff_t off = it - begin(); if (Size == Capacity) reserve(Capacity ? Capacity * 2 : 4); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(value_type)); Data[off] = v; Size++; return Data + off; }$/;"	f	class:ImVector	access:public	signature:(const_iterator it, const value_type& v)
insert_length	libs/imgui/stb_textedit.h	/^   short           insert_length;$/;"	m	struct:__anon2	access:public
insert_mode	libs/imgui/stb_textedit.h	/^   unsigned char insert_mode;$/;"	m	struct:__anon4	access:public
invert	libs/imgui/stb_truetype.h	/^   int invert;$/;"	m	struct:stbtt__edge	access:public
isPressed	include/Input.h	/^    bool isPressed(int key);$/;"	p	namespace:Input	signature:(int key)
isPressed	src/Input.cpp	/^    bool isPressed(int key) {$/;"	f	namespace:Input	signature:(int key)
is_separator	libs/imgui/imgui.cpp	/^static bool is_separator(unsigned int c)                                                          { return c==',' || c==';' || c=='(' || c==')' || c=='{' || c=='}' || c=='[' || c==']' || c=='|'; }$/;"	f	file:	signature:(unsigned int c)
is_word_boundary	libs/imgui/stb_textedit.h	/^static int is_word_boundary( STB_TEXTEDIT_STRING *_str, int _idx )$/;"	f	signature:( STB_TEXTEDIT_STRING *_str, int _idx )
isblank	libs/imgui/imgui.h	/^        static bool isblank(char c) { return c == ' ' || c == '\\t'; }$/;"	f	struct:ImGuiTextFilter::TextRange	access:public	signature:(char c)
iterator	libs/imgui/imgui.h	/^    typedef value_type*         iterator;$/;"	t	class:ImVector	access:public
kern	libs/imgui/stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo	access:public
key	libs/imgui/imgui.h	/^        ImGuiID key; $/;"	m	struct:ImGuiStorage::Pair	access:public
keyCallback	include/Input.h	/^    void keyCallback(GLFWwindow* window, int key, int scancode, int action, int mods);$/;"	p	namespace:Input	signature:(GLFWwindow* window, int key, int scancode, int action, int mods)
keyCallback	src/Input.cpp	/^    void keyCallback(GLFWwindow* window, int key, int scancode, int action, int mods) {$/;"	f	namespace:Input	signature:(GLFWwindow* window, int key, int scancode, int action, int mods)
keys	src/Input.cpp	/^    bool keys[1000] = {0};$/;"	m	namespace:Input	file:
lastTick	src/Game.cpp	/^    float lastTick;$/;"	m	namespace:Game	file:
layout	src/level/Level.cpp	/^    byte layout[Level::height][Level::width];$/;"	m	namespace:Level	file:
layout0	src/level/Level.cpp	/^    byte layout0[Level::height][Level::width];$/;"	m	namespace:Level	file:
length	libs/imgui/stb_textedit.h	/^   int first_char, length; \/\/ first char of row, and length$/;"	m	struct:__anon6	access:public
load	include/gfx/ShaderLoader.h	/^    GLuint load(const char *nameVert, const char *nameFrag);$/;"	p	namespace:Shader	signature:(const char *nameVert, const char *nameFrag)
load	include/gfx/TextureLoader.h	/^	GLuint load(std::string name);$/;"	p	namespace:Texture	signature:(std::string name)
load	include/io/Reader.h	/^	void load(std::string*);$/;"	p	namespace:IO::Reader	signature:(std::string*)
load	src/gfx/ShaderLoader.cpp	/^    GLuint load(const char *nameVert, const char *nameFrag) {$/;"	f	namespace:Shader	signature:(const char *nameVert, const char *nameFrag)
load	src/gfx/TextureLoader.cpp	/^    GLuint load(std::string name) {$/;"	f	namespace:Texture	signature:(std::string name)
load	src/io/Reader.cpp	/^	void load(string fileName[]) {$/;"	f	namespace:IO::Reader	signature:(string fileName[])
loadFile	src/io/Reader.cpp	/^	static void loadFile(std::string fileName);$/;"	p	namespace:IO::Reader	file:	signature:(std::string fileName)
loadFile	src/io/Reader.cpp	/^	void loadFile(std::string fileName) {$/;"	f	namespace:IO::Reader	signature:(std::string fileName)
loadPNG	GaffMaker/include/LoadPNG.h	/^image loadPNG(char *name);$/;"	p	signature:(char *name)
loadPNG	GaffMaker/src/LoadPNG.cpp	/^image loadPNG(char *name) {$/;"	f	signature:(char *name)
loca	libs/imgui/stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo	access:public
log	include/util/Console.h	/^    void log(std::string text);$/;"	p	namespace:Console	signature:(std::string text)
log	src/util/Console.cpp	/^    void log(std::string text) {$/;"	f	namespace:Console	signature:(std::string text)
main	GaffMaker/src/Writer.cpp	/^int main() {$/;"	f	signature:()
main	include/Game.h	/^    void main();$/;"	p	namespace:Game	signature:()
main	libs/imgui/stb_truetype.h	/^int main(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	src/Game.cpp	/^    void main() {$/;"	f	namespace:Game	signature:()
main	src/Launcher.cpp	/^int main() {$/;"	f	signature:()
makeFile	GaffMaker/src/Writer.cpp	/^void makeFile(string name, byte type, int extra, int size, byte data[]) {$/;"	f	signature:(string name, byte type, int extra, int size, byte data[])
makeFile	GaffMaker/src/Writer.cpp	/^void makeFile(string name, byte type, int extra, int size, byte data[]);$/;"	p	file:	signature:(string name, byte type, int extra, int size, byte data[])
makeImage	GaffMaker/src/Writer.cpp	/^void makeImage(char *imageName, string name, byte type) {$/;"	f	signature:(char *imageName, string name, byte type)
makeImage	GaffMaker/src/Writer.cpp	/^void makeImage(char *imageName, string name, byte type);$/;"	p	file:	signature:(char *imageName, string name, byte type)
maxFT	src/Game.cpp	/^    float maxFT = 0;$/;"	m	namespace:Game	file:
minFT	src/Game.cpp	/^    float minFT = 10;$/;"	m	namespace:Game	file:
move	include/gfx/Render.h	/^    void move(vec4 toMove);$/;"	p	namespace:Render	signature:(vec4 toMove)
move	src/gfx/Render.cpp	/^    void move(vec4 toMove) {$/;"	f	namespace:Render	signature:(vec4 toMove)
move	src/legacy/Render.cpp	/^    void move(vec4 toMove) {$/;"	f	namespace:Render	signature:(vec4 toMove)
my_stbtt_initfont	libs/imgui/stb_truetype.h	/^void my_stbtt_initfont(void)$/;"	f	signature:(void)
my_stbtt_print	libs/imgui/stb_truetype.h	/^void my_stbtt_print(float x, float y, char *text)$/;"	f	signature:(float x, float y, char *text)
name	GaffMaker/include/Definitions.h	/^	    std::string name = "";$/;"	m	struct:Gaff::fileInfo	access:public
name	include/Definitions.h	/^	    std::string name = "";$/;"	m	struct:Gaff::fileInfo	access:public
nameSize	GaffMaker/include/Definitions.h	/^	    byte nameSize = 0x00;$/;"	m	struct:Gaff::fileInfo	access:public
nameSize	include/Definitions.h	/^	    byte nameSize = 0x00;$/;"	m	struct:Gaff::fileInfo	access:public
next	libs/imgui/stb_rect_pack.h	/^   stbrp_node  *next;$/;"	m	struct:stbrp_node	access:public
next	libs/imgui/stb_truetype.h	/^   struct stbtt__active_edge *next;$/;"	m	struct:stbtt__active_edge	typeref:struct:stbtt__active_edge::stbtt__active_edge	access:public
next	libs/imgui/stb_truetype.h	/^   struct stbtt__hheap_chunk *next;$/;"	m	struct:stbtt__hheap_chunk	typeref:struct:stbtt__hheap_chunk::stbtt__hheap_chunk	access:public
nodes	libs/imgui/stb_truetype.h	/^   void  *nodes;$/;"	m	struct:stbtt_pack_context	access:public
numGlyphs	libs/imgui/stb_truetype.h	/^   int numGlyphs;                     \/\/ number of glyphs, needed for range checking$/;"	m	struct:stbtt_fontinfo	access:public
num_chars	libs/imgui/stb_textedit.h	/^   int num_chars;$/;"	m	struct:__anon5	access:public
num_chars	libs/imgui/stb_truetype.h	/^   int num_chars;$/;"	m	struct:__anon10	access:public
num_nodes	libs/imgui/stb_rect_pack.h	/^   int num_nodes;$/;"	m	struct:stbrp_context	access:public
num_remaining_in_head_chunk	libs/imgui/stb_truetype.h	/^   int    num_remaining_in_head_chunk;$/;"	m	struct:stbtt__hheap	access:public
offset	GaffMaker/include/Definitions.h	/^	    byteInt offset;$/;"	m	struct:Gaff::fileInfo	access:public
offset	GaffMaker/src/Writer.cpp	/^byteInt offset;$/;"	v
offset	include/Definitions.h	/^	    byteInt offset;$/;"	m	struct:Gaff::fileInfo	access:public
operator *	libs/imgui/imgui.cpp	/^static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }$/;"	f	file:	signature:(const ImVec2& lhs, const ImVec2& rhs)
operator *	libs/imgui/imgui.cpp	/^static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }$/;"	f	file:	signature:(const ImVec2& lhs, const float rhs)
operator *=	libs/imgui/imgui.cpp	/^static inline ImVec2& operator*=(ImVec2& lhs, const float rhs)                  { lhs.x *= rhs; lhs.y *= rhs; return lhs; }$/;"	f	file:	signature:(ImVec2& lhs, const float rhs)
operator +	libs/imgui/imgui.cpp	/^static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }$/;"	f	file:	signature:(const ImVec2& lhs, const ImVec2& rhs)
operator +=	libs/imgui/imgui.cpp	/^static inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }$/;"	f	file:	signature:(ImVec2& lhs, const ImVec2& rhs)
operator -	libs/imgui/imgui.cpp	/^static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }$/;"	f	file:	signature:(const ImVec2& lhs, const ImVec2& rhs)
operator -	libs/imgui/imgui.cpp	/^static inline ImVec4 operator-(const ImVec4& lhs, const ImVec4& rhs)            { return ImVec4(lhs.x-rhs.x, lhs.y-rhs.y, lhs.z-rhs.z, lhs.w-lhs.w); }$/;"	f	file:	signature:(const ImVec4& lhs, const ImVec4& rhs)
operator /	libs/imgui/imgui.cpp	/^static inline ImVec2 operator\/(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x\/rhs.x, lhs.y\/rhs.y); }$/;"	f	file:	signature:(const ImVec2& lhs, const ImVec2& rhs)
operator ImU32	libs/imgui/imgui.h	/^    operator ImU32() const                                          { return ImGui::ColorConvertFloat4ToU32(Value); }$/;"	f	struct:ImColor	access:public	signature:() const
operator ImVec4	libs/imgui/imgui.h	/^    operator ImVec4() const                                         { return Value; }$/;"	f	struct:ImColor	access:public	signature:() const
operator []	libs/imgui/imgui.h	/^    inline const value_type&    operator[](int i) const         { IM_ASSERT(i < Size); return Data[i]; }$/;"	f	class:ImVector	access:public	signature:(int i) const
operator []	libs/imgui/imgui.h	/^    inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }$/;"	f	class:ImVector	access:public	signature:(int i)
operator bool	libs/imgui/imgui.h	/^    operator bool() const { int current_frame = ImGui::GetFrameCount(); if (RefFrame == current_frame) return false; RefFrame = current_frame; return true; }$/;"	f	struct:ImGuiOnceUponAFrame	access:public	signature:() const
origin	GaffMaker/include/Definitions.h	/^	    std::string origin = "";$/;"	m	struct:Gaff::fileInfo	access:public
origin	include/Definitions.h	/^	    std::string origin = "";$/;"	m	struct:Gaff::fileInfo	access:public
outline	include/gfx/Render.h	/^    void outline(vec4 position, vec2 size, vec4 color);$/;"	p	namespace:Render	signature:(vec4 position, vec2 size, vec4 color)
outline	src/gfx/Render.cpp	/^    void outline(vec4 modelMatrix , vec2 size, vec4 color) {$/;"	f	namespace:Render	signature:(vec4 modelMatrix , vec2 size, vec4 color)
outline	src/legacy/Render.cpp	/^    void outline(vec4 position , vec2 size, vec4 color) {$/;"	f	namespace:Render	signature:(vec4 position , vec2 size, vec4 color)
outlineAbs	include/gfx/Render.h	/^    void outlineAbs(vec4 position, vec2 size, vec4 color);$/;"	p	namespace:Render	signature:(vec4 position, vec2 size, vec4 color)
outlineAbs	src/gfx/Render.cpp	/^    void outlineAbs(vec4 modelMatrix , vec2 size, vec4 color) {$/;"	f	namespace:Render	signature:(vec4 modelMatrix , vec2 size, vec4 color)
outlineAbs	src/legacy/Render.cpp	/^    void outlineAbs(vec4 position , vec2 size, vec4 color) {$/;"	f	namespace:Render	signature:(vec4 position , vec2 size, vec4 color)
pack_info	libs/imgui/stb_truetype.h	/^   void *pack_info;$/;"	m	struct:stbtt_pack_context	access:public
padding	libs/imgui/stb_truetype.h	/^      unsigned char type,padding;$/;"	m	struct:__anon12	access:public
padding	libs/imgui/stb_truetype.h	/^   int   padding;$/;"	m	struct:stbtt_pack_context	access:public
padding1	libs/imgui/stb_textedit.h	/^   unsigned char padding1, padding2, padding3;$/;"	m	struct:__anon4	access:public
padding2	libs/imgui/stb_textedit.h	/^   unsigned char padding1, padding2, padding3;$/;"	m	struct:__anon4	access:public
padding3	libs/imgui/stb_textedit.h	/^   unsigned char padding1, padding2, padding3;$/;"	m	struct:__anon4	access:public
paused	src/Game.cpp	/^    bool paused = false;$/;"	m	namespace:Game	file:
pixels	libs/imgui/stb_truetype.h	/^   unsigned char *pixels;$/;"	m	struct:__anon13	access:public
pixels	libs/imgui/stb_truetype.h	/^   unsigned char *pixels;$/;"	m	struct:stbtt_pack_context	access:public
player	src/Game.cpp	/^    Entity *player = Level::getPlayer();$/;"	m	namespace:Game	file:
player	src/gfx/Camera.cpp	/^    Entity *player;$/;"	m	namespace:Camera	file:
poll	include/Window.h	/^    void poll();$/;"	p	namespace:Window	signature:()
poll	src/Window.cpp	/^    void poll() {$/;"	f	namespace:Window	signature:()
poll	src/legacy/Window.cpp	/^    void poll() {$/;"	f	namespace:Window	signature:()
pop_back	libs/imgui/imgui.h	/^    inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }$/;"	f	class:ImVector	access:public	signature:()
pos	libs/imgui/imgui.h	/^    ImVec2  pos;$/;"	m	struct:ImDrawVert	access:public
position	include/entities/Entity.h	/^	vec4 position = vec4(0, 0, 0.0f, 1.0f);$/;"	m	class:Entity	access:public
positionLast	src/gfx/Camera.cpp	/^    vec4 positionLast;$/;"	m	namespace:Camera	file:
positionMatrix	src/gfx/Font.cpp	/^    mat4 positionMatrix = translate(IDENTITY, vec3(1.0f, 0, 0));$/;"	m	namespace:Font	file:
preferred_x	libs/imgui/stb_textedit.h	/^   float preferred_x; \/\/ this determines where the cursor up\/down tries to seek to along x$/;"	m	struct:__anon4	access:public
prev_first	libs/imgui/stb_textedit.h	/^   int prev_first;  \/\/ first char of previous row$/;"	m	struct:__anon6	access:public
prev_link	libs/imgui/stb_rect_pack.h	/^   stbrp_node **prev_link;$/;"	m	struct:__anon25	access:public
print	include/util/Log.h	/^    void print(std::string msg, int type);$/;"	p	namespace:Log	signature:(std::string msg, int type)
print	src/util/Log.cpp	/^    void print(std::string msg, int type) {$/;"	f	namespace:Log	signature:(std::string msg, int type)
proc	src/Game.cpp	/^    struct proc_t proc;$/;"	m	namespace:Game	typeref:struct:Game::proc_t	file:
proggy_clean_ttf_compressed_data_base85	libs/imgui/imgui.cpp	/^static const char proggy_clean_ttf_compressed_data_base85[11980+1] =$/;"	v	file:
projectionMatrix	src/gfx/Render.cpp	/^    mat4 projectionMatrix = perspective(fov, 4.0f \/ 3.0f, 0.1f, 100.0f);$/;"	m	namespace:Render	file:
push_back	libs/imgui/imgui.h	/^    inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }$/;"	f	class:ImVector	access:public	signature:(const value_type& v)
quad	include/gfx/Render.h	/^    void quad(vec4 position, vec2 size, vec4 color);$/;"	p	namespace:Render	signature:(vec4 position, vec2 size, vec4 color)
quad	src/gfx/Render.cpp	/^    void quad(vec4 modelMatrix , vec2 size, vec4 color) {$/;"	f	namespace:Render	signature:(vec4 modelMatrix , vec2 size, vec4 color)
quad	src/legacy/Render.cpp	/^    void quad(vec4 position , vec2 size, vec4 color) {$/;"	f	namespace:Render	signature:(vec4 position , vec2 size, vec4 color)
quadAbs	include/gfx/Render.h	/^    void quadAbs(vec4 position, vec2 size, vec4 color);$/;"	p	namespace:Render	signature:(vec4 position, vec2 size, vec4 color)
quadAbs	src/gfx/Render.cpp	/^    void quadAbs(vec4 modelMatrix, vec2 size, vec4 color) {$/;"	f	namespace:Render	signature:(vec4 modelMatrix, vec2 size, vec4 color)
quadAbs	src/legacy/Render.cpp	/^    void quadAbs(vec4 position, vec2 size, vec4 color) {$/;"	f	namespace:Render	signature:(vec4 position, vec2 size, vec4 color)
quadTex	include/gfx/Render.h	/^    void quadTex(vec4 position, vec2 size, GLuint tex, vec4 uv);$/;"	p	namespace:Render	signature:(vec4 position, vec2 size, GLuint tex, vec4 uv)
quadTex	src/gfx/Render.cpp	/^    void quadTex(vec4 modelMatrix, vec2 size, GLuint tex, vec4 uv) {$/;"	f	namespace:Render	signature:(vec4 modelMatrix, vec2 size, GLuint tex, vec4 uv)
quadTex	src/legacy/Render.cpp	/^    void quadTex(vec4 position, vec2 size, GLuint tex, vec4 uv) {$/;"	f	namespace:Render	signature:(vec4 position, vec2 size, GLuint tex, vec4 uv)
quadTexAbs	include/gfx/Render.h	/^    void quadTexAbs(vec4 position, vec2 size, GLuint tex, vec4 uv);$/;"	p	namespace:Render	signature:(vec4 position, vec2 size, GLuint tex, vec4 uv)
quadTexAbs	src/gfx/Render.cpp	/^    void quadTexAbs(vec4 position, vec2 size, GLuint tex, vec4 uv) {$/;"	f	namespace:Render	signature:(vec4 position, vec2 size, GLuint tex, vec4 uv)
quadTexAbs	src/legacy/Render.cpp	/^    void quadTexAbs(vec4 position, vec2 size, GLuint tex, vec4 uv) {$/;"	f	namespace:Render	signature:(vec4 position, vec2 size, GLuint tex, vec4 uv)
rG	src/io/Reader.cpp	/^	uint rG = 0;$/;"	m	namespace:IO::Reader	file:
read	include/io/Reader.h	/^	void read(int id, byte*);$/;"	p	namespace:IO::Reader	signature:(int id, byte*)
read	src/io/Reader.cpp	/^	void read(int id, byte data[]) {$/;"	f	namespace:IO::Reader	signature:(int id, byte data[])
readShader	src/gfx/ShaderLoader.cpp	/^    void readShader(std::string fileName, std::vector<char> &buffer) {$/;"	f	namespace:Shader	signature:(std::string fileName, std::vector<char> &buffer)
readShader	src/gfx/ShaderLoader.cpp	/^    void readShader(std::string fileName, std::vector<char> &buffer);$/;"	p	namespace:Shader	file:	signature:(std::string fileName, std::vector<char> &buffer)
rect_height_compare	libs/imgui/stb_rect_pack.h	/^static int rect_height_compare(const void *a, const void *b)$/;"	f	signature:(const void *a, const void *b)
rect_original_order	libs/imgui/stb_rect_pack.h	/^static int rect_original_order(const void *a, const void *b)$/;"	f	signature:(const void *a, const void *b)
rect_width_compare	libs/imgui/stb_rect_pack.h	/^static int rect_width_compare(const void *a, const void *b)$/;"	f	signature:(const void *a, const void *b)
redo_char_point	libs/imgui/stb_textedit.h	/^   short undo_char_point, redo_char_point;$/;"	m	struct:__anon3	access:public
redo_point	libs/imgui/stb_textedit.h	/^   short undo_point, redo_point;$/;"	m	struct:__anon3	access:public
render	include/entities/Entity.h	/^	void render();$/;"	p	class:Entity	access:public	signature:()
render	include/gfx/Camera.h	/^    void render();$/;"	p	namespace:Camera	signature:()
render	include/gfx/Font.h	/^    void render(vec4 position, vec4 color, std::string msg);$/;"	p	namespace:Font	signature:(vec4 position, vec4 color, std::string msg)
render	include/level/Level.h	/^    void render();$/;"	p	namespace:Level	signature:()
render	include/level/Tile.h	/^    void render(vec4 position, byte id);$/;"	p	namespace:Tile	signature:(vec4 position, byte id)
render	src/Game.cpp	/^    void render() {$/;"	f	namespace:Game	signature:()
render	src/Game.cpp	/^    void render();$/;"	p	namespace:Game	file:	signature:()
render	src/entities/Entity.cpp	/^void Entity::render() {$/;"	f	class:Entity	signature:()
render	src/gfx/Camera.cpp	/^    void render() {$/;"	f	namespace:Camera	signature:()
render	src/gfx/Font.cpp	/^    void render(vec4 position, vec4 color, std::string msg) {$/;"	f	namespace:Font	signature:(vec4 position, vec4 color, std::string msg)
render	src/level/Level.cpp	/^    void render() {$/;"	f	namespace:Level	signature:()
render	src/level/Tile.cpp	/^void Tile::render(vec4 position, byte id) {$/;"	f	class:Tile	signature:(vec4 position, byte id)
renderDebug	src/Game.cpp	/^    void renderDebug() {$/;"	f	namespace:Game	signature:()
renderDebug	src/Game.cpp	/^    void renderDebug();$/;"	p	namespace:Game	file:	signature:()
reserve	libs/imgui/imgui.h	/^    inline void                 reserve(int new_capacity)    $/;"	f	class:ImVector	access:public	signature:(int new_capacity)
resize	libs/imgui/imgui.h	/^    inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }$/;"	f	class:ImVector	access:public	signature:(int new_size)
run	include/util/Command.h	/^    bool run(std::string command);$/;"	p	namespace:Command	signature:(std::string command)
run	src/util/Command.cpp	/^    bool run(std::string command) {$/;"	f	namespace:Command	signature:(std::string command)
s	GaffMaker/include/Definitions.h	/^    unsigned short s;$/;"	m	union:byteShort	access:public
s	include/Definitions.h	/^    unsigned short s;$/;"	m	union:byteShort	access:public
s0	libs/imgui/stb_truetype.h	/^   float x0,y0,s0,t0; \/\/ top-left$/;"	m	struct:__anon8	access:public
s1	libs/imgui/stb_truetype.h	/^   float x1,y1,s1,t1; \/\/ bottom-right$/;"	m	struct:__anon8	access:public
select_end	libs/imgui/stb_textedit.h	/^   int select_end;$/;"	m	struct:__anon4	access:public
select_start	libs/imgui/stb_textedit.h	/^   int select_start;          \/\/ selection start point$/;"	m	struct:__anon4	access:public
setState	include/Input.h	/^    void setState(int key, bool state);$/;"	p	namespace:Input	signature:(int key, bool state)
setState	src/Input.cpp	/^    void setState(int key, bool state) {$/;"	f	namespace:Input	signature:(int key, bool state)
shouldClose	include/Window.h	/^    bool shouldClose();$/;"	p	namespace:Window	signature:()
shouldClose	src/Window.cpp	/^    bool shouldClose() {$/;"	f	namespace:Window	signature:()
shouldClose	src/legacy/Window.cpp	/^    bool shouldClose() {$/;"	f	namespace:Window	signature:()
show	include/util/Console.h	/^    void show(bool *opened);$/;"	p	namespace:Console	signature:(bool *opened)
show	src/util/Console.cpp	/^    void show(bool* opened) {$/;"	f	namespace:Console	signature:(bool* opened)
showConsole	src/Game.cpp	/^    bool showConsole = false;$/;"	m	namespace:Game	file:
showDebug	src/Game.cpp	/^    bool showDebug = false;$/;"	m	namespace:Game	file:
single_line	libs/imgui/stb_textedit.h	/^   unsigned char single_line;$/;"	m	struct:__anon4	access:public
size	GaffMaker/include/Definitions.h	/^	    byteInt size;$/;"	m	struct:Gaff::fileInfo	access:public
size	GaffMaker/include/LoadPNG.h	/^    int size = 0;$/;"	m	struct:image	access:public
size	include/Definitions.h	/^	    byteInt size;$/;"	m	struct:Gaff::fileInfo	access:public
size	libs/imgui/imgui.h	/^    inline int                  size() const                    { return Size; }$/;"	f	class:ImVector	access:public	signature:() const
size	libs/imgui/imgui.h	/^    int                 size() const { return Buf.Size-1; }$/;"	f	struct:ImGuiTextBuffer	access:public	signature:() const
snprintf	libs/imgui/imgui.cpp	489;"	d	file:
split	libs/imgui/imgui.cpp	/^void ImGuiTextFilter::TextRange::split(char separator, ImVector<TextRange>& out)$/;"	f	class:ImGuiTextFilter::TextRange	signature:(char separator, ImVector<TextRange>& out)
split	libs/imgui/imgui.h	/^        IMGUI_API void split(char separator, ImVector<TextRange>& out);$/;"	p	struct:ImGuiTextFilter::TextRange	access:public	signature:(char separator, ImVector<TextRange>& out)
stb__barrier	libs/imgui/imgui.cpp	/^static unsigned char *stb__barrier, *stb__barrier2, *stb__barrier3, *stb__barrier4;$/;"	v	file:
stb__barrier2	libs/imgui/imgui.cpp	/^static unsigned char *stb__barrier, *stb__barrier2, *stb__barrier3, *stb__barrier4;$/;"	v	file:
stb__barrier3	libs/imgui/imgui.cpp	/^static unsigned char *stb__barrier, *stb__barrier2, *stb__barrier3, *stb__barrier4;$/;"	v	file:
stb__barrier4	libs/imgui/imgui.cpp	/^static unsigned char *stb__barrier, *stb__barrier2, *stb__barrier3, *stb__barrier4;$/;"	v	file:
stb__dout	libs/imgui/imgui.cpp	/^static unsigned char *stb__dout;$/;"	v	file:
stb__in2	libs/imgui/imgui.cpp	13231;"	d	file:
stb__in3	libs/imgui/imgui.cpp	13232;"	d	file:
stb__in4	libs/imgui/imgui.cpp	13233;"	d	file:
stb__lit	libs/imgui/imgui.cpp	/^static void stb__lit(unsigned char *data, unsigned int length)$/;"	f	file:	signature:(unsigned char *data, unsigned int length)
stb__match	libs/imgui/imgui.cpp	/^static void stb__match(unsigned char *data, unsigned int length)$/;"	f	file:	signature:(unsigned char *data, unsigned int length)
stb_adler32	libs/imgui/imgui.cpp	/^static unsigned int stb_adler32(unsigned int adler32, unsigned char *buffer, unsigned int buflen)$/;"	f	file:	signature:(unsigned int adler32, unsigned char *buffer, unsigned int buflen)
stb_decompress	libs/imgui/imgui.cpp	/^static unsigned int stb_decompress(unsigned char *output, unsigned char *i, unsigned int length)$/;"	f	file:	signature:(unsigned char *output, unsigned char *i, unsigned int length)
stb_decompress	libs/imgui/imgui.cpp	/^static unsigned int stb_decompress(unsigned char *output, unsigned char *i, unsigned int length);$/;"	p	file:	signature:(unsigned char *output, unsigned char *i, unsigned int length)
stb_decompress_length	libs/imgui/imgui.cpp	/^static unsigned int stb_decompress_length(unsigned char *input)$/;"	f	file:	signature:(unsigned char *input)
stb_decompress_length	libs/imgui/imgui.cpp	/^static unsigned int stb_decompress_length(unsigned char *input);$/;"	p	file:	signature:(unsigned char *input)
stb_decompress_token	libs/imgui/imgui.cpp	/^static unsigned char *stb_decompress_token(unsigned char *i)$/;"	f	file:	signature:(unsigned char *i)
stb_text_create_undo_record	libs/imgui/stb_textedit.h	/^static StbUndoRecord *stb_text_create_undo_record(StbUndoState *state, int numchars)$/;"	f	signature:(StbUndoState *state, int numchars)
stb_text_createundo	libs/imgui/stb_textedit.h	/^static STB_TEXTEDIT_CHARTYPE *stb_text_createundo(StbUndoState *state, int pos, int insert_len, int delete_len)$/;"	f	signature:(StbUndoState *state, int pos, int insert_len, int delete_len)
stb_text_locate_coord	libs/imgui/stb_textedit.h	/^static int stb_text_locate_coord(STB_TEXTEDIT_STRING *str, float x, float y)$/;"	f	signature:(STB_TEXTEDIT_STRING *str, float x, float y)
stb_text_makeundo_delete	libs/imgui/stb_textedit.h	/^static void stb_text_makeundo_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length)$/;"	f	signature:(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length)
stb_text_makeundo_delete	libs/imgui/stb_textedit.h	/^static void stb_text_makeundo_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length);$/;"	p	signature:(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length)
stb_text_makeundo_insert	libs/imgui/stb_textedit.h	/^static void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length)$/;"	f	signature:(STB_TexteditState *state, int where, int length)
stb_text_makeundo_insert	libs/imgui/stb_textedit.h	/^static void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length);$/;"	p	signature:(STB_TexteditState *state, int where, int length)
stb_text_makeundo_replace	libs/imgui/stb_textedit.h	/^static void stb_text_makeundo_replace(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length)$/;"	f	signature:(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length)
stb_text_makeundo_replace	libs/imgui/stb_textedit.h	/^static void stb_text_makeundo_replace(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length);$/;"	p	signature:(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length)
stb_text_redo	libs/imgui/stb_textedit.h	/^static void stb_text_redo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)$/;"	f	signature:(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
stb_text_redo	libs/imgui/stb_textedit.h	/^static void stb_text_redo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state);$/;"	p	signature:(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
stb_text_undo	libs/imgui/stb_textedit.h	/^static void stb_text_undo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)$/;"	f	signature:(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
stb_text_undo	libs/imgui/stb_textedit.h	/^static void stb_text_undo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state);$/;"	p	signature:(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
stb_textedit_clamp	libs/imgui/stb_textedit.h	/^static void stb_textedit_clamp(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)$/;"	f	signature:(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
stb_textedit_clear_state	libs/imgui/stb_textedit.h	/^static void stb_textedit_clear_state(STB_TexteditState *state, int is_single_line)$/;"	f	signature:(STB_TexteditState *state, int is_single_line)
stb_textedit_click	libs/imgui/stb_textedit.h	/^static void stb_textedit_click(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)$/;"	f	signature:(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
stb_textedit_cut	libs/imgui/stb_textedit.h	/^static int stb_textedit_cut(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)$/;"	f	signature:(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
stb_textedit_delete	libs/imgui/stb_textedit.h	/^static void stb_textedit_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int len)$/;"	f	signature:(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int len)
stb_textedit_delete_selection	libs/imgui/stb_textedit.h	/^static void stb_textedit_delete_selection(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)$/;"	f	signature:(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
stb_textedit_discard_redo	libs/imgui/stb_textedit.h	/^static void stb_textedit_discard_redo(StbUndoState *state)$/;"	f	signature:(StbUndoState *state)
stb_textedit_discard_undo	libs/imgui/stb_textedit.h	/^static void stb_textedit_discard_undo(StbUndoState *state)$/;"	f	signature:(StbUndoState *state)
stb_textedit_drag	libs/imgui/stb_textedit.h	/^static void stb_textedit_drag(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)$/;"	f	signature:(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
stb_textedit_find_charpos	libs/imgui/stb_textedit.h	/^static void stb_textedit_find_charpos(StbFindState *find, STB_TEXTEDIT_STRING *str, int n, int single_line)$/;"	f	signature:(StbFindState *find, STB_TEXTEDIT_STRING *str, int n, int single_line)
stb_textedit_flush_redo	libs/imgui/stb_textedit.h	/^static void stb_textedit_flush_redo(StbUndoState *state)$/;"	f	signature:(StbUndoState *state)
stb_textedit_initialize_state	libs/imgui/stb_textedit.h	/^static void stb_textedit_initialize_state(STB_TexteditState *state, int is_single_line)$/;"	f	signature:(STB_TexteditState *state, int is_single_line)
stb_textedit_key	libs/imgui/stb_textedit.h	/^static void stb_textedit_key(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int key)$/;"	f	signature:(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int key)
stb_textedit_move_to_first	libs/imgui/stb_textedit.h	/^static void stb_textedit_move_to_first(STB_TexteditState *state)$/;"	f	signature:(STB_TexteditState *state)
stb_textedit_move_to_last	libs/imgui/stb_textedit.h	/^static void stb_textedit_move_to_last(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)$/;"	f	signature:(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
stb_textedit_move_to_word_next	libs/imgui/stb_textedit.h	/^static int stb_textedit_move_to_word_next( STB_TEXTEDIT_STRING *_str, STB_TexteditState *_state )$/;"	f	signature:( STB_TEXTEDIT_STRING *_str, STB_TexteditState *_state )
stb_textedit_move_to_word_previous	libs/imgui/stb_textedit.h	/^static int stb_textedit_move_to_word_previous( STB_TEXTEDIT_STRING *_str, STB_TexteditState *_state )$/;"	f	signature:( STB_TEXTEDIT_STRING *_str, STB_TexteditState *_state )
stb_textedit_paste	libs/imgui/stb_textedit.h	/^static int stb_textedit_paste(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE const *ctext, int len)$/;"	f	signature:(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE const *ctext, int len)
stb_textedit_prep_selection_at_cursor	libs/imgui/stb_textedit.h	/^static void stb_textedit_prep_selection_at_cursor(STB_TexteditState *state)$/;"	f	signature:(STB_TexteditState *state)
stb_textedit_sortselection	libs/imgui/stb_textedit.h	/^static void stb_textedit_sortselection(STB_TexteditState *state)$/;"	f	signature:(STB_TexteditState *state)
stbrp__findresult	libs/imgui/stb_rect_pack.h	/^} stbrp__findresult;$/;"	t	typeref:struct:__anon25
stbrp__skyline_find_best_pos	libs/imgui/stb_rect_pack.h	/^static stbrp__findresult stbrp__skyline_find_best_pos(stbrp_context *c, int width, int height)$/;"	f	signature:(stbrp_context *c, int width, int height)
stbrp__skyline_find_min_y	libs/imgui/stb_rect_pack.h	/^static int stbrp__skyline_find_min_y(stbrp_context *c, stbrp_node *first, int x0, int width, int *pwaste)$/;"	f	signature:(stbrp_context *c, stbrp_node *first, int x0, int width, int *pwaste)
stbrp__skyline_pack_rectangle	libs/imgui/stb_rect_pack.h	/^static stbrp__findresult stbrp__skyline_pack_rectangle(stbrp_context *context, int width, int height)$/;"	f	signature:(stbrp_context *context, int width, int height)
stbrp_context	libs/imgui/stb_rect_pack.h	/^struct stbrp_context$/;"	s
stbrp_context	libs/imgui/stb_rect_pack.h	/^typedef struct stbrp_context stbrp_context;$/;"	t	typeref:struct:stbrp_context
stbrp_context	libs/imgui/stb_truetype.h	/^} stbrp_context;$/;"	t	typeref:struct:__anon21
stbrp_context::active_head	libs/imgui/stb_rect_pack.h	/^   stbrp_node *active_head;$/;"	m	struct:stbrp_context	access:public
stbrp_context::align	libs/imgui/stb_rect_pack.h	/^   int align;$/;"	m	struct:stbrp_context	access:public
stbrp_context::extra	libs/imgui/stb_rect_pack.h	/^   stbrp_node extra[2]; \/\/ we allocate two extra nodes so optimal user-node-count is 'width' not 'width+2'$/;"	m	struct:stbrp_context	access:public
stbrp_context::free_head	libs/imgui/stb_rect_pack.h	/^   stbrp_node *free_head;$/;"	m	struct:stbrp_context	access:public
stbrp_context::height	libs/imgui/stb_rect_pack.h	/^   int height;$/;"	m	struct:stbrp_context	access:public
stbrp_context::heuristic	libs/imgui/stb_rect_pack.h	/^   int heuristic;$/;"	m	struct:stbrp_context	access:public
stbrp_context::init_mode	libs/imgui/stb_rect_pack.h	/^   int init_mode;$/;"	m	struct:stbrp_context	access:public
stbrp_context::num_nodes	libs/imgui/stb_rect_pack.h	/^   int num_nodes;$/;"	m	struct:stbrp_context	access:public
stbrp_context::width	libs/imgui/stb_rect_pack.h	/^   int width;$/;"	m	struct:stbrp_context	access:public
stbrp_coord	libs/imgui/stb_rect_pack.h	/^typedef int            stbrp_coord;$/;"	t
stbrp_coord	libs/imgui/stb_rect_pack.h	/^typedef unsigned short stbrp_coord;$/;"	t
stbrp_coord	libs/imgui/stb_truetype.h	/^typedef int stbrp_coord;$/;"	t
stbrp_init_target	libs/imgui/stb_rect_pack.h	/^STBRP_DEF void stbrp_init_target (stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes);$/;"	p	signature:(stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes)
stbrp_init_target	libs/imgui/stb_rect_pack.h	/^STBRP_DEF void stbrp_init_target(stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes)$/;"	f	signature:(stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes)
stbrp_init_target	libs/imgui/stb_truetype.h	/^static void stbrp_init_target(stbrp_context *con, int pw, int ph, stbrp_node *nodes, int num_nodes)$/;"	f	signature:(stbrp_context *con, int pw, int ph, stbrp_node *nodes, int num_nodes)
stbrp_node	libs/imgui/stb_rect_pack.h	/^struct stbrp_node$/;"	s
stbrp_node	libs/imgui/stb_rect_pack.h	/^typedef struct stbrp_node    stbrp_node;$/;"	t	typeref:struct:stbrp_node
stbrp_node	libs/imgui/stb_truetype.h	/^} stbrp_node;$/;"	t	typeref:struct:__anon22
stbrp_node::next	libs/imgui/stb_rect_pack.h	/^   stbrp_node  *next;$/;"	m	struct:stbrp_node	access:public
stbrp_node::x	libs/imgui/stb_rect_pack.h	/^   stbrp_coord  x,y;$/;"	m	struct:stbrp_node	access:public
stbrp_node::y	libs/imgui/stb_rect_pack.h	/^   stbrp_coord  x,y;$/;"	m	struct:stbrp_node	access:public
stbrp_pack_rects	libs/imgui/stb_rect_pack.h	/^STBRP_DEF void stbrp_pack_rects (stbrp_context *context, stbrp_rect *rects, int num_rects);$/;"	p	signature:(stbrp_context *context, stbrp_rect *rects, int num_rects)
stbrp_pack_rects	libs/imgui/stb_rect_pack.h	/^STBRP_DEF void stbrp_pack_rects(stbrp_context *context, stbrp_rect *rects, int num_rects)$/;"	f	signature:(stbrp_context *context, stbrp_rect *rects, int num_rects)
stbrp_pack_rects	libs/imgui/stb_truetype.h	/^static void stbrp_pack_rects(stbrp_context *con, stbrp_rect *rects, int num_rects)$/;"	f	signature:(stbrp_context *con, stbrp_rect *rects, int num_rects)
stbrp_rect	libs/imgui/stb_rect_pack.h	/^struct stbrp_rect$/;"	s
stbrp_rect	libs/imgui/stb_rect_pack.h	/^typedef struct stbrp_rect    stbrp_rect;$/;"	t	typeref:struct:stbrp_rect
stbrp_rect	libs/imgui/stb_truetype.h	/^struct stbrp_rect$/;"	s
stbrp_rect	libs/imgui/stb_truetype.h	/^typedef struct stbrp_rect stbrp_rect;$/;"	t	typeref:struct:stbrp_rect
stbrp_rect::h	libs/imgui/stb_rect_pack.h	/^   stbrp_coord    w, h;$/;"	m	struct:stbrp_rect	access:public
stbrp_rect::h	libs/imgui/stb_truetype.h	/^   int id,w,h,was_packed;$/;"	m	struct:stbrp_rect	access:public
stbrp_rect::id	libs/imgui/stb_rect_pack.h	/^   int            id;$/;"	m	struct:stbrp_rect	access:public
stbrp_rect::id	libs/imgui/stb_truetype.h	/^   int id,w,h,was_packed;$/;"	m	struct:stbrp_rect	access:public
stbrp_rect::w	libs/imgui/stb_rect_pack.h	/^   stbrp_coord    w, h;$/;"	m	struct:stbrp_rect	access:public
stbrp_rect::w	libs/imgui/stb_truetype.h	/^   int id,w,h,was_packed;$/;"	m	struct:stbrp_rect	access:public
stbrp_rect::was_packed	libs/imgui/stb_rect_pack.h	/^   int            was_packed;  \/\/ non-zero if valid packing$/;"	m	struct:stbrp_rect	access:public
stbrp_rect::was_packed	libs/imgui/stb_truetype.h	/^   int id,w,h,was_packed;$/;"	m	struct:stbrp_rect	access:public
stbrp_rect::x	libs/imgui/stb_rect_pack.h	/^   stbrp_coord    x, y;$/;"	m	struct:stbrp_rect	access:public
stbrp_rect::x	libs/imgui/stb_truetype.h	/^   stbrp_coord x,y;$/;"	m	struct:stbrp_rect	access:public
stbrp_rect::y	libs/imgui/stb_rect_pack.h	/^   stbrp_coord    x, y;$/;"	m	struct:stbrp_rect	access:public
stbrp_rect::y	libs/imgui/stb_truetype.h	/^   stbrp_coord x,y;$/;"	m	struct:stbrp_rect	access:public
stbrp_setup_allow_out_of_mem	libs/imgui/stb_rect_pack.h	/^STBRP_DEF void stbrp_setup_allow_out_of_mem (stbrp_context *context, int allow_out_of_mem);$/;"	p	signature:(stbrp_context *context, int allow_out_of_mem)
stbrp_setup_allow_out_of_mem	libs/imgui/stb_rect_pack.h	/^STBRP_DEF void stbrp_setup_allow_out_of_mem(stbrp_context *context, int allow_out_of_mem)$/;"	f	signature:(stbrp_context *context, int allow_out_of_mem)
stbrp_setup_heuristic	libs/imgui/stb_rect_pack.h	/^STBRP_DEF void stbrp_setup_heuristic (stbrp_context *context, int heuristic);$/;"	p	signature:(stbrp_context *context, int heuristic)
stbrp_setup_heuristic	libs/imgui/stb_rect_pack.h	/^STBRP_DEF void stbrp_setup_heuristic(stbrp_context *context, int heuristic)$/;"	f	signature:(stbrp_context *context, int heuristic)
stbtt_BakeFontBitmap	libs/imgui/stb_truetype.h	/^STBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,  \/\/ font location (use offset=0 for plain .ttf)$/;"	f	signature:(const unsigned char *data, int offset, float pixel_height, unsigned char *pixels, int pw, int ph, int first_char, int num_chars, stbtt_bakedchar *chardata)
stbtt_BakeFontBitmap	libs/imgui/stb_truetype.h	/^STBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,  \/\/ font location (use offset=0 for plain .ttf)$/;"	p	signature:(const unsigned char *data, int offset, float pixel_height, unsigned char *pixels, int pw, int ph, int first_char, int num_chars, stbtt_bakedchar *chardata)
stbtt_CompareUTF8toUTF16_bigendian	libs/imgui/stb_truetype.h	/^STBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2) $/;"	f	signature:(const char *s1, int len1, const char *s2, int len2)
stbtt_CompareUTF8toUTF16_bigendian	libs/imgui/stb_truetype.h	/^STBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2);$/;"	p	signature:(const char *s1, int len1, const char *s2, int len2)
stbtt_FindGlyphIndex	libs/imgui/stb_truetype.h	/^STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint)$/;"	f	signature:(const stbtt_fontinfo *info, int unicode_codepoint)
stbtt_FindGlyphIndex	libs/imgui/stb_truetype.h	/^STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint);$/;"	p	signature:(const stbtt_fontinfo *info, int unicode_codepoint)
stbtt_FindMatchingFont	libs/imgui/stb_truetype.h	/^STBTT_DEF int stbtt_FindMatchingFont(const unsigned char *font_collection, const char *name_utf8, stbtt_int32 flags)$/;"	f	signature:(const unsigned char *font_collection, const char *name_utf8, stbtt_int32 flags)
stbtt_FindMatchingFont	libs/imgui/stb_truetype.h	/^STBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags);$/;"	p	signature:(const unsigned char *fontdata, const char *name, int flags)
stbtt_FlattenCurves	libs/imgui/stb_truetype.h	/^static stbtt__point *stbtt_FlattenCurves(stbtt_vertex *vertices, int num_verts, float objspace_flatness, int **contour_lengths, int *num_contours, void *userdata)$/;"	f	signature:(stbtt_vertex *vertices, int num_verts, float objspace_flatness, int **contour_lengths, int *num_contours, void *userdata)
stbtt_FreeBitmap	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata)$/;"	f	signature:(unsigned char *bitmap, void *userdata)
stbtt_FreeBitmap	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata);$/;"	p	signature:(unsigned char *bitmap, void *userdata)
stbtt_FreeShape	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *v)$/;"	f	signature:(const stbtt_fontinfo *info, stbtt_vertex *v)
stbtt_FreeShape	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *vertices);$/;"	p	signature:(const stbtt_fontinfo *info, stbtt_vertex *vertices)
stbtt_GetBakedQuad	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_GetBakedQuad(stbtt_bakedchar *chardata, int pw, int ph,  \/\/ same data as above$/;"	p	signature:(stbtt_bakedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int opengl_fillrule)
stbtt_GetBakedQuad	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_GetBakedQuad(stbtt_bakedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int opengl_fillrule)$/;"	f	signature:(stbtt_bakedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int opengl_fillrule)
stbtt_GetCodepointBitmap	libs/imgui/stb_truetype.h	/^STBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff)$/;"	f	signature:(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff)
stbtt_GetCodepointBitmap	libs/imgui/stb_truetype.h	/^STBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff);$/;"	p	signature:(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff)
stbtt_GetCodepointBitmapBox	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)$/;"	f	signature:(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)
stbtt_GetCodepointBitmapBox	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);$/;"	p	signature:(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)
stbtt_GetCodepointBitmapBoxSubpixel	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)$/;"	f	signature:(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
stbtt_GetCodepointBitmapBoxSubpixel	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);$/;"	p	signature:(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
stbtt_GetCodepointBitmapSubpixel	libs/imgui/stb_truetype.h	/^STBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff)$/;"	f	signature:(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff)
stbtt_GetCodepointBitmapSubpixel	libs/imgui/stb_truetype.h	/^STBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff);$/;"	p	signature:(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff)
stbtt_GetCodepointBox	libs/imgui/stb_truetype.h	/^STBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1)$/;"	f	signature:(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1)
stbtt_GetCodepointBox	libs/imgui/stb_truetype.h	/^STBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1);$/;"	p	signature:(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1)
stbtt_GetCodepointHMetrics	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing)$/;"	f	signature:(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing)
stbtt_GetCodepointHMetrics	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing);$/;"	p	signature:(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing)
stbtt_GetCodepointKernAdvance	libs/imgui/stb_truetype.h	/^STBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2)$/;"	f	signature:(const stbtt_fontinfo *info, int ch1, int ch2)
stbtt_GetCodepointKernAdvance	libs/imgui/stb_truetype.h	/^STBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2);$/;"	p	signature:(const stbtt_fontinfo *info, int ch1, int ch2)
stbtt_GetCodepointShape	libs/imgui/stb_truetype.h	/^STBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices)$/;"	f	signature:(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices)
stbtt_GetCodepointShape	libs/imgui/stb_truetype.h	/^STBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices);$/;"	p	signature:(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices)
stbtt_GetFontBoundingBox	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1)$/;"	f	signature:(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1)
stbtt_GetFontBoundingBox	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1);$/;"	p	signature:(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1)
stbtt_GetFontNameString	libs/imgui/stb_truetype.h	/^STBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID)$/;"	f	signature:(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID)
stbtt_GetFontNameString	libs/imgui/stb_truetype.h	/^STBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID);$/;"	p	signature:(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID)
stbtt_GetFontOffsetForIndex	libs/imgui/stb_truetype.h	/^STBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index);$/;"	p	signature:(const unsigned char *data, int index)
stbtt_GetFontOffsetForIndex	libs/imgui/stb_truetype.h	/^STBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *font_collection, int index)$/;"	f	signature:(const unsigned char *font_collection, int index)
stbtt_GetFontVMetrics	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap)$/;"	f	signature:(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap)
stbtt_GetFontVMetrics	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap);$/;"	p	signature:(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap)
stbtt_GetGlyphBitmap	libs/imgui/stb_truetype.h	/^STBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff)$/;"	f	signature:(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff)
stbtt_GetGlyphBitmap	libs/imgui/stb_truetype.h	/^STBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff);$/;"	p	signature:(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff)
stbtt_GetGlyphBitmapBox	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)$/;"	f	signature:(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)
stbtt_GetGlyphBitmapBox	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);$/;"	p	signature:(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)
stbtt_GetGlyphBitmapBoxSubpixel	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)$/;"	f	signature:(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
stbtt_GetGlyphBitmapBoxSubpixel	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);$/;"	p	signature:(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
stbtt_GetGlyphBitmapSubpixel	libs/imgui/stb_truetype.h	/^STBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff)$/;"	f	signature:(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff)
stbtt_GetGlyphBitmapSubpixel	libs/imgui/stb_truetype.h	/^STBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff);$/;"	p	signature:(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff)
stbtt_GetGlyphBox	libs/imgui/stb_truetype.h	/^STBTT_DEF int  stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);$/;"	p	signature:(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)
stbtt_GetGlyphBox	libs/imgui/stb_truetype.h	/^STBTT_DEF int stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)$/;"	f	signature:(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)
stbtt_GetGlyphHMetrics	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing)$/;"	f	signature:(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing)
stbtt_GetGlyphHMetrics	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing);$/;"	p	signature:(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing)
stbtt_GetGlyphKernAdvance	libs/imgui/stb_truetype.h	/^STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)$/;"	f	signature:(const stbtt_fontinfo *info, int glyph1, int glyph2)
stbtt_GetGlyphKernAdvance	libs/imgui/stb_truetype.h	/^STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2);$/;"	p	signature:(const stbtt_fontinfo *info, int glyph1, int glyph2)
stbtt_GetGlyphShape	libs/imgui/stb_truetype.h	/^STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)$/;"	f	signature:(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
stbtt_GetGlyphShape	libs/imgui/stb_truetype.h	/^STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **vertices);$/;"	p	signature:(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **vertices)
stbtt_GetPackedQuad	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_GetPackedQuad(stbtt_packedchar *chardata, int pw, int ph,  \/\/ same data as above$/;"	p	signature:(stbtt_packedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int align_to_integer)
stbtt_GetPackedQuad	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_GetPackedQuad(stbtt_packedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int align_to_integer)$/;"	f	signature:(stbtt_packedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int align_to_integer)
stbtt_InitFont	libs/imgui/stb_truetype.h	/^STBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset);$/;"	p	signature:(stbtt_fontinfo *info, const unsigned char *data, int offset)
stbtt_InitFont	libs/imgui/stb_truetype.h	/^STBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data2, int fontstart)$/;"	f	signature:(stbtt_fontinfo *info, const unsigned char *data2, int fontstart)
stbtt_IsGlyphEmpty	libs/imgui/stb_truetype.h	/^STBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index)$/;"	f	signature:(const stbtt_fontinfo *info, int glyph_index)
stbtt_IsGlyphEmpty	libs/imgui/stb_truetype.h	/^STBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index);$/;"	p	signature:(const stbtt_fontinfo *info, int glyph_index)
stbtt_MakeCodepointBitmap	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint)$/;"	f	signature:(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint)
stbtt_MakeCodepointBitmap	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint);$/;"	p	signature:(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint)
stbtt_MakeCodepointBitmapSubpixel	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint)$/;"	f	signature:(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint)
stbtt_MakeCodepointBitmapSubpixel	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint);$/;"	p	signature:(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint)
stbtt_MakeGlyphBitmap	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph)$/;"	f	signature:(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph)
stbtt_MakeGlyphBitmap	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph);$/;"	p	signature:(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph)
stbtt_MakeGlyphBitmapSubpixel	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph)$/;"	f	signature:(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph)
stbtt_MakeGlyphBitmapSubpixel	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph);$/;"	p	signature:(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph)
stbtt_PackBegin	libs/imgui/stb_truetype.h	/^STBTT_DEF int  stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int width, int height, int stride_in_bytes, int padding, void *alloc_context);$/;"	p	signature:(stbtt_pack_context *spc, unsigned char *pixels, int width, int height, int stride_in_bytes, int padding, void *alloc_context)
stbtt_PackBegin	libs/imgui/stb_truetype.h	/^STBTT_DEF int stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int pw, int ph, int stride_in_bytes, int padding, void *alloc_context)$/;"	f	signature:(stbtt_pack_context *spc, unsigned char *pixels, int pw, int ph, int stride_in_bytes, int padding, void *alloc_context)
stbtt_PackEnd	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc)$/;"	f	signature:(stbtt_pack_context *spc)
stbtt_PackEnd	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc);$/;"	p	signature:(stbtt_pack_context *spc)
stbtt_PackFontRange	libs/imgui/stb_truetype.h	/^STBTT_DEF int  stbtt_PackFontRange(stbtt_pack_context *spc, unsigned char *fontdata, int font_index, float font_size,$/;"	p	signature:(stbtt_pack_context *spc, unsigned char *fontdata, int font_index, float font_size, int first_unicode_char_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range)
stbtt_PackFontRange	libs/imgui/stb_truetype.h	/^STBTT_DEF int stbtt_PackFontRange(stbtt_pack_context *spc, unsigned char *fontdata, int font_index, float font_size,$/;"	f	signature:(stbtt_pack_context *spc, unsigned char *fontdata, int font_index, float font_size, int first_unicode_codepoint_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range)
stbtt_PackFontRanges	libs/imgui/stb_truetype.h	/^STBTT_DEF int  stbtt_PackFontRanges(stbtt_pack_context *spc, unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges);$/;"	p	signature:(stbtt_pack_context *spc, unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges)
stbtt_PackFontRanges	libs/imgui/stb_truetype.h	/^STBTT_DEF int stbtt_PackFontRanges(stbtt_pack_context *spc, unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges)$/;"	f	signature:(stbtt_pack_context *spc, unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges)
stbtt_PackFontRangesGatherRects	libs/imgui/stb_truetype.h	/^STBTT_DEF int  stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);$/;"	p	signature:(stbtt_pack_context *spc, stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)
stbtt_PackFontRangesGatherRects	libs/imgui/stb_truetype.h	/^STBTT_DEF int stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)$/;"	f	signature:(stbtt_pack_context *spc, stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)
stbtt_PackFontRangesPackRects	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects)$/;"	f	signature:(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects)
stbtt_PackFontRangesPackRects	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects);$/;"	p	signature:(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects)
stbtt_PackFontRangesRenderIntoRects	libs/imgui/stb_truetype.h	/^STBTT_DEF int  stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);$/;"	p	signature:(stbtt_pack_context *spc, stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)
stbtt_PackFontRangesRenderIntoRects	libs/imgui/stb_truetype.h	/^STBTT_DEF int stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)$/;"	f	signature:(stbtt_pack_context *spc, stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)
stbtt_PackSetOversampling	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample)$/;"	f	signature:(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample)
stbtt_PackSetOversampling	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample);$/;"	p	signature:(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample)
stbtt_Rasterize	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result, float flatness_in_pixels, stbtt_vertex *vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void *userdata)$/;"	f	signature:(stbtt__bitmap *result, float flatness_in_pixels, stbtt_vertex *vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void *userdata)
stbtt_Rasterize	libs/imgui/stb_truetype.h	/^STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result, float flatness_in_pixels, stbtt_vertex *vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void *userdata);$/;"	p	signature:(stbtt__bitmap *result, float flatness_in_pixels, stbtt_vertex *vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void *userdata)
stbtt_ScaleForMappingEmToPixels	libs/imgui/stb_truetype.h	/^STBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels)$/;"	f	signature:(const stbtt_fontinfo *info, float pixels)
stbtt_ScaleForMappingEmToPixels	libs/imgui/stb_truetype.h	/^STBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels);$/;"	p	signature:(const stbtt_fontinfo *info, float pixels)
stbtt_ScaleForPixelHeight	libs/imgui/stb_truetype.h	/^STBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float height)$/;"	f	signature:(const stbtt_fontinfo *info, float height)
stbtt_ScaleForPixelHeight	libs/imgui/stb_truetype.h	/^STBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float pixels);$/;"	p	signature:(const stbtt_fontinfo *info, float pixels)
stbtt__CompareUTF8toUTF16_bigendian_prefix	libs/imgui/stb_truetype.h	/^static stbtt_int32 stbtt__CompareUTF8toUTF16_bigendian_prefix(const stbtt_uint8 *s1, stbtt_int32 len1, const stbtt_uint8 *s2, stbtt_int32 len2) $/;"	f	signature:(const stbtt_uint8 *s1, stbtt_int32 len1, const stbtt_uint8 *s2, stbtt_int32 len2)
stbtt__GetGlyfOffset	libs/imgui/stb_truetype.h	/^static int stbtt__GetGlyfOffset(const stbtt_fontinfo *info, int glyph_index)$/;"	f	signature:(const stbtt_fontinfo *info, int glyph_index)
stbtt__active_edge	libs/imgui/stb_truetype.h	/^typedef struct stbtt__active_edge$/;"	s
stbtt__active_edge	libs/imgui/stb_truetype.h	/^} stbtt__active_edge;$/;"	t	typeref:struct:stbtt__active_edge
stbtt__active_edge::direction	libs/imgui/stb_truetype.h	/^   float direction;$/;"	m	struct:stbtt__active_edge	access:public
stbtt__active_edge::direction	libs/imgui/stb_truetype.h	/^   int direction;$/;"	m	struct:stbtt__active_edge	access:public
stbtt__active_edge::dx	libs/imgui/stb_truetype.h	/^   int x,dx;$/;"	m	struct:stbtt__active_edge	access:public
stbtt__active_edge::ey	libs/imgui/stb_truetype.h	/^   float ey;$/;"	m	struct:stbtt__active_edge	access:public
stbtt__active_edge::fdx	libs/imgui/stb_truetype.h	/^   float fx,fdx,fdy;$/;"	m	struct:stbtt__active_edge	access:public
stbtt__active_edge::fdy	libs/imgui/stb_truetype.h	/^   float fx,fdx,fdy;$/;"	m	struct:stbtt__active_edge	access:public
stbtt__active_edge::fx	libs/imgui/stb_truetype.h	/^   float fx,fdx,fdy;$/;"	m	struct:stbtt__active_edge	access:public
stbtt__active_edge::next	libs/imgui/stb_truetype.h	/^   struct stbtt__active_edge *next;$/;"	m	struct:stbtt__active_edge	typeref:struct:stbtt__active_edge::stbtt__active_edge	access:public
stbtt__active_edge::sy	libs/imgui/stb_truetype.h	/^   float sy;$/;"	m	struct:stbtt__active_edge	access:public
stbtt__active_edge::x	libs/imgui/stb_truetype.h	/^   int x,dx;$/;"	m	struct:stbtt__active_edge	access:public
stbtt__add_point	libs/imgui/stb_truetype.h	/^static void stbtt__add_point(stbtt__point *points, int n, float x, float y)$/;"	f	signature:(stbtt__point *points, int n, float x, float y)
stbtt__bitmap	libs/imgui/stb_truetype.h	/^} stbtt__bitmap;$/;"	t	typeref:struct:__anon13
stbtt__check_size16	libs/imgui/stb_truetype.h	/^   typedef char stbtt__check_size16[sizeof(stbtt_int16)==2 ? 1 : -1];$/;"	t
stbtt__check_size32	libs/imgui/stb_truetype.h	/^   typedef char stbtt__check_size32[sizeof(stbtt_int32)==4 ? 1 : -1];$/;"	t
stbtt__close_shape	libs/imgui/stb_truetype.h	/^static int stbtt__close_shape(stbtt_vertex *vertices, int num_vertices, int was_off, int start_off,$/;"	f	signature:(stbtt_vertex *vertices, int num_vertices, int was_off, int start_off, stbtt_int32 sx, stbtt_int32 sy, stbtt_int32 scx, stbtt_int32 scy, stbtt_int32 cx, stbtt_int32 cy)
stbtt__edge	libs/imgui/stb_truetype.h	/^typedef struct stbtt__edge {$/;"	s
stbtt__edge	libs/imgui/stb_truetype.h	/^} stbtt__edge;$/;"	t	typeref:struct:stbtt__edge
stbtt__edge::invert	libs/imgui/stb_truetype.h	/^   int invert;$/;"	m	struct:stbtt__edge	access:public
stbtt__edge::x0	libs/imgui/stb_truetype.h	/^   float x0,y0, x1,y1;$/;"	m	struct:stbtt__edge	access:public
stbtt__edge::x1	libs/imgui/stb_truetype.h	/^   float x0,y0, x1,y1;$/;"	m	struct:stbtt__edge	access:public
stbtt__edge::y0	libs/imgui/stb_truetype.h	/^   float x0,y0, x1,y1;$/;"	m	struct:stbtt__edge	access:public
stbtt__edge::y1	libs/imgui/stb_truetype.h	/^   float x0,y0, x1,y1;$/;"	m	struct:stbtt__edge	access:public
stbtt__fill_active_edges	libs/imgui/stb_truetype.h	/^static void stbtt__fill_active_edges(unsigned char *scanline, int len, stbtt__active_edge *e, int max_weight)$/;"	f	signature:(unsigned char *scanline, int len, stbtt__active_edge *e, int max_weight)
stbtt__fill_active_edges_new	libs/imgui/stb_truetype.h	/^static void stbtt__fill_active_edges_new(float *scanline, float *scanline_fill, int len, stbtt__active_edge *e, float y_top)$/;"	f	signature:(float *scanline, float *scanline_fill, int len, stbtt__active_edge *e, float y_top)
stbtt__find_table	libs/imgui/stb_truetype.h	/^static stbtt_uint32 stbtt__find_table(stbtt_uint8 *data, stbtt_uint32 fontstart, const char *tag)$/;"	f	signature:(stbtt_uint8 *data, stbtt_uint32 fontstart, const char *tag)
stbtt__h_prefilter	libs/imgui/stb_truetype.h	/^static void stbtt__h_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)$/;"	f	signature:(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)
stbtt__handle_clipped_edge	libs/imgui/stb_truetype.h	/^static void stbtt__handle_clipped_edge(float *scanline, int x, stbtt__active_edge *e, float x0, float y0, float x1, float y1)$/;"	f	signature:(float *scanline, int x, stbtt__active_edge *e, float x0, float y0, float x1, float y1)
stbtt__hheap	libs/imgui/stb_truetype.h	/^typedef struct stbtt__hheap$/;"	s
stbtt__hheap	libs/imgui/stb_truetype.h	/^} stbtt__hheap;$/;"	t	typeref:struct:stbtt__hheap
stbtt__hheap::first_free	libs/imgui/stb_truetype.h	/^   void   *first_free;$/;"	m	struct:stbtt__hheap	access:public
stbtt__hheap::head	libs/imgui/stb_truetype.h	/^   struct stbtt__hheap_chunk *head;$/;"	m	struct:stbtt__hheap	typeref:struct:stbtt__hheap::stbtt__hheap_chunk	access:public
stbtt__hheap::num_remaining_in_head_chunk	libs/imgui/stb_truetype.h	/^   int    num_remaining_in_head_chunk;$/;"	m	struct:stbtt__hheap	access:public
stbtt__hheap_alloc	libs/imgui/stb_truetype.h	/^static void *stbtt__hheap_alloc(stbtt__hheap *hh, size_t size, void *userdata)$/;"	f	signature:(stbtt__hheap *hh, size_t size, void *userdata)
stbtt__hheap_chunk	libs/imgui/stb_truetype.h	/^typedef struct stbtt__hheap_chunk$/;"	s
stbtt__hheap_chunk	libs/imgui/stb_truetype.h	/^} stbtt__hheap_chunk;$/;"	t	typeref:struct:stbtt__hheap_chunk
stbtt__hheap_chunk::next	libs/imgui/stb_truetype.h	/^   struct stbtt__hheap_chunk *next;$/;"	m	struct:stbtt__hheap_chunk	typeref:struct:stbtt__hheap_chunk::stbtt__hheap_chunk	access:public
stbtt__hheap_cleanup	libs/imgui/stb_truetype.h	/^static void stbtt__hheap_cleanup(stbtt__hheap *hh, void *userdata)$/;"	f	signature:(stbtt__hheap *hh, void *userdata)
stbtt__hheap_free	libs/imgui/stb_truetype.h	/^static void stbtt__hheap_free(stbtt__hheap *hh, void *p)$/;"	f	signature:(stbtt__hheap *hh, void *p)
stbtt__isfont	libs/imgui/stb_truetype.h	/^static int stbtt__isfont(const stbtt_uint8 *font)$/;"	f	signature:(const stbtt_uint8 *font)
stbtt__matches	libs/imgui/stb_truetype.h	/^static int stbtt__matches(stbtt_uint8 *fc, stbtt_uint32 offset, stbtt_uint8 *name, stbtt_int32 flags)$/;"	f	signature:(stbtt_uint8 *fc, stbtt_uint32 offset, stbtt_uint8 *name, stbtt_int32 flags)
stbtt__matchpair	libs/imgui/stb_truetype.h	/^static int stbtt__matchpair(stbtt_uint8 *fc, stbtt_uint32 nm, stbtt_uint8 *name, stbtt_int32 nlen, stbtt_int32 target_id, stbtt_int32 next_id)$/;"	f	signature:(stbtt_uint8 *fc, stbtt_uint32 nm, stbtt_uint8 *name, stbtt_int32 nlen, stbtt_int32 target_id, stbtt_int32 next_id)
stbtt__new_active	libs/imgui/stb_truetype.h	/^static stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)$/;"	f	signature:(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)
stbtt__oversample_shift	libs/imgui/stb_truetype.h	/^static float stbtt__oversample_shift(int oversample)$/;"	f	signature:(int oversample)
stbtt__point	libs/imgui/stb_truetype.h	/^} stbtt__point;$/;"	t	typeref:struct:__anon20
stbtt__rasterize	libs/imgui/stb_truetype.h	/^static void stbtt__rasterize(stbtt__bitmap *result, stbtt__point *pts, int *wcount, int windings, float scale_x, float scale_y, float shift_x, float shift_y, int off_x, int off_y, int invert, void *userdata)$/;"	f	signature:(stbtt__bitmap *result, stbtt__point *pts, int *wcount, int windings, float scale_x, float scale_y, float shift_x, float shift_y, int off_x, int off_y, int invert, void *userdata)
stbtt__rasterize_sorted_edges	libs/imgui/stb_truetype.h	/^static void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)$/;"	f	signature:(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)
stbtt__sort_edges	libs/imgui/stb_truetype.h	/^static void stbtt__sort_edges(stbtt__edge *p, int n)$/;"	f	signature:(stbtt__edge *p, int n)
stbtt__sort_edges_ins_sort	libs/imgui/stb_truetype.h	/^static void stbtt__sort_edges_ins_sort(stbtt__edge *p, int n)$/;"	f	signature:(stbtt__edge *p, int n)
stbtt__sort_edges_quicksort	libs/imgui/stb_truetype.h	/^static void stbtt__sort_edges_quicksort(stbtt__edge *p, int n)$/;"	f	signature:(stbtt__edge *p, int n)
stbtt__tesselate_curve	libs/imgui/stb_truetype.h	/^static int stbtt__tesselate_curve(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float objspace_flatness_squared, int n)$/;"	f	signature:(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float objspace_flatness_squared, int n)
stbtt__test_oversample_pow2	libs/imgui/stb_truetype.h	/^typedef int stbtt__test_oversample_pow2[(STBTT_MAX_OVERSAMPLE & (STBTT_MAX_OVERSAMPLE-1)) == 0 ? 1 : -1];$/;"	t
stbtt__v_prefilter	libs/imgui/stb_truetype.h	/^static void stbtt__v_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)$/;"	f	signature:(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)
stbtt_aligned_quad	libs/imgui/stb_truetype.h	/^} stbtt_aligned_quad;$/;"	t	typeref:struct:__anon8
stbtt_bakedchar	libs/imgui/stb_truetype.h	/^} stbtt_bakedchar;$/;"	t	typeref:struct:__anon7
stbtt_fontinfo	libs/imgui/stb_truetype.h	/^typedef struct stbtt_fontinfo stbtt_fontinfo;$/;"	t	typeref:struct:stbtt_fontinfo
stbtt_fontinfo	libs/imgui/stb_truetype.h	/^typedef struct stbtt_fontinfo$/;"	s
stbtt_fontinfo	libs/imgui/stb_truetype.h	/^} stbtt_fontinfo;$/;"	t	typeref:struct:stbtt_fontinfo
stbtt_fontinfo::data	libs/imgui/stb_truetype.h	/^   unsigned char  * data;              \/\/ pointer to .ttf file$/;"	m	struct:stbtt_fontinfo	access:public
stbtt_fontinfo::fontstart	libs/imgui/stb_truetype.h	/^   int              fontstart;         \/\/ offset of start of font$/;"	m	struct:stbtt_fontinfo	access:public
stbtt_fontinfo::glyf	libs/imgui/stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo	access:public
stbtt_fontinfo::head	libs/imgui/stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo	access:public
stbtt_fontinfo::hhea	libs/imgui/stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo	access:public
stbtt_fontinfo::hmtx	libs/imgui/stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo	access:public
stbtt_fontinfo::indexToLocFormat	libs/imgui/stb_truetype.h	/^   int indexToLocFormat;              \/\/ format needed to map from glyph index to glyph$/;"	m	struct:stbtt_fontinfo	access:public
stbtt_fontinfo::index_map	libs/imgui/stb_truetype.h	/^   int index_map;                     \/\/ a cmap mapping for our chosen character encoding$/;"	m	struct:stbtt_fontinfo	access:public
stbtt_fontinfo::kern	libs/imgui/stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo	access:public
stbtt_fontinfo::loca	libs/imgui/stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo	access:public
stbtt_fontinfo::numGlyphs	libs/imgui/stb_truetype.h	/^   int numGlyphs;                     \/\/ number of glyphs, needed for range checking$/;"	m	struct:stbtt_fontinfo	access:public
stbtt_fontinfo::userdata	libs/imgui/stb_truetype.h	/^   void           * userdata;$/;"	m	struct:stbtt_fontinfo	access:public
stbtt_int16	libs/imgui/stb_truetype.h	/^   typedef signed   short  stbtt_int16;$/;"	t
stbtt_int32	libs/imgui/stb_truetype.h	/^   typedef signed   int    stbtt_int32;$/;"	t
stbtt_int8	libs/imgui/stb_truetype.h	/^   typedef signed   char   stbtt_int8;$/;"	t
stbtt_pack_context	libs/imgui/stb_truetype.h	/^struct stbtt_pack_context {$/;"	s
stbtt_pack_context	libs/imgui/stb_truetype.h	/^typedef struct stbtt_pack_context stbtt_pack_context;$/;"	t	typeref:struct:stbtt_pack_context
stbtt_pack_context::h_oversample	libs/imgui/stb_truetype.h	/^   unsigned int   h_oversample, v_oversample;$/;"	m	struct:stbtt_pack_context	access:public
stbtt_pack_context::height	libs/imgui/stb_truetype.h	/^   int   height;$/;"	m	struct:stbtt_pack_context	access:public
stbtt_pack_context::nodes	libs/imgui/stb_truetype.h	/^   void  *nodes;$/;"	m	struct:stbtt_pack_context	access:public
stbtt_pack_context::pack_info	libs/imgui/stb_truetype.h	/^   void *pack_info;$/;"	m	struct:stbtt_pack_context	access:public
stbtt_pack_context::padding	libs/imgui/stb_truetype.h	/^   int   padding;$/;"	m	struct:stbtt_pack_context	access:public
stbtt_pack_context::pixels	libs/imgui/stb_truetype.h	/^   unsigned char *pixels;$/;"	m	struct:stbtt_pack_context	access:public
stbtt_pack_context::stride_in_bytes	libs/imgui/stb_truetype.h	/^   int   stride_in_bytes;$/;"	m	struct:stbtt_pack_context	access:public
stbtt_pack_context::user_allocator_context	libs/imgui/stb_truetype.h	/^   void *user_allocator_context;$/;"	m	struct:stbtt_pack_context	access:public
stbtt_pack_context::v_oversample	libs/imgui/stb_truetype.h	/^   unsigned int   h_oversample, v_oversample;$/;"	m	struct:stbtt_pack_context	access:public
stbtt_pack_context::width	libs/imgui/stb_truetype.h	/^   int   width;$/;"	m	struct:stbtt_pack_context	access:public
stbtt_pack_range	libs/imgui/stb_truetype.h	/^} stbtt_pack_range;$/;"	t	typeref:struct:__anon10
stbtt_packedchar	libs/imgui/stb_truetype.h	/^} stbtt_packedchar;$/;"	t	typeref:struct:__anon9
stbtt_setvertex	libs/imgui/stb_truetype.h	/^static void stbtt_setvertex(stbtt_vertex *v, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy)$/;"	f	signature:(stbtt_vertex *v, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy)
stbtt_tag	libs/imgui/stb_truetype.h	959;"	d
stbtt_tag4	libs/imgui/stb_truetype.h	958;"	d
stbtt_uint16	libs/imgui/stb_truetype.h	/^   typedef unsigned short  stbtt_uint16;$/;"	t
stbtt_uint32	libs/imgui/stb_truetype.h	/^   typedef unsigned int    stbtt_uint32;$/;"	t
stbtt_uint8	libs/imgui/stb_truetype.h	/^   typedef unsigned char   stbtt_uint8;$/;"	t
stbtt_vertex	libs/imgui/stb_truetype.h	/^   } stbtt_vertex;$/;"	t	typeref:struct:__anon12
stbtt_vertex_type	libs/imgui/stb_truetype.h	720;"	d
stride	libs/imgui/stb_truetype.h	/^   int w,h,stride;$/;"	m	struct:__anon13	access:public
stride_in_bytes	libs/imgui/stb_truetype.h	/^   int   stride_in_bytes;$/;"	m	struct:stbtt_pack_context	access:public
swap	include/Window.h	/^    void swap();$/;"	p	namespace:Window	signature:()
swap	libs/imgui/imgui.h	/^    inline void                 swap(ImVector<T>& rhs)          { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; value_type* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }$/;"	f	class:ImVector	access:public	signature:(ImVector<T>& rhs)
swap	src/Window.cpp	/^    void swap() {$/;"	f	namespace:Window	signature:()
swap	src/legacy/Window.cpp	/^    void swap() {$/;"	f	namespace:Window	signature:()
switchInput	src/Game.cpp	/^    bool switchInput = false;$/;"	m	namespace:Game	file:
sy	libs/imgui/stb_truetype.h	/^   float sy;$/;"	m	struct:stbtt__active_edge	access:public
t0	libs/imgui/stb_truetype.h	/^   float x0,y0,s0,t0; \/\/ top-left$/;"	m	struct:__anon8	access:public
t1	libs/imgui/stb_truetype.h	/^   float x1,y1,s1,t1; \/\/ bottom-right$/;"	m	struct:__anon8	access:public
temp_bitmap	libs/imgui/stb_truetype.h	/^unsigned char temp_bitmap[512*512];$/;"	v
terminate	include/Window.h	/^    void terminate();$/;"	p	namespace:Window	signature:()
terminate	src/Window.cpp	/^    void terminate() {$/;"	f	namespace:Window	signature:()
terminate	src/legacy/Window.cpp	/^    void terminate() {$/;"	f	namespace:Window	signature:()
test	include/gfx/Render.h	/^    void test(vec4 position);$/;"	p	namespace:Render	signature:(vec4 position)
test	src/legacy/Render.cpp	/^    void test() {$/;"	f	namespace:Render	signature:()
tex	src/entities/Entity.cpp	/^static int tex = 0;$/;"	v	file:
tex	src/gfx/Font.cpp	/^    GLuint tex;$/;"	m	namespace:Font	file:
tick	include/entities/Entity.h	/^	void tick();$/;"	p	class:Entity	access:public	signature:()
tick	include/gfx/Camera.h	/^    void tick();$/;"	p	namespace:Camera	signature:()
tick	include/level/Level.h	/^    void tick();$/;"	p	namespace:Level	signature:()
tick	src/Game.cpp	/^    void tick() {$/;"	f	namespace:Game	signature:()
tick	src/Game.cpp	/^    void tick();$/;"	p	namespace:Game	file:	signature:()
tick	src/entities/Entity.cpp	/^void Entity::tick() {$/;"	f	class:Entity	signature:()
tick	src/gfx/Camera.cpp	/^    void tick() {$/;"	f	namespace:Camera	signature:()
tick	src/level/Level.cpp	/^    void tick() {$/;"	f	namespace:Level	signature:()
ticks	src/Game.cpp	/^    int ticks = 0;$/;"	m	namespace:Game	file:
tile	include/gfx/Render.h	/^    void tile(vec4 position, GLuint tex);$/;"	p	namespace:Render	signature:(vec4 position, GLuint tex)
tile	src/gfx/Render.cpp	/^    void tile(vec4 position, GLuint tex) {$/;"	f	namespace:Render	signature:(vec4 position, GLuint tex)
tile	src/legacy/Render.cpp	/^    void tile(vec4 position, GLuint tex) {$/;"	f	namespace:Render	signature:(vec4 position, GLuint tex)
tileMatrixID	src/gfx/Render.cpp	/^    GLuint tileMatrixID;$/;"	m	namespace:Render	file:
tileOffset	src/level/Level.cpp	/^    const mat4 tileOffset = translate(IDENTITY, vec3(8, 8, 0));$/;"	m	namespace:Level	file:
tileProgramID	src/gfx/Render.cpp	/^    GLuint tileProgramID;$/;"	m	namespace:Render	file:
tileScale	src/level/Level.cpp	/^    const mat4 tileScale = scale(IDENTITY, vec3(Level::tileScaleInt));$/;"	m	namespace:Level	file:
tileScaleInt	include/level/Level.h	/^    const int tileScaleInt = 16;$/;"	m	namespace:Level
tileTextureHandler	src/gfx/Render.cpp	/^    GLuint tileTextureHandler;$/;"	m	namespace:Render	file:
tileUVBuffer	src/gfx/Render.cpp	/^    GLuint tileUVBuffer;$/;"	m	namespace:Render	file:
tileVertexBuffer	src/gfx/Render.cpp	/^    GLuint tileVertexBuffer;$/;"	m	namespace:Render	file:
tiles	src/level/Tile.cpp	/^uint tiles[256] = {0x00};$/;"	v
toMove	src/gfx/Camera.cpp	/^    vec4 toMove = vec4(0, 0, 0, 0);$/;"	m	namespace:Camera	file:
trim_blanks	libs/imgui/imgui.h	/^        void trim_blanks() { while (b < e && isblank(*b)) b++; while (e > b && isblank(*(e-1))) e--; }$/;"	f	struct:ImGuiTextFilter::TextRange	access:public	signature:()
ttBYTE	libs/imgui/stb_truetype.h	938;"	d
ttCHAR	libs/imgui/stb_truetype.h	939;"	d
ttFixed	libs/imgui/stb_truetype.h	940;"	d
ttLONG	libs/imgui/stb_truetype.h	/^   static stbtt_int32 ttLONG(const stbtt_uint8 *p)    { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }$/;"	f	signature:(const stbtt_uint8 *p)
ttLONG	libs/imgui/stb_truetype.h	947;"	d
ttSHORT	libs/imgui/stb_truetype.h	/^   static stbtt_int16 ttSHORT(const stbtt_uint8 *p)   { return p[0]*256 + p[1]; }$/;"	f	signature:(const stbtt_uint8 *p)
ttSHORT	libs/imgui/stb_truetype.h	945;"	d
ttULONG	libs/imgui/stb_truetype.h	/^   static stbtt_uint32 ttULONG(const stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }$/;"	f	signature:(const stbtt_uint8 *p)
ttULONG	libs/imgui/stb_truetype.h	946;"	d
ttUSHORT	libs/imgui/stb_truetype.h	/^   static stbtt_uint16 ttUSHORT(const stbtt_uint8 *p) { return p[0]*256 + p[1]; }$/;"	f	signature:(const stbtt_uint8 *p)
ttUSHORT	libs/imgui/stb_truetype.h	944;"	d
ttf_buffer	libs/imgui/stb_truetype.h	/^char ttf_buffer[1<<25];$/;"	v
ttf_buffer	libs/imgui/stb_truetype.h	/^unsigned char ttf_buffer[1<<20];$/;"	v
tweakBarInit	src/legacy/Window.cpp	/^    void tweakBarInit() {$/;"	f	namespace:Window	signature:()
tweakBarInit	src/legacy/Window.cpp	/^    void tweakBarInit();$/;"	p	namespace:Window	file:	signature:()
tween	src/gfx/Camera.cpp	/^    mat4 tween = scale(IDENTITY, vec3(tweenFloat, tweenFloat, 1));$/;"	m	namespace:Camera	file:
tweenFloat	src/gfx/Camera.cpp	/^    float tweenFloat = 0.1 * VT;$/;"	m	namespace:Camera	file:
type	GaffMaker/include/Definitions.h	/^	    byte type = 0x00;$/;"	m	struct:Gaff::fileInfo	access:public
type	include/Definitions.h	/^	    byte type = 0x00;$/;"	m	struct:Gaff::fileInfo	access:public
type	libs/imgui/stb_truetype.h	/^      unsigned char type,padding;$/;"	m	struct:__anon12	access:public
uint	GaffMaker/include/Definitions.h	/^typedef unsigned int uint;$/;"	t
uint	include/Definitions.h	/^typedef unsigned int uint;$/;"	t
undo_char	libs/imgui/stb_textedit.h	/^   STB_TEXTEDIT_CHARTYPE  undo_char[STB_TEXTEDIT_UNDOCHARCOUNT];$/;"	m	struct:__anon3	access:public
undo_char_point	libs/imgui/stb_textedit.h	/^   short undo_char_point, redo_char_point;$/;"	m	struct:__anon3	access:public
undo_point	libs/imgui/stb_textedit.h	/^   short undo_point, redo_point;$/;"	m	struct:__anon3	access:public
undo_rec	libs/imgui/stb_textedit.h	/^   StbUndoRecord          undo_rec [STB_TEXTEDIT_UNDOSTATECOUNT];$/;"	m	struct:__anon3	access:public
undostate	libs/imgui/stb_textedit.h	/^   StbUndoState undostate;$/;"	m	struct:__anon4	access:public
user_allocator_context	libs/imgui/stb_truetype.h	/^   void *user_allocator_context;$/;"	m	struct:stbtt_pack_context	access:public
userdata	libs/imgui/stb_truetype.h	/^   void           * userdata;$/;"	m	struct:stbtt_fontinfo	access:public
uv	libs/imgui/imgui.h	/^    ImVec2  uv;$/;"	m	struct:ImDrawVert	access:public
v_oversample	libs/imgui/stb_truetype.h	/^   unsigned char h_oversample, v_oversample; \/\/ don't set these, they're used internally$/;"	m	struct:__anon10	access:public
v_oversample	libs/imgui/stb_truetype.h	/^   unsigned int   h_oversample, v_oversample;$/;"	m	struct:stbtt_pack_context	access:public
va_copy	libs/imgui/imgui.cpp	1806;"	d	file:
val_f	libs/imgui/imgui.h	/^        union { int val_i; float val_f; void* val_p; };        $/;"	m	union:ImGuiStorage::Pair::__anon1	access:public
val_i	libs/imgui/imgui.h	/^        union { int val_i; float val_f; void* val_p; };        $/;"	m	union:ImGuiStorage::Pair::__anon1	access:public
val_p	libs/imgui/imgui.h	/^        union { int val_i; float val_f; void* val_p; };        $/;"	m	union:ImGuiStorage::Pair::__anon1	access:public
value_type	libs/imgui/imgui.h	/^    typedef T                   value_type;$/;"	t	class:ImVector	access:public
velocity	src/entities/Entity.cpp	/^vec4 velocity = vec4(0, 0, 0, 0);$/;"	v
view	src/gfx/Render.cpp	/^    vec4 view = vec4(0, 0, 10, 1);$/;"	m	namespace:Render	file:
view	src/legacy/Render.cpp	/^    vec4 view = vec4(0, 0, 0, 1);$/;"	m	namespace:Render	file:
viewMatrix	src/gfx/Render.cpp	/^    mat4 viewMatrix = lookAt(vec3(view.x, view.y, view.z), vec3(view.x, view.y, view.z-1), vec3(0, 1, 0));$/;"	m	namespace:Render	file:
viewMatrix	src/legacy/Render.cpp	/^    mat4 viewMatrix = translate(IDENTITY, vec3(0));$/;"	m	namespace:Render	file:
vsize	src/Game.cpp	/^    float vsize = proc.vsize \/ 1000000;$/;"	m	namespace:Game	file:
w	libs/imgui/imgui.h	/^    float x, y, z, w;$/;"	m	struct:ImVec4	access:public
w	libs/imgui/stb_rect_pack.h	/^   stbrp_coord    w, h;$/;"	m	struct:stbrp_rect	access:public
w	libs/imgui/stb_truetype.h	/^   int id,w,h,was_packed;$/;"	m	struct:stbrp_rect	access:public
w	libs/imgui/stb_truetype.h	/^   int w,h,stride;$/;"	m	struct:__anon13	access:public
was_packed	libs/imgui/stb_rect_pack.h	/^   int            was_packed;  \/\/ non-zero if valid packing$/;"	m	struct:stbrp_rect	access:public
was_packed	libs/imgui/stb_truetype.h	/^   int id,w,h,was_packed;$/;"	m	struct:stbrp_rect	access:public
where	libs/imgui/stb_textedit.h	/^   STB_TEXTEDIT_POSITIONTYPE  where;$/;"	m	struct:__anon2	access:public
width	GaffMaker/include/LoadPNG.h	/^    short width = 0;$/;"	m	struct:image	access:public
width	include/level/Level.h	/^    const int width = 64;$/;"	m	namespace:Level
width	libs/imgui/stb_rect_pack.h	/^   int width;$/;"	m	struct:stbrp_context	access:public
width	libs/imgui/stb_truetype.h	/^   int   width;$/;"	m	struct:stbtt_pack_context	access:public
width	libs/imgui/stb_truetype.h	/^   int width,height;$/;"	m	struct:__anon21	access:public
window	src/Window.cpp	/^    GLFWwindow* window;$/;"	m	namespace:Window	file:
window	src/legacy/Window.cpp	/^    GLFWwindow* window;$/;"	m	namespace:Window	file:
x	libs/imgui/imgui.h	/^    float x, y, z, w;$/;"	m	struct:ImVec4	access:public
x	libs/imgui/imgui.h	/^    float x, y;$/;"	m	struct:ImVec2	access:public
x	libs/imgui/stb_rect_pack.h	/^   int x,y;$/;"	m	struct:__anon25	access:public
x	libs/imgui/stb_rect_pack.h	/^   stbrp_coord    x, y;$/;"	m	struct:stbrp_rect	access:public
x	libs/imgui/stb_rect_pack.h	/^   stbrp_coord  x,y;$/;"	m	struct:stbrp_node	access:public
x	libs/imgui/stb_textedit.h	/^   float x,y;    \/\/ position of n'th character$/;"	m	struct:__anon6	access:public
x	libs/imgui/stb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy;$/;"	m	struct:__anon12	access:public
x	libs/imgui/stb_truetype.h	/^   float x,y;$/;"	m	struct:__anon20	access:public
x	libs/imgui/stb_truetype.h	/^   int x,dx;$/;"	m	struct:stbtt__active_edge	access:public
x	libs/imgui/stb_truetype.h	/^   int x,y,bottom_y;$/;"	m	struct:__anon21	access:public
x	libs/imgui/stb_truetype.h	/^   stbrp_coord x,y;$/;"	m	struct:stbrp_rect	access:public
x	libs/imgui/stb_truetype.h	/^   unsigned char x;$/;"	m	struct:__anon22	access:public
x0	libs/imgui/stb_textedit.h	/^   float x0,x1;             \/\/ starting x location, end x location (allows for align=right, etc)$/;"	m	struct:__anon5	access:public
x0	libs/imgui/stb_truetype.h	/^   float x0,y0, x1,y1;$/;"	m	struct:stbtt__edge	access:public
x0	libs/imgui/stb_truetype.h	/^   float x0,y0,s0,t0; \/\/ top-left$/;"	m	struct:__anon8	access:public
x0	libs/imgui/stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon7	access:public
x0	libs/imgui/stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon9	access:public
x1	libs/imgui/stb_textedit.h	/^   float x0,x1;             \/\/ starting x location, end x location (allows for align=right, etc)$/;"	m	struct:__anon5	access:public
x1	libs/imgui/stb_truetype.h	/^   float x0,y0, x1,y1;$/;"	m	struct:stbtt__edge	access:public
x1	libs/imgui/stb_truetype.h	/^   float x1,y1,s1,t1; \/\/ bottom-right$/;"	m	struct:__anon8	access:public
x1	libs/imgui/stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon7	access:public
x1	libs/imgui/stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon9	access:public
xadvance	libs/imgui/stb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon7	access:public
xadvance	libs/imgui/stb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon9	access:public
xoff	libs/imgui/stb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon7	access:public
xoff	libs/imgui/stb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon9	access:public
xoff2	libs/imgui/stb_truetype.h	/^   float xoff2,yoff2;$/;"	m	struct:__anon9	access:public
y	libs/imgui/imgui.h	/^    float x, y, z, w;$/;"	m	struct:ImVec4	access:public
y	libs/imgui/imgui.h	/^    float x, y;$/;"	m	struct:ImVec2	access:public
y	libs/imgui/stb_rect_pack.h	/^   int x,y;$/;"	m	struct:__anon25	access:public
y	libs/imgui/stb_rect_pack.h	/^   stbrp_coord    x, y;$/;"	m	struct:stbrp_rect	access:public
y	libs/imgui/stb_rect_pack.h	/^   stbrp_coord  x,y;$/;"	m	struct:stbrp_node	access:public
y	libs/imgui/stb_textedit.h	/^   float x,y;    \/\/ position of n'th character$/;"	m	struct:__anon6	access:public
y	libs/imgui/stb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy;$/;"	m	struct:__anon12	access:public
y	libs/imgui/stb_truetype.h	/^   float x,y;$/;"	m	struct:__anon20	access:public
y	libs/imgui/stb_truetype.h	/^   int x,y,bottom_y;$/;"	m	struct:__anon21	access:public
y	libs/imgui/stb_truetype.h	/^   stbrp_coord x,y;$/;"	m	struct:stbrp_rect	access:public
y0	libs/imgui/stb_truetype.h	/^   float x0,y0, x1,y1;$/;"	m	struct:stbtt__edge	access:public
y0	libs/imgui/stb_truetype.h	/^   float x0,y0,s0,t0; \/\/ top-left$/;"	m	struct:__anon8	access:public
y0	libs/imgui/stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon7	access:public
y0	libs/imgui/stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon9	access:public
y1	libs/imgui/stb_truetype.h	/^   float x0,y0, x1,y1;$/;"	m	struct:stbtt__edge	access:public
y1	libs/imgui/stb_truetype.h	/^   float x1,y1,s1,t1; \/\/ bottom-right$/;"	m	struct:__anon8	access:public
y1	libs/imgui/stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon7	access:public
y1	libs/imgui/stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon9	access:public
ymax	libs/imgui/stb_textedit.h	/^   float ymin,ymax;         \/\/ height of row above and below baseline$/;"	m	struct:__anon5	access:public
ymin	libs/imgui/stb_textedit.h	/^   float ymin,ymax;         \/\/ height of row above and below baseline$/;"	m	struct:__anon5	access:public
yoff	libs/imgui/stb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon7	access:public
yoff	libs/imgui/stb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon9	access:public
yoff2	libs/imgui/stb_truetype.h	/^   float xoff2,yoff2;$/;"	m	struct:__anon9	access:public
z	libs/imgui/imgui.h	/^    float x, y, z, w;$/;"	m	struct:ImVec4	access:public
~Console	src/util/Console.cpp	/^	~Console()$/;"	f	struct:Console::Console	access:public	signature:()
~ExampleAppConsole	libs/imgui/imgui.cpp	/^    ~ExampleAppConsole()$/;"	f	struct:ExampleAppConsole	access:public	signature:()
~ImDrawList	libs/imgui/imgui.h	/^    ~ImDrawList() { ClearFreeMemory(); }$/;"	f	struct:ImDrawList	access:public	signature:()
~ImFont	libs/imgui/imgui.cpp	/^ImFont::~ImFont()$/;"	f	class:ImFont	signature:()
~ImFont	libs/imgui/imgui.h	/^    IMGUI_API ~ImFont();$/;"	p	struct:ImFont	access:public	signature:()
~ImFontAtlas	libs/imgui/imgui.cpp	/^ImFontAtlas::~ImFontAtlas()$/;"	f	class:ImFontAtlas	signature:()
~ImFontAtlas	libs/imgui/imgui.h	/^    IMGUI_API ~ImFontAtlas();$/;"	p	struct:ImFontAtlas	access:public	signature:()
~ImGuiListClipper	libs/imgui/imgui.h	/^    ~ImGuiListClipper()                        { IM_ASSERT(ItemsCount == -1); } \/\/ user forgot to call End()$/;"	f	struct:ImGuiListClipper	access:public	signature:()
~ImGuiWindow	libs/imgui/imgui.cpp	/^    ~ImGuiWindow();$/;"	p	struct:ImGuiWindow	file:	access:public	signature:()
~ImGuiWindow	libs/imgui/imgui.cpp	/^ImGuiWindow::~ImGuiWindow()$/;"	f	class:ImGuiWindow	signature:()
~ImVector	libs/imgui/imgui.h	/^    ~ImVector()                 { if (Data) ImGui::MemFree(Data); }$/;"	f	class:ImVector	access:public	signature:()
